#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <pybind11/numpy.h>

#include "imgui-knobs/imgui-knobs.h"  // Change this include to the library you are binding

#include "implot/implot.h"
#include <iostream>

namespace py = pybind11;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

template<typename T>
void MyLog(T* values, int count)
{
    for(int i = 0; i < count; ++i)
        std::cout << "i=" << i << " value=" << (int)values[i] << "\n";
}

void py_init_module_imgui_knobs(py::module& m)
{
    m.def("my_log",    // implot.h:868
          [](const py::array & values)
          {
              auto PlotBars_adapt_c_buffers = [=](const py::array & values)
              {
                  // convert py::array to C standard buffer (const)
                  const void * values_from_pyarray = values.data();
                  py::ssize_t values_count = values.shape()[0];

                  // call the correct template version by casting
                  char values_type = values.dtype().char_();
                  std::cout << "values_type=" << values_type << "\n";

                  if (values_type == 'B')
                      MyLog(static_cast<const uint8_t *>(values_from_pyarray), static_cast<int>(values_count));
                  else if (values_type == 'b')
                      MyLog(static_cast<const int8_t *>(values_from_pyarray), static_cast<int>(values_count));
                  else if (values_type == 'H')
                      MyLog(static_cast<const uint16_t *>(values_from_pyarray), static_cast<int>(values_count));
                  else if (values_type == 'h')
                      MyLog(static_cast<const int16_t *>(values_from_pyarray), static_cast<int>(values_count));
                  else if (values_type == 'I')
                      MyLog(static_cast<const uint32_t *>(values_from_pyarray), static_cast<int>(values_count));
                  else if (values_type == 'i')
                      MyLog(static_cast<const int32_t *>(values_from_pyarray), static_cast<int>(values_count));
                  else if (values_type == 'L')
                      //MyLog(static_cast<const uint64_t *>(values_from_pyarray), static_cast<int>(values_count));
                      MyLog(static_cast<const int *>(values_from_pyarray), static_cast<int>(values_count));
                  else if (values_type == 'l')
                      //MyLog(static_cast<const int64_t *>(values_from_pyarray), static_cast<int>(values_count));
                      MyLog(static_cast<const int *>(values_from_pyarray), static_cast<int>(values_count));
                  else if (values_type == 'f')
                      MyLog(static_cast<const float *>(values_from_pyarray), static_cast<int>(values_count));
                  else if (values_type == 'd')
                      MyLog(static_cast<const double *>(values_from_pyarray), static_cast<int>(values_count));
                  else if (values_type == 'g')
                      MyLog(static_cast<const long double *>(values_from_pyarray), static_cast<int>(values_count));
                  else if (values_type == 'q')
                      MyLog(static_cast<const long long *>(values_from_pyarray), static_cast<int>(values_count));
                      // If we reach this point, the array type is not supported!
                  else
                      throw std::runtime_error(std::string("Bad array type ('") + values_type + "') for param values");
              };

              PlotBars_adapt_c_buffers(values);
          },     py::arg("values"));

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:imgui-knobs.h>    ////////////////////
    py::enum_<ImGuiKnobFlags_>(m, "ImGuiKnobFlags_", py::arithmetic(), "")
        .value("no_title", ImGuiKnobFlags_NoTitle, "")
        .value("no_input", ImGuiKnobFlags_NoInput, "")
        .value("value_tooltip", ImGuiKnobFlags_ValueTooltip, "")
        .value("drag_horizontal", ImGuiKnobFlags_DragHorizontal, "");


    py::enum_<ImGuiKnobVariant_>(m, "ImGuiKnobVariant_", py::arithmetic(), "")
        .value("tick", ImGuiKnobVariant_Tick, "")
        .value("dot", ImGuiKnobVariant_Dot, "")
        .value("wiper", ImGuiKnobVariant_Wiper, "")
        .value("wiper_only", ImGuiKnobVariant_WiperOnly, "")
        .value("wiper_dot", ImGuiKnobVariant_WiperDot, "")
        .value("stepped", ImGuiKnobVariant_Stepped, "")
        .value("space", ImGuiKnobVariant_Space, "");


    auto pyClasscolor_set =
        py::class_<ImGuiKnobs::color_set>
            (m, "color_set", "")
        .def_readwrite("base", &ImGuiKnobs::color_set::base, "")
        .def_readwrite("hovered", &ImGuiKnobs::color_set::hovered, "")
        .def_readwrite("active", &ImGuiKnobs::color_set::active, "")
        .def(py::init<ImColor, ImColor, ImColor>(),
            py::arg("base"), py::arg("hovered"), py::arg("active"))
        .def(py::init<ImColor>(),
            py::arg("color"))
        ;


    m.def("knob",
        [](const char * label, float p_value, float v_min, float v_max, float speed = 0, const char * format = NULL, ImGuiKnobVariant variant = ImGuiKnobVariant_Tick, float size = 0, ImGuiKnobFlags flags = 0, int steps = 10) -> std::tuple<bool, float>
        {
            auto Knob_adapt_modifiable_immutable_to_return = [](const char * label, float p_value, float v_min, float v_max, float speed = 0, const char * format = NULL, ImGuiKnobVariant variant = ImGuiKnobVariant_Tick, float size = 0, ImGuiKnobFlags flags = 0, int steps = 10) -> std::tuple<bool, float>
            {
                float * p_value_adapt_modifiable = & p_value;

                bool r = ImGuiKnobs::Knob(label, p_value_adapt_modifiable, v_min, v_max, speed, format, variant, size, flags, steps);
                return std::make_tuple(r, p_value);
            };

            return Knob_adapt_modifiable_immutable_to_return(label, p_value, v_min, v_max, speed, format, variant, size, flags, steps);
        },     py::arg("label"), py::arg("p_value"), py::arg("v_min"), py::arg("v_max"), py::arg("speed") = 0, py::arg("format") = py::none(), py::arg("variant") = ImGuiKnobVariant_Tick, py::arg("size") = 0, py::arg("flags") = 0, py::arg("steps") = 10);

    m.def("knob_int",
        [](const char * label, int p_value, int v_min, int v_max, float speed = 0, const char * format = NULL, ImGuiKnobVariant variant = ImGuiKnobVariant_Tick, float size = 0, ImGuiKnobFlags flags = 0, int steps = 10) -> std::tuple<bool, int>
        {
            auto KnobInt_adapt_modifiable_immutable_to_return = [](const char * label, int p_value, int v_min, int v_max, float speed = 0, const char * format = NULL, ImGuiKnobVariant variant = ImGuiKnobVariant_Tick, float size = 0, ImGuiKnobFlags flags = 0, int steps = 10) -> std::tuple<bool, int>
            {
                int * p_value_adapt_modifiable = & p_value;

                bool r = ImGuiKnobs::KnobInt(label, p_value_adapt_modifiable, v_min, v_max, speed, format, variant, size, flags, steps);
                return std::make_tuple(r, p_value);
            };

            return KnobInt_adapt_modifiable_immutable_to_return(label, p_value, v_min, v_max, speed, format, variant, size, flags, steps);
        },     py::arg("label"), py::arg("p_value"), py::arg("v_min"), py::arg("v_max"), py::arg("speed") = 0, py::arg("format") = py::none(), py::arg("variant") = ImGuiKnobVariant_Tick, py::arg("size") = 0, py::arg("flags") = 0, py::arg("steps") = 10);
    ////////////////////    </generated_from:imgui-knobs.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
