#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/numpy.h>

#include "imgui.h"
#include "imgui_internal.h"
#include "misc/cpp/imgui_stdlib.h"
#include "imgui_docking_internal_types.h"
#include "litgen_glue_code.h"

namespace py = pybind11;



// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


void py_init_module_imgui_internal(py::module& m)
{
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:imgui_internal.h>    ////////////////////
    m.def("im_hash_data",    // imgui_internal.h:315
        ImHashData, py::arg("data"), py::arg("data_size"), py::arg("seed") = 0);

    m.def("im_hash_str",    // imgui_internal.h:316
        ImHashStr, py::arg("data"), py::arg("data_size") = 0, py::arg("seed") = 0);

    m.def("im_alpha_blend_colors",    // imgui_internal.h:324
        ImAlphaBlendColors,
        py::arg("col_a"), py::arg("col_b"),
        "Helpers: Color Blending");

    m.def("im_file_load_to_memory",    // imgui_internal.h:411
        ImFileLoadToMemory,
        py::arg("filename"), py::arg("mode"), py::arg("out_file_size") = py::none(), py::arg("padding_bytes") = 0,
        pybind11::return_value_policy::reference);

    m.def("im_bezier_cubic_calc",    // imgui_internal.h:476
        ImBezierCubicCalc, py::arg("p1"), py::arg("p2"), py::arg("p3"), py::arg("p4"), py::arg("t"));

    m.def("im_bezier_cubic_closest_point",    // imgui_internal.h:477
        ImBezierCubicClosestPoint,
        py::arg("p1"), py::arg("p2"), py::arg("p3"), py::arg("p4"), py::arg("p"), py::arg("num_segments"),
        "For curves with explicit number of segments");

    m.def("im_bezier_cubic_closest_point_casteljau",    // imgui_internal.h:478
        ImBezierCubicClosestPointCasteljau,
        py::arg("p1"), py::arg("p2"), py::arg("p3"), py::arg("p4"), py::arg("p"), py::arg("tess_tol"),
        "For auto-tessellated curves you can use tess_tol = style.CurveTessellationTol");

    m.def("im_bezier_quadratic_calc",    // imgui_internal.h:479
        ImBezierQuadraticCalc, py::arg("p1"), py::arg("p2"), py::arg("p3"), py::arg("t"));

    m.def("im_line_closest_point",    // imgui_internal.h:480
        ImLineClosestPoint, py::arg("a"), py::arg("b"), py::arg("p"));

    m.def("im_triangle_contains_point",    // imgui_internal.h:481
        ImTriangleContainsPoint, py::arg("a"), py::arg("b"), py::arg("c"), py::arg("p"));

    m.def("im_triangle_closest_point",    // imgui_internal.h:482
        ImTriangleClosestPoint, py::arg("a"), py::arg("b"), py::arg("c"), py::arg("p"));

    m.def("im_triangle_barycentric_coords",    // imgui_internal.h:483
        [](const ImVec2 & a, const ImVec2 & b, const ImVec2 & c, const ImVec2 & p, float out_u, float out_v, float out_w) -> std::tuple<float, float, float>
        {
            auto ImTriangleBarycentricCoords_adapt_modifiable_immutable_to_return = [](const ImVec2 & a, const ImVec2 & b, const ImVec2 & c, const ImVec2 & p, float out_u, float out_v, float out_w) -> std::tuple<float, float, float>
            {
                float & out_u_adapt_modifiable = out_u;
                float & out_v_adapt_modifiable = out_v;
                float & out_w_adapt_modifiable = out_w;

                ImTriangleBarycentricCoords(a, b, c, p, out_u_adapt_modifiable, out_v_adapt_modifiable, out_w_adapt_modifiable);
                return std::make_tuple(out_u, out_v, out_w);
            };

            return ImTriangleBarycentricCoords_adapt_modifiable_immutable_to_return(a, b, c, p, out_u, out_v, out_w);
        },     py::arg("a"), py::arg("b"), py::arg("c"), py::arg("p"), py::arg("out_u"), py::arg("out_v"), py::arg("out_w"));

    m.def("im_get_dir_quadrant_from_delta",    // imgui_internal.h:485
        ImGetDirQuadrantFromDelta, py::arg("dx"), py::arg("dy"));


    auto pyClassImVec1 =
        py::class_<ImVec1>    // imgui_internal.h:490
            (m, "ImVec1", "")
        .def_readwrite("x", &ImVec1::x, "")    // imgui_internal.h:492
        .def(py::init<>())    // imgui_internal.h:493
        .def(py::init<float>(),    // imgui_internal.h:494
            py::arg("_x"))
        ;


    auto pyClassImVec2ih =
        py::class_<ImVec2ih>    // imgui_internal.h:498
            (m, "ImVec2ih", "Helper: ImVec2ih (2D vector, half-size integer, for long-term packed storage)")
        .def_readwrite("x", &ImVec2ih::x, "")    // imgui_internal.h:500
        .def_readwrite("y", &ImVec2ih::y, "")    // imgui_internal.h:500
        .def(py::init<>())    // imgui_internal.h:501
        .def(py::init<short, short>(),    // imgui_internal.h:502
            py::arg("_x"), py::arg("_y"))
        .def(py::init<const ImVec2 &>(),    // imgui_internal.h:503
            py::arg("rhs"))
        ;


    auto pyClassImRect =
        py::class_<ImRect>    // imgui_internal.h:508
            (m, "ImRect", " Helper: ImRect (2D axis aligned bounding-box)\n NB: we can't rely on ImVec2 math operators being available here!")
        .def_readwrite("min", &ImRect::Min, "Upper-left")    // imgui_internal.h:510
        .def_readwrite("max", &ImRect::Max, "Lower-right")    // imgui_internal.h:511
        .def(py::init<>())    // imgui_internal.h:513
        .def(py::init<const ImVec2 &, const ImVec2 &>(),    // imgui_internal.h:514
            py::arg("min"), py::arg("max"))
        .def(py::init<const ImVec4 &>(),    // imgui_internal.h:515
            py::arg("v"))
        .def(py::init<float, float, float, float>(),    // imgui_internal.h:516
            py::arg("x1"), py::arg("y1"), py::arg("x2"), py::arg("y2"))
        ;


    auto pyClassImBitVector =
        py::class_<ImBitVector>    // imgui_internal.h:580
            (m, "ImBitVector", " Helper: ImBitVector\n Store 1-bit per value.")
        .def(py::init<>()) // implicit default constructor
        ;


    auto pyClassImDrawListSharedData =
        py::class_<ImDrawListSharedData>    // imgui_internal.h:732
            (m, "ImDrawListSharedData", " Data shared between all ImDrawList instances\n You may want to create your own instance of this if you want to use ImDrawList completely without ImGui. In that case, watch out for future changes to this structure.")
        .def(py::init<>([](
        ImVec2 TexUvWhitePixel = ImVec2(), float FontSize = float(), float CurveTessellationTol = float(), float CircleSegmentMaxError = float(), ImVec4 ClipRectFullscreen = ImVec4(), ImDrawListFlags InitialFlags = ImDrawListFlags(), float ArcFastRadiusCutoff = float())
        {
            auto r = std::make_unique<ImDrawListSharedData>();
            r->TexUvWhitePixel = TexUvWhitePixel;
            r->FontSize = FontSize;
            r->CurveTessellationTol = CurveTessellationTol;
            r->CircleSegmentMaxError = CircleSegmentMaxError;
            r->ClipRectFullscreen = ClipRectFullscreen;
            r->InitialFlags = InitialFlags;
            r->ArcFastRadiusCutoff = ArcFastRadiusCutoff;
            return r;
        })
        , py::arg("tex_uv_white_pixel") = ImVec2(), py::arg("font_size") = float(), py::arg("curve_tessellation_tol") = float(), py::arg("circle_segment_max_error") = float(), py::arg("clip_rect_fullscreen") = ImVec4(), py::arg("initial_flags") = ImDrawListFlags(), py::arg("arc_fast_radius_cutoff") = float()
        )
        .def_readwrite("tex_uv_white_pixel", &ImDrawListSharedData::TexUvWhitePixel, "UV of white pixel in the atlas")    // imgui_internal.h:734
        .def_readwrite("font", &ImDrawListSharedData::Font, "Current/default font (optional, for simplified AddText overload)")    // imgui_internal.h:735
        .def_readwrite("font_size", &ImDrawListSharedData::FontSize, "Current/default font size (optional, for simplified AddText overload)")    // imgui_internal.h:736
        .def_readwrite("curve_tessellation_tol", &ImDrawListSharedData::CurveTessellationTol, "Tessellation tolerance when using PathBezierCurveTo()")    // imgui_internal.h:737
        .def_readwrite("circle_segment_max_error", &ImDrawListSharedData::CircleSegmentMaxError, "Number of circle segments to use per pixel of radius for AddCircle() etc")    // imgui_internal.h:738
        .def_readwrite("clip_rect_fullscreen", &ImDrawListSharedData::ClipRectFullscreen, "Value for PushClipRectFullscreen()")    // imgui_internal.h:739
        .def_readwrite("initial_flags", &ImDrawListSharedData::InitialFlags, "Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)")    // imgui_internal.h:740
        .def_readwrite("arc_fast_radius_cutoff", &ImDrawListSharedData::ArcFastRadiusCutoff, "Cutoff radius after which arc drawing will fallback to slower PathArcTo()")    // imgui_internal.h:744
        .def_property("circle_segment_counts",    // imgui_internal.h:745
            [](ImDrawListSharedData &self) -> pybind11::array
            {
                auto dtype = pybind11::dtype(pybind11::format_descriptor<ImU8>::format());
                auto base = pybind11::array(dtype, {64}, {sizeof(ImU8)});
                return pybind11::array(dtype, {64}, {sizeof(ImU8)}, self.CircleSegmentCounts, base);
            }, [](ImDrawListSharedData& self) {},
            "Precomputed segment count for given radius before we calculate it dynamically (to avoid calculation overhead)")
        .def_readonly("tex_uv_lines", &ImDrawListSharedData::TexUvLines, "UV of anti-aliased lines in the atlas")    // imgui_internal.h:746
        .def(py::init<>())    // imgui_internal.h:748
        ;


    auto pyClassImDrawDataBuilder =
        py::class_<ImDrawDataBuilder>    // imgui_internal.h:752
            (m, "ImDrawDataBuilder", "")
        .def(py::init<>()) // implicit default constructor
        .def("flatten_into_single_layer",    // imgui_internal.h:759
            &ImDrawDataBuilder::FlattenIntoSingleLayer)
        ;


    py::enum_<ImGuiItemFlags_>(m, "ImGuiItemFlags_", py::arithmetic(), " Transient per-window flags, reset at the beginning of the frame. For child window, inherited from parent on first Begin().\n This is going to be exposed in imgui.h when stabilized enough.")    // imgui_internal.h:768
        .value("none", ImGuiItemFlags_None, "")
        .value("no_tab_stop", ImGuiItemFlags_NoTabStop, "False     // Disable keyboard tabbing (FIXME: should merge with _NoNav)")
        .value("button_repeat", ImGuiItemFlags_ButtonRepeat, "False     // Button() will return True multiple times based on io.KeyRepeatDelay and io.KeyRepeatRate settings.")
        .value("disabled", ImGuiItemFlags_Disabled, "False     // Disable interactions but doesn't affect visuals. See BeginDisabled()/EndDisabled(). See github.com/ocornut/imgui/issues/211")
        .value("no_nav", ImGuiItemFlags_NoNav, "False     // Disable keyboard/gamepad directional navigation (FIXME: should merge with _NoTabStop)")
        .value("no_nav_default_focus", ImGuiItemFlags_NoNavDefaultFocus, "False     // Disable item being a candidate for default focus (e.g. used by title bar items)")
        .value("selectable_dont_close_popup", ImGuiItemFlags_SelectableDontClosePopup, "False     // Disable MenuItem/Selectable() automatically closing their popup window")
        .value("mixed_value", ImGuiItemFlags_MixedValue, "False     // [BETA] Represent a mixed/indeterminate value, generally multi-selection where values differ. Currently only supported by Checkbox() (later should support all sorts of widgets)")
        .value("read_only", ImGuiItemFlags_ReadOnly, "False     // [ALPHA] Allow hovering interactions but underlying value is not changed.")
        .value("inputable", ImGuiItemFlags_Inputable, "False     // [WIP] Auto-activate input mode when tab focused. Currently only used and supported by a few items before it becomes a generic feature.");


    py::enum_<ImGuiItemStatusFlags_>(m, "ImGuiItemStatusFlags_", py::arithmetic(), "Storage for LastItem data")    // imgui_internal.h:783
        .value("none", ImGuiItemStatusFlags_None, "")
        .value("hovered_rect", ImGuiItemStatusFlags_HoveredRect, "Mouse position is within item rectangle (does NOT mean that the window is in correct z-order and can be hovered!, this is only one part of the most-common IsItemHovered test)")
        .value("has_display_rect", ImGuiItemStatusFlags_HasDisplayRect, "g.LastItemData.DisplayRect is valid")
        .value("edited", ImGuiItemStatusFlags_Edited, "Value exposed by item was edited in the current frame (should match the bool return value of most widgets)")
        .value("toggled_selection", ImGuiItemStatusFlags_ToggledSelection, "Set when Selectable(), TreeNode() reports toggling a selection. We can't report \"Selected\", only state changes, in order to easily handle clipping with less issues.")
        .value("toggled_open", ImGuiItemStatusFlags_ToggledOpen, "Set when TreeNode() reports toggling their open state.")
        .value("has_deactivated", ImGuiItemStatusFlags_HasDeactivated, "Set if the widget/group is able to provide data for the ImGuiItemStatusFlags_Deactivated flag.")
        .value("deactivated", ImGuiItemStatusFlags_Deactivated, "Only valid if ImGuiItemStatusFlags_HasDeactivated is set.")
        .value("hovered_window", ImGuiItemStatusFlags_HoveredWindow, "Override the HoveredWindow test to allow cross-window hover testing.")
        .value("focused_by_tabbing", ImGuiItemStatusFlags_FocusedByTabbing, "");


    py::enum_<ImGuiInputTextFlagsPrivate_>(m, "ImGuiInputTextFlagsPrivate_", py::arithmetic(), "Extend ImGuiInputTextFlags_")    // imgui_internal.h:806
        .value("im_gui_input_text_flags_multiline", ImGuiInputTextFlags_Multiline, "For internal use by InputTextMultiline()")
        .value("im_gui_input_text_flags_no_mark_edited", ImGuiInputTextFlags_NoMarkEdited, "For internal use by functions using InputText() before reformatting data")
        .value("im_gui_input_text_flags_merged_item", ImGuiInputTextFlags_MergedItem, "For internal use by TempInputText(), will skip calling ItemAdd(). Require bounding-box to strictly match.");


    py::enum_<ImGuiButtonFlagsPrivate_>(m, "ImGuiButtonFlagsPrivate_", py::arithmetic(), "Extend ImGuiButtonFlags_")    // imgui_internal.h:815
        .value("im_gui_button_flags_pressed_on_click", ImGuiButtonFlags_PressedOnClick, "return True on click (mouse down event)")
        .value("im_gui_button_flags_pressed_on_click_release", ImGuiButtonFlags_PressedOnClickRelease, "[Default] return True on click + release on same item <-- this is what the majority of Button are using")
        .value("im_gui_button_flags_pressed_on_click_release_anywhere", ImGuiButtonFlags_PressedOnClickReleaseAnywhere, "return True on click + release even if the release event is not done while hovering the item")
        .value("im_gui_button_flags_pressed_on_release", ImGuiButtonFlags_PressedOnRelease, "return True on release (default requires click+release)")
        .value("im_gui_button_flags_pressed_on_double_click", ImGuiButtonFlags_PressedOnDoubleClick, "return True on double-click (default requires click+release)")
        .value("im_gui_button_flags_pressed_on_drag_drop_hold", ImGuiButtonFlags_PressedOnDragDropHold, "return True when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)")
        .value("im_gui_button_flags_repeat", ImGuiButtonFlags_Repeat, "hold to repeat")
        .value("im_gui_button_flags_flatten_children", ImGuiButtonFlags_FlattenChildren, "allow interactions even if a child window is overlapping")
        .value("im_gui_button_flags_allow_item_overlap", ImGuiButtonFlags_AllowItemOverlap, "require previous frame HoveredId to either match id or be null before being usable, use along with SetItemAllowOverlap()")
        .value("im_gui_button_flags_dont_close_popups", ImGuiButtonFlags_DontClosePopups, "disable automatically closing parent popup on press // [UNUSED]")
        .value("im_gui_button_flags_align_text_base_line", ImGuiButtonFlags_AlignTextBaseLine, "vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine")
        .value("im_gui_button_flags_no_key_modifiers", ImGuiButtonFlags_NoKeyModifiers, "disable mouse interaction if a key modifier is held")
        .value("im_gui_button_flags_no_holding_active_id", ImGuiButtonFlags_NoHoldingActiveId, "don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)")
        .value("im_gui_button_flags_no_nav_focus", ImGuiButtonFlags_NoNavFocus, "don't override navigation focus when activated")
        .value("im_gui_button_flags_no_hovered_on_focus", ImGuiButtonFlags_NoHoveredOnFocus, "don't report as hovered when nav focus is on this item")
        .value("im_gui_button_flags_pressed_on_mask_", ImGuiButtonFlags_PressedOnMask_, "")
        .value("im_gui_button_flags_pressed_on_default_", ImGuiButtonFlags_PressedOnDefault_, "");


    py::enum_<ImGuiComboFlagsPrivate_>(m, "ImGuiComboFlagsPrivate_", py::arithmetic(), "Extend ImGuiComboFlags_")    // imgui_internal.h:838
        .value("im_gui_combo_flags_custom_preview", ImGuiComboFlags_CustomPreview, "enable BeginComboPreview()");


    py::enum_<ImGuiSliderFlagsPrivate_>(m, "ImGuiSliderFlagsPrivate_", py::arithmetic(), "Extend ImGuiSliderFlags_")    // imgui_internal.h:844
        .value("im_gui_slider_flags_vertical", ImGuiSliderFlags_Vertical, "Should this slider be orientated vertically?")
        .value("im_gui_slider_flags_read_only", ImGuiSliderFlags_ReadOnly, "");


    py::enum_<ImGuiSelectableFlagsPrivate_>(m, "ImGuiSelectableFlagsPrivate_", py::arithmetic(), "Extend ImGuiSelectableFlags_")    // imgui_internal.h:851
        .value("im_gui_selectable_flags_no_holding_active_id", ImGuiSelectableFlags_NoHoldingActiveID, "")
        .value("im_gui_selectable_flags_select_on_nav", ImGuiSelectableFlags_SelectOnNav, "(WIP) Auto-select when moved into. This is not exposed in public API as to handle multi-select and modifiers we will need user to explicitly control focus scope. May be replaced with a BeginSelection() API.")
        .value("im_gui_selectable_flags_select_on_click", ImGuiSelectableFlags_SelectOnClick, "Override button behavior to react on Click (default is Click+Release)")
        .value("im_gui_selectable_flags_select_on_release", ImGuiSelectableFlags_SelectOnRelease, "Override button behavior to react on Release (default is Click+Release)")
        .value("im_gui_selectable_flags_span_avail_width", ImGuiSelectableFlags_SpanAvailWidth, "Span all avail width even if we declared less for layout purpose. FIXME: We may be able to remove this (added in 6251379, 2bcafc86 for menus)")
        .value("im_gui_selectable_flags_draw_hovered_when_held", ImGuiSelectableFlags_DrawHoveredWhenHeld, "Always show active when held, even is not hovered. This concept could probably be renamed/formalized somehow.")
        .value("im_gui_selectable_flags_set_nav_id_on_hover", ImGuiSelectableFlags_SetNavIdOnHover, "Set Nav/Focus ID on mouse hover (used by MenuItem)")
        .value("im_gui_selectable_flags_no_pad_with_half_spacing", ImGuiSelectableFlags_NoPadWithHalfSpacing, "Disable padding each side with ItemSpacing * 0.5");


    py::enum_<ImGuiTreeNodeFlagsPrivate_>(m, "ImGuiTreeNodeFlagsPrivate_", py::arithmetic(), "Extend ImGuiTreeNodeFlags_")    // imgui_internal.h:865
        .value("im_gui_tree_node_flags_clip_label_for_trailing_button", ImGuiTreeNodeFlags_ClipLabelForTrailingButton, "");


    py::enum_<ImGuiSeparatorFlags_>(m, "ImGuiSeparatorFlags_", py::arithmetic(), "")    // imgui_internal.h:870
        .value("none", ImGuiSeparatorFlags_None, "")
        .value("horizontal", ImGuiSeparatorFlags_Horizontal, "Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar")
        .value("vertical", ImGuiSeparatorFlags_Vertical, "")
        .value("span_all_columns", ImGuiSeparatorFlags_SpanAllColumns, "");


    py::enum_<ImGuiTextFlags_>(m, "ImGuiTextFlags_", py::arithmetic(), "")    // imgui_internal.h:878
        .value("none", ImGuiTextFlags_None, "")
        .value("no_width_for_large_clipped_text", ImGuiTextFlags_NoWidthForLargeClippedText, "");


    py::enum_<ImGuiTooltipFlags_>(m, "ImGuiTooltipFlags_", py::arithmetic(), "")    // imgui_internal.h:884
        .value("none", ImGuiTooltipFlags_None, "")
        .value("override_previous_tooltip", ImGuiTooltipFlags_OverridePreviousTooltip, "Override will clear/ignore previously submitted tooltip (defaults to append)");


    py::enum_<ImGuiLayoutType_>(m, "ImGuiLayoutType_", py::arithmetic(), " FIXME: this is in development, not exposed/functional as a generic feature yet.\n Horizontal/Vertical enums are fixed to 0/1 so they may be used to index ImVec2")    // imgui_internal.h:892
        .value("horizontal", ImGuiLayoutType_Horizontal, "")
        .value("vertical", ImGuiLayoutType_Vertical, "");


    py::enum_<ImGuiLogType>(m, "ImGuiLogType", py::arithmetic(), "")    // imgui_internal.h:898
        .value("none", ImGuiLogType_None, "")
        .value("tty", ImGuiLogType_TTY, "")
        .value("file", ImGuiLogType_File, "")
        .value("buffer", ImGuiLogType_Buffer, "")
        .value("clipboard", ImGuiLogType_Clipboard, "");


    py::enum_<ImGuiAxis>(m, "ImGuiAxis", py::arithmetic(), "X/Y enums are fixed to 0/1 so they may be used to index ImVec2")    // imgui_internal.h:908
        .value("none", ImGuiAxis_None, "")
        .value("x", ImGuiAxis_X, "")
        .value("y", ImGuiAxis_Y, "");


    py::enum_<ImGuiPlotType>(m, "ImGuiPlotType", py::arithmetic(), "")    // imgui_internal.h:915
        .value("lines", ImGuiPlotType_Lines, "")
        .value("histogram", ImGuiPlotType_Histogram, "");


    py::enum_<ImGuiPopupPositionPolicy>(m, "ImGuiPopupPositionPolicy", py::arithmetic(), "")    // imgui_internal.h:921
        .value("default", ImGuiPopupPositionPolicy_Default, "")
        .value("combo_box", ImGuiPopupPositionPolicy_ComboBox, "")
        .value("tooltip", ImGuiPopupPositionPolicy_Tooltip, "");


    auto pyClassImGuiDataTypeTempStorage =
        py::class_<ImGuiDataTypeTempStorage>    // imgui_internal.h:928
            (m, "ImGuiDataTypeTempStorage", "")
        .def(py::init<>()) // implicit default constructor
        .def_property("data",    // imgui_internal.h:930
            [](ImGuiDataTypeTempStorage &self) -> pybind11::array
            {
                auto dtype = pybind11::dtype(pybind11::format_descriptor<ImU8>::format());
                auto base = pybind11::array(dtype, {8}, {sizeof(ImU8)});
                return pybind11::array(dtype, {8}, {sizeof(ImU8)}, self.Data, base);
            }, [](ImGuiDataTypeTempStorage& self) {},
            "Can fit any data up to ImGuiDataType_COUNT")
        ;


    auto pyClassImGuiDataTypeInfo =
        py::class_<ImGuiDataTypeInfo>    // imgui_internal.h:934
            (m, "ImGuiDataTypeInfo", "Type information associated to one ImGuiDataType. Retrieve with DataTypeGetInfo().")
        .def(py::init<>([](
        size_t Size = size_t())
        {
            auto r = std::make_unique<ImGuiDataTypeInfo>();
            r->Size = Size;
            return r;
        })
        , py::arg("size") = size_t()
        )
        .def_readwrite("size", &ImGuiDataTypeInfo::Size, "Size in bytes")    // imgui_internal.h:936
        .def_readonly("name", &ImGuiDataTypeInfo::Name, "Short descriptive name for the type, for debugging")    // imgui_internal.h:937
        .def_readonly("print_fmt", &ImGuiDataTypeInfo::PrintFmt, "Default printf format for the type")    // imgui_internal.h:938
        .def_readonly("scan_fmt", &ImGuiDataTypeInfo::ScanFmt, "Default scanf format for the type")    // imgui_internal.h:939
        ;


    py::enum_<ImGuiDataTypePrivate_>(m, "ImGuiDataTypePrivate_", py::arithmetic(), "Extend ImGuiDataType_")    // imgui_internal.h:943
        .value("im_gui_data_type_string", ImGuiDataType_String, "")
        .value("im_gui_data_type_pointer", ImGuiDataType_Pointer, "")
        .value("im_gui_data_type_id", ImGuiDataType_ID, "");


    auto pyClassImGuiColorMod =
        py::class_<ImGuiColorMod>    // imgui_internal.h:951
            (m, "ImGuiColorMod", "Stacked color modifier, backup of modified data so we can restore it")
        .def(py::init<>([](
        ImGuiCol Col = ImGuiCol(), ImVec4 BackupValue = ImVec4())
        {
            auto r = std::make_unique<ImGuiColorMod>();
            r->Col = Col;
            r->BackupValue = BackupValue;
            return r;
        })
        , py::arg("col") = ImGuiCol(), py::arg("backup_value") = ImVec4()
        )
        .def_readwrite("col", &ImGuiColorMod::Col, "")    // imgui_internal.h:953
        .def_readwrite("backup_value", &ImGuiColorMod::BackupValue, "")    // imgui_internal.h:954
        ;


    auto pyClassImGuiStyleMod =
        py::class_<ImGuiStyleMod>    // imgui_internal.h:958
            (m, "ImGuiStyleMod", "Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.")
        .def_readwrite("var_idx", &ImGuiStyleMod::VarIdx, "")    // imgui_internal.h:960
        .def(py::init<ImGuiStyleVar, int>(),    // imgui_internal.h:962
            py::arg("idx"), py::arg("v"))
        .def(py::init<ImGuiStyleVar, float>(),    // imgui_internal.h:963
            py::arg("idx"), py::arg("v"))
        .def(py::init<ImGuiStyleVar, ImVec2>(),    // imgui_internal.h:964
            py::arg("idx"), py::arg("v"))
        ;


    auto pyClassImGuiComboPreviewData =
        py::class_<ImGuiComboPreviewData>    // imgui_internal.h:968
            (m, "ImGuiComboPreviewData", "Storage data for BeginComboPreview()/EndComboPreview()")
        .def(py::init<>([](
        ImRect PreviewRect = ImRect(), ImVec2 BackupCursorPos = ImVec2(), ImVec2 BackupCursorMaxPos = ImVec2(), ImVec2 BackupCursorPosPrevLine = ImVec2(), float BackupPrevLineTextBaseOffset = float(), ImGuiLayoutType BackupLayout = ImGuiLayoutType())
        {
            auto r = std::make_unique<ImGuiComboPreviewData>();
            r->PreviewRect = PreviewRect;
            r->BackupCursorPos = BackupCursorPos;
            r->BackupCursorMaxPos = BackupCursorMaxPos;
            r->BackupCursorPosPrevLine = BackupCursorPosPrevLine;
            r->BackupPrevLineTextBaseOffset = BackupPrevLineTextBaseOffset;
            r->BackupLayout = BackupLayout;
            return r;
        })
        , py::arg("preview_rect") = ImRect(), py::arg("backup_cursor_pos") = ImVec2(), py::arg("backup_cursor_max_pos") = ImVec2(), py::arg("backup_cursor_pos_prev_line") = ImVec2(), py::arg("backup_prev_line_text_base_offset") = float(), py::arg("backup_layout") = ImGuiLayoutType()
        )
        .def_readwrite("preview_rect", &ImGuiComboPreviewData::PreviewRect, "")    // imgui_internal.h:970
        .def_readwrite("backup_cursor_pos", &ImGuiComboPreviewData::BackupCursorPos, "")    // imgui_internal.h:971
        .def_readwrite("backup_cursor_max_pos", &ImGuiComboPreviewData::BackupCursorMaxPos, "")    // imgui_internal.h:972
        .def_readwrite("backup_cursor_pos_prev_line", &ImGuiComboPreviewData::BackupCursorPosPrevLine, "")    // imgui_internal.h:973
        .def_readwrite("backup_prev_line_text_base_offset", &ImGuiComboPreviewData::BackupPrevLineTextBaseOffset, "")    // imgui_internal.h:974
        .def_readwrite("backup_layout", &ImGuiComboPreviewData::BackupLayout, "")    // imgui_internal.h:975
        .def(py::init<>())    // imgui_internal.h:977
        ;


    auto pyClassImGuiGroupData =
        py::class_<ImGuiGroupData>    // imgui_internal.h:981
            (m, "ImGuiGroupData", "Stacked storage data for BeginGroup()/EndGroup()")
        .def(py::init<>([](
        ImGuiID WindowID = ImGuiID(), ImVec2 BackupCursorPos = ImVec2(), ImVec2 BackupCursorMaxPos = ImVec2(), ImVec1 BackupIndent = ImVec1(), ImVec1 BackupGroupOffset = ImVec1(), ImVec2 BackupCurrLineSize = ImVec2(), float BackupCurrLineTextBaseOffset = float(), ImGuiID BackupActiveIdIsAlive = ImGuiID(), bool BackupActiveIdPreviousFrameIsAlive = bool(), bool BackupHoveredIdIsAlive = bool(), bool EmitItem = bool())
        {
            auto r = std::make_unique<ImGuiGroupData>();
            r->WindowID = WindowID;
            r->BackupCursorPos = BackupCursorPos;
            r->BackupCursorMaxPos = BackupCursorMaxPos;
            r->BackupIndent = BackupIndent;
            r->BackupGroupOffset = BackupGroupOffset;
            r->BackupCurrLineSize = BackupCurrLineSize;
            r->BackupCurrLineTextBaseOffset = BackupCurrLineTextBaseOffset;
            r->BackupActiveIdIsAlive = BackupActiveIdIsAlive;
            r->BackupActiveIdPreviousFrameIsAlive = BackupActiveIdPreviousFrameIsAlive;
            r->BackupHoveredIdIsAlive = BackupHoveredIdIsAlive;
            r->EmitItem = EmitItem;
            return r;
        })
        , py::arg("window_id") = ImGuiID(), py::arg("backup_cursor_pos") = ImVec2(), py::arg("backup_cursor_max_pos") = ImVec2(), py::arg("backup_indent") = ImVec1(), py::arg("backup_group_offset") = ImVec1(), py::arg("backup_curr_line_size") = ImVec2(), py::arg("backup_curr_line_text_base_offset") = float(), py::arg("backup_active_id_is_alive") = ImGuiID(), py::arg("backup_active_id_previous_frame_is_alive") = bool(), py::arg("backup_hovered_id_is_alive") = bool(), py::arg("emit_item") = bool()
        )
        .def_readwrite("window_id", &ImGuiGroupData::WindowID, "")    // imgui_internal.h:983
        .def_readwrite("backup_cursor_pos", &ImGuiGroupData::BackupCursorPos, "")    // imgui_internal.h:984
        .def_readwrite("backup_cursor_max_pos", &ImGuiGroupData::BackupCursorMaxPos, "")    // imgui_internal.h:985
        .def_readwrite("backup_indent", &ImGuiGroupData::BackupIndent, "")    // imgui_internal.h:986
        .def_readwrite("backup_group_offset", &ImGuiGroupData::BackupGroupOffset, "")    // imgui_internal.h:987
        .def_readwrite("backup_curr_line_size", &ImGuiGroupData::BackupCurrLineSize, "")    // imgui_internal.h:988
        .def_readwrite("backup_curr_line_text_base_offset", &ImGuiGroupData::BackupCurrLineTextBaseOffset, "")    // imgui_internal.h:989
        .def_readwrite("backup_active_id_is_alive", &ImGuiGroupData::BackupActiveIdIsAlive, "")    // imgui_internal.h:990
        .def_readwrite("backup_active_id_previous_frame_is_alive", &ImGuiGroupData::BackupActiveIdPreviousFrameIsAlive, "")    // imgui_internal.h:991
        .def_readwrite("backup_hovered_id_is_alive", &ImGuiGroupData::BackupHoveredIdIsAlive, "")    // imgui_internal.h:992
        .def_readwrite("emit_item", &ImGuiGroupData::EmitItem, "")    // imgui_internal.h:993
        ;


    auto pyClassImGuiMenuColumns =
        py::class_<ImGuiMenuColumns>    // imgui_internal.h:997
            (m, "ImGuiMenuColumns", "Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.")
        .def(py::init<>([](
        ImU32 TotalWidth = ImU32(), ImU32 NextTotalWidth = ImU32(), ImU16 Spacing = ImU16(), ImU16 OffsetIcon = ImU16(), ImU16 OffsetLabel = ImU16(), ImU16 OffsetShortcut = ImU16(), ImU16 OffsetMark = ImU16())
        {
            auto r = std::make_unique<ImGuiMenuColumns>();
            r->TotalWidth = TotalWidth;
            r->NextTotalWidth = NextTotalWidth;
            r->Spacing = Spacing;
            r->OffsetIcon = OffsetIcon;
            r->OffsetLabel = OffsetLabel;
            r->OffsetShortcut = OffsetShortcut;
            r->OffsetMark = OffsetMark;
            return r;
        })
        , py::arg("total_width") = ImU32(), py::arg("next_total_width") = ImU32(), py::arg("spacing") = ImU16(), py::arg("offset_icon") = ImU16(), py::arg("offset_label") = ImU16(), py::arg("offset_shortcut") = ImU16(), py::arg("offset_mark") = ImU16()
        )
        .def_readwrite("total_width", &ImGuiMenuColumns::TotalWidth, "")    // imgui_internal.h:999
        .def_readwrite("next_total_width", &ImGuiMenuColumns::NextTotalWidth, "")    // imgui_internal.h:1000
        .def_readwrite("spacing", &ImGuiMenuColumns::Spacing, "")    // imgui_internal.h:1001
        .def_readwrite("offset_icon", &ImGuiMenuColumns::OffsetIcon, "Always zero for now")    // imgui_internal.h:1002
        .def_readwrite("offset_label", &ImGuiMenuColumns::OffsetLabel, "Offsets are locked in Update()")    // imgui_internal.h:1003
        .def_readwrite("offset_shortcut", &ImGuiMenuColumns::OffsetShortcut, "")    // imgui_internal.h:1004
        .def_readwrite("offset_mark", &ImGuiMenuColumns::OffsetMark, "")    // imgui_internal.h:1005
        .def_property("widths",    // imgui_internal.h:1006
            [](ImGuiMenuColumns &self) -> pybind11::array
            {
                auto dtype = pybind11::dtype(pybind11::format_descriptor<ImU16>::format());
                auto base = pybind11::array(dtype, {4}, {sizeof(ImU16)});
                return pybind11::array(dtype, {4}, {sizeof(ImU16)}, self.Widths, base);
            }, [](ImGuiMenuColumns& self) {},
            "Width of:   Icon, Label, Shortcut, Mark  (accumulators for current frame)")
        .def(py::init<>())    // imgui_internal.h:1008
        ;


    auto pyClassImGuiInputTextState =
        py::class_<ImGuiInputTextState>    // imgui_internal.h:1016
            (m, "ImGuiInputTextState", " Internal state of the currently focused/edited text input box\n For a given item ID, access with ImGui::GetInputTextState()")
        .def(py::init<>([](
        ImGuiID ID = ImGuiID(), int CurLenW = int(), int CurLenA = int(), bool TextAIsValid = bool(), int BufCapacityA = int(), float ScrollX = float(), float CursorAnim = float(), bool CursorFollow = bool(), bool SelectedAllMouseLock = bool(), bool Edited = bool(), ImGuiInputTextFlags Flags = ImGuiInputTextFlags())
        {
            auto r = std::make_unique<ImGuiInputTextState>();
            r->ID = ID;
            r->CurLenW = CurLenW;
            r->CurLenA = CurLenA;
            r->TextAIsValid = TextAIsValid;
            r->BufCapacityA = BufCapacityA;
            r->ScrollX = ScrollX;
            r->CursorAnim = CursorAnim;
            r->CursorFollow = CursorFollow;
            r->SelectedAllMouseLock = SelectedAllMouseLock;
            r->Edited = Edited;
            r->Flags = Flags;
            return r;
        })
        , py::arg("id") = ImGuiID(), py::arg("cur_len_w") = int(), py::arg("cur_len_a") = int(), py::arg("text_a_is_valid") = bool(), py::arg("buf_capacity_a") = int(), py::arg("scroll_x") = float(), py::arg("cursor_anim") = float(), py::arg("cursor_follow") = bool(), py::arg("selected_all_mouse_lock") = bool(), py::arg("edited") = bool(), py::arg("flags") = ImGuiInputTextFlags()
        )
        .def_readwrite("id", &ImGuiInputTextState::ID, "widget id owning the text state")    // imgui_internal.h:1018
        .def_readwrite("cur_len_w", &ImGuiInputTextState::CurLenW, "we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 length is valid even if TextA is not.")    // imgui_internal.h:1019
        .def_readwrite("cur_len_a", &ImGuiInputTextState::CurLenA, "we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 length is valid even if TextA is not.")    // imgui_internal.h:1019
        .def_readwrite("text_a_is_valid", &ImGuiInputTextState::TextAIsValid, "temporary UTF8 buffer is not initially valid before we make the widget active (until then we pull the data from user argument)")    // imgui_internal.h:1023
        .def_readwrite("buf_capacity_a", &ImGuiInputTextState::BufCapacityA, "end-user buffer capacity")    // imgui_internal.h:1024
        .def_readwrite("scroll_x", &ImGuiInputTextState::ScrollX, "horizontal scrolling/offset")    // imgui_internal.h:1025
        .def_readwrite("cursor_anim", &ImGuiInputTextState::CursorAnim, "timer for cursor blink, reset on every user action so the cursor reappears immediately")    // imgui_internal.h:1027
        .def_readwrite("cursor_follow", &ImGuiInputTextState::CursorFollow, "set when we want scrolling to follow the current cursor position (not always!)")    // imgui_internal.h:1028
        .def_readwrite("selected_all_mouse_lock", &ImGuiInputTextState::SelectedAllMouseLock, "after a double-click to select all, we ignore further mouse drags to update selection")    // imgui_internal.h:1029
        .def_readwrite("edited", &ImGuiInputTextState::Edited, "edited this frame")    // imgui_internal.h:1030
        .def_readwrite("flags", &ImGuiInputTextState::Flags, "copy of InputText() flags")    // imgui_internal.h:1031
        .def(py::init<>())    // imgui_internal.h:1033
        ;


    auto pyClassImGuiPopupData =
        py::class_<ImGuiPopupData>    // imgui_internal.h:1052
            (m, "ImGuiPopupData", "Storage for current popup stack")
        .def(py::init<>([](
        ImGuiID PopupId = ImGuiID(), int ParentNavLayer = int(), int OpenFrameCount = int(), ImGuiID OpenParentId = ImGuiID(), ImVec2 OpenPopupPos = ImVec2(), ImVec2 OpenMousePos = ImVec2())
        {
            auto r = std::make_unique<ImGuiPopupData>();
            r->PopupId = PopupId;
            r->ParentNavLayer = ParentNavLayer;
            r->OpenFrameCount = OpenFrameCount;
            r->OpenParentId = OpenParentId;
            r->OpenPopupPos = OpenPopupPos;
            r->OpenMousePos = OpenMousePos;
            return r;
        })
        , py::arg("popup_id") = ImGuiID(), py::arg("parent_nav_layer") = int(), py::arg("open_frame_count") = int(), py::arg("open_parent_id") = ImGuiID(), py::arg("open_popup_pos") = ImVec2(), py::arg("open_mouse_pos") = ImVec2()
        )
        .def_readwrite("popup_id", &ImGuiPopupData::PopupId, "Set on OpenPopup()")    // imgui_internal.h:1054
        .def_readwrite("window", &ImGuiPopupData::Window, "Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()")    // imgui_internal.h:1055
        .def_readwrite("source_window", &ImGuiPopupData::SourceWindow, "Set on OpenPopup() copy of NavWindow at the time of opening the popup")    // imgui_internal.h:1056
        .def_readwrite("parent_nav_layer", &ImGuiPopupData::ParentNavLayer, "Resolved on BeginPopup(). Actually a ImGuiNavLayer type (declared down below), initialized to -1 which is not part of an enum, but serves well-enough as \"not any of layers\" value")    // imgui_internal.h:1057
        .def_readwrite("open_frame_count", &ImGuiPopupData::OpenFrameCount, "Set on OpenPopup()")    // imgui_internal.h:1058
        .def_readwrite("open_parent_id", &ImGuiPopupData::OpenParentId, "Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)")    // imgui_internal.h:1059
        .def_readwrite("open_popup_pos", &ImGuiPopupData::OpenPopupPos, "Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)")    // imgui_internal.h:1060
        .def_readwrite("open_mouse_pos", &ImGuiPopupData::OpenMousePos, "Set on OpenPopup(), copy of mouse position at the time of opening popup")    // imgui_internal.h:1061
        .def(py::init<>())    // imgui_internal.h:1063
        ;


    py::enum_<ImGuiNextWindowDataFlags_>(m, "ImGuiNextWindowDataFlags_", py::arithmetic(), "")    // imgui_internal.h:1066
        .value("none", ImGuiNextWindowDataFlags_None, "")
        .value("has_pos", ImGuiNextWindowDataFlags_HasPos, "")
        .value("has_size", ImGuiNextWindowDataFlags_HasSize, "")
        .value("has_content_size", ImGuiNextWindowDataFlags_HasContentSize, "")
        .value("has_collapsed", ImGuiNextWindowDataFlags_HasCollapsed, "")
        .value("has_size_constraint", ImGuiNextWindowDataFlags_HasSizeConstraint, "")
        .value("has_focus", ImGuiNextWindowDataFlags_HasFocus, "")
        .value("has_bg_alpha", ImGuiNextWindowDataFlags_HasBgAlpha, "")
        .value("has_scroll", ImGuiNextWindowDataFlags_HasScroll, "")
        .value("has_viewport", ImGuiNextWindowDataFlags_HasViewport, "")
        .value("has_dock", ImGuiNextWindowDataFlags_HasDock, "")
        .value("has_window_class", ImGuiNextWindowDataFlags_HasWindowClass, "");


    auto pyClassImGuiNextWindowData =
        py::class_<ImGuiNextWindowData>    // imgui_internal.h:1083
            (m, "ImGuiNextWindowData", "Storage for SetNexWindow** functions")
        .def(py::init<>([](
        ImGuiNextWindowDataFlags Flags = ImGuiNextWindowDataFlags(), ImGuiCond PosCond = ImGuiCond(), ImGuiCond SizeCond = ImGuiCond(), ImGuiCond CollapsedCond = ImGuiCond(), ImGuiCond DockCond = ImGuiCond(), ImVec2 PosVal = ImVec2(), ImVec2 PosPivotVal = ImVec2(), ImVec2 SizeVal = ImVec2(), ImVec2 ContentSizeVal = ImVec2(), ImVec2 ScrollVal = ImVec2(), bool PosUndock = bool(), bool CollapsedVal = bool(), ImRect SizeConstraintRect = ImRect(), float BgAlphaVal = float(), ImGuiID ViewportId = ImGuiID(), ImGuiID DockId = ImGuiID(), ImGuiWindowClass WindowClass = ImGuiWindowClass(), ImVec2 MenuBarOffsetMinVal = ImVec2())
        {
            auto r = std::make_unique<ImGuiNextWindowData>();
            r->Flags = Flags;
            r->PosCond = PosCond;
            r->SizeCond = SizeCond;
            r->CollapsedCond = CollapsedCond;
            r->DockCond = DockCond;
            r->PosVal = PosVal;
            r->PosPivotVal = PosPivotVal;
            r->SizeVal = SizeVal;
            r->ContentSizeVal = ContentSizeVal;
            r->ScrollVal = ScrollVal;
            r->PosUndock = PosUndock;
            r->CollapsedVal = CollapsedVal;
            r->SizeConstraintRect = SizeConstraintRect;
            r->BgAlphaVal = BgAlphaVal;
            r->ViewportId = ViewportId;
            r->DockId = DockId;
            r->WindowClass = WindowClass;
            r->MenuBarOffsetMinVal = MenuBarOffsetMinVal;
            return r;
        })
        , py::arg("flags") = ImGuiNextWindowDataFlags(), py::arg("pos_cond") = ImGuiCond(), py::arg("size_cond") = ImGuiCond(), py::arg("collapsed_cond") = ImGuiCond(), py::arg("dock_cond") = ImGuiCond(), py::arg("pos_val") = ImVec2(), py::arg("pos_pivot_val") = ImVec2(), py::arg("size_val") = ImVec2(), py::arg("content_size_val") = ImVec2(), py::arg("scroll_val") = ImVec2(), py::arg("pos_undock") = bool(), py::arg("collapsed_val") = bool(), py::arg("size_constraint_rect") = ImRect(), py::arg("bg_alpha_val") = float(), py::arg("viewport_id") = ImGuiID(), py::arg("dock_id") = ImGuiID(), py::arg("window_class") = ImGuiWindowClass(), py::arg("menu_bar_offset_min_val") = ImVec2()
        )
        .def_readwrite("flags", &ImGuiNextWindowData::Flags, "")    // imgui_internal.h:1085
        .def_readwrite("pos_cond", &ImGuiNextWindowData::PosCond, "")    // imgui_internal.h:1086
        .def_readwrite("size_cond", &ImGuiNextWindowData::SizeCond, "")    // imgui_internal.h:1087
        .def_readwrite("collapsed_cond", &ImGuiNextWindowData::CollapsedCond, "")    // imgui_internal.h:1088
        .def_readwrite("dock_cond", &ImGuiNextWindowData::DockCond, "")    // imgui_internal.h:1089
        .def_readwrite("pos_val", &ImGuiNextWindowData::PosVal, "")    // imgui_internal.h:1090
        .def_readwrite("pos_pivot_val", &ImGuiNextWindowData::PosPivotVal, "")    // imgui_internal.h:1091
        .def_readwrite("size_val", &ImGuiNextWindowData::SizeVal, "")    // imgui_internal.h:1092
        .def_readwrite("content_size_val", &ImGuiNextWindowData::ContentSizeVal, "")    // imgui_internal.h:1093
        .def_readwrite("scroll_val", &ImGuiNextWindowData::ScrollVal, "")    // imgui_internal.h:1094
        .def_readwrite("pos_undock", &ImGuiNextWindowData::PosUndock, "")    // imgui_internal.h:1095
        .def_readwrite("collapsed_val", &ImGuiNextWindowData::CollapsedVal, "")    // imgui_internal.h:1096
        .def_readwrite("size_constraint_rect", &ImGuiNextWindowData::SizeConstraintRect, "")    // imgui_internal.h:1097
        .def_readwrite("size_callback_user_data", &ImGuiNextWindowData::SizeCallbackUserData, "")    // imgui_internal.h:1099
        .def_readwrite("bg_alpha_val", &ImGuiNextWindowData::BgAlphaVal, "Override background alpha")    // imgui_internal.h:1100
        .def_readwrite("viewport_id", &ImGuiNextWindowData::ViewportId, "")    // imgui_internal.h:1101
        .def_readwrite("dock_id", &ImGuiNextWindowData::DockId, "")    // imgui_internal.h:1102
        .def_readwrite("window_class", &ImGuiNextWindowData::WindowClass, "")    // imgui_internal.h:1103
        .def_readwrite("menu_bar_offset_min_val", &ImGuiNextWindowData::MenuBarOffsetMinVal, "(Always on) This is not exposed publicly, so we don't clear it and it doesn't have a corresponding flag (could we? for consistency?)")    // imgui_internal.h:1104
        .def(py::init<>())    // imgui_internal.h:1106
        ;


    py::enum_<ImGuiNextItemDataFlags_>(m, "ImGuiNextItemDataFlags_", py::arithmetic(), "")    // imgui_internal.h:1110
        .value("none", ImGuiNextItemDataFlags_None, "")
        .value("has_width", ImGuiNextItemDataFlags_HasWidth, "")
        .value("has_open", ImGuiNextItemDataFlags_HasOpen, "");


    auto pyClassImGuiNextItemData =
        py::class_<ImGuiNextItemData>    // imgui_internal.h:1117
            (m, "ImGuiNextItemData", "")
        .def(py::init<>([](
        ImGuiNextItemDataFlags Flags = ImGuiNextItemDataFlags(), float Width = float(), ImGuiID FocusScopeId = ImGuiID(), ImGuiCond OpenCond = ImGuiCond(), bool OpenVal = bool())
        {
            auto r = std::make_unique<ImGuiNextItemData>();
            r->Flags = Flags;
            r->Width = Width;
            r->FocusScopeId = FocusScopeId;
            r->OpenCond = OpenCond;
            r->OpenVal = OpenVal;
            return r;
        })
        , py::arg("flags") = ImGuiNextItemDataFlags(), py::arg("width") = float(), py::arg("focus_scope_id") = ImGuiID(), py::arg("open_cond") = ImGuiCond(), py::arg("open_val") = bool()
        )
        .def_readwrite("flags", &ImGuiNextItemData::Flags, "")    // imgui_internal.h:1119
        .def_readwrite("width", &ImGuiNextItemData::Width, "Set by SetNextItemWidth()")    // imgui_internal.h:1120
        .def_readwrite("focus_scope_id", &ImGuiNextItemData::FocusScopeId, "Set by SetNextItemMultiSelectData() (!= 0 signify value has been set, so it's an alternate version of HasSelectionData, we don't use Flags for this because they are cleared too early. This is mostly used for debugging)")    // imgui_internal.h:1121
        .def_readwrite("open_cond", &ImGuiNextItemData::OpenCond, "")    // imgui_internal.h:1122
        .def_readwrite("open_val", &ImGuiNextItemData::OpenVal, "Set by SetNextItemOpen()")    // imgui_internal.h:1123
        .def(py::init<>())    // imgui_internal.h:1125
        ;


    auto pyClassImGuiLastItemData =
        py::class_<ImGuiLastItemData>    // imgui_internal.h:1130
            (m, "ImGuiLastItemData", "Status storage for the last submitted item")
        .def(py::init<>([](
        ImGuiID ID = ImGuiID(), ImGuiItemFlags InFlags = ImGuiItemFlags(), ImGuiItemStatusFlags StatusFlags = ImGuiItemStatusFlags(), ImRect Rect = ImRect(), ImRect NavRect = ImRect(), ImRect DisplayRect = ImRect())
        {
            auto r = std::make_unique<ImGuiLastItemData>();
            r->ID = ID;
            r->InFlags = InFlags;
            r->StatusFlags = StatusFlags;
            r->Rect = Rect;
            r->NavRect = NavRect;
            r->DisplayRect = DisplayRect;
            return r;
        })
        , py::arg("id") = ImGuiID(), py::arg("in_flags") = ImGuiItemFlags(), py::arg("status_flags") = ImGuiItemStatusFlags(), py::arg("rect") = ImRect(), py::arg("nav_rect") = ImRect(), py::arg("display_rect") = ImRect()
        )
        .def_readwrite("id", &ImGuiLastItemData::ID, "")    // imgui_internal.h:1132
        .def_readwrite("in_flags", &ImGuiLastItemData::InFlags, "See ImGuiItemFlags_")    // imgui_internal.h:1133
        .def_readwrite("status_flags", &ImGuiLastItemData::StatusFlags, "See ImGuiItemStatusFlags_")    // imgui_internal.h:1134
        .def_readwrite("rect", &ImGuiLastItemData::Rect, "Full rectangle")    // imgui_internal.h:1135
        .def_readwrite("nav_rect", &ImGuiLastItemData::NavRect, "Navigation scoring rectangle (not displayed)")    // imgui_internal.h:1136
        .def_readwrite("display_rect", &ImGuiLastItemData::DisplayRect, "Display rectangle (only if ImGuiItemStatusFlags_HasDisplayRect is set)")    // imgui_internal.h:1137
        .def(py::init<>())    // imgui_internal.h:1139
        ;


    auto pyClassImGuiStackSizes =
        py::class_<ImGuiStackSizes>    // imgui_internal.h:1142
            (m, "ImGuiStackSizes", "")
        .def(py::init<>([](
        short SizeOfIDStack = short(), short SizeOfColorStack = short(), short SizeOfStyleVarStack = short(), short SizeOfFontStack = short(), short SizeOfFocusScopeStack = short(), short SizeOfGroupStack = short(), short SizeOfItemFlagsStack = short(), short SizeOfBeginPopupStack = short(), short SizeOfDisabledStack = short())
        {
            auto r = std::make_unique<ImGuiStackSizes>();
            r->SizeOfIDStack = SizeOfIDStack;
            r->SizeOfColorStack = SizeOfColorStack;
            r->SizeOfStyleVarStack = SizeOfStyleVarStack;
            r->SizeOfFontStack = SizeOfFontStack;
            r->SizeOfFocusScopeStack = SizeOfFocusScopeStack;
            r->SizeOfGroupStack = SizeOfGroupStack;
            r->SizeOfItemFlagsStack = SizeOfItemFlagsStack;
            r->SizeOfBeginPopupStack = SizeOfBeginPopupStack;
            r->SizeOfDisabledStack = SizeOfDisabledStack;
            return r;
        })
        , py::arg("size_of_id_stack") = short(), py::arg("size_of_color_stack") = short(), py::arg("size_of_style_var_stack") = short(), py::arg("size_of_font_stack") = short(), py::arg("size_of_focus_scope_stack") = short(), py::arg("size_of_group_stack") = short(), py::arg("size_of_item_flags_stack") = short(), py::arg("size_of_begin_popup_stack") = short(), py::arg("size_of_disabled_stack") = short()
        )
        .def_readwrite("size_of_id_stack", &ImGuiStackSizes::SizeOfIDStack, "")    // imgui_internal.h:1144
        .def_readwrite("size_of_color_stack", &ImGuiStackSizes::SizeOfColorStack, "")    // imgui_internal.h:1145
        .def_readwrite("size_of_style_var_stack", &ImGuiStackSizes::SizeOfStyleVarStack, "")    // imgui_internal.h:1146
        .def_readwrite("size_of_font_stack", &ImGuiStackSizes::SizeOfFontStack, "")    // imgui_internal.h:1147
        .def_readwrite("size_of_focus_scope_stack", &ImGuiStackSizes::SizeOfFocusScopeStack, "")    // imgui_internal.h:1148
        .def_readwrite("size_of_group_stack", &ImGuiStackSizes::SizeOfGroupStack, "")    // imgui_internal.h:1149
        .def_readwrite("size_of_item_flags_stack", &ImGuiStackSizes::SizeOfItemFlagsStack, "")    // imgui_internal.h:1150
        .def_readwrite("size_of_begin_popup_stack", &ImGuiStackSizes::SizeOfBeginPopupStack, "")    // imgui_internal.h:1151
        .def_readwrite("size_of_disabled_stack", &ImGuiStackSizes::SizeOfDisabledStack, "")    // imgui_internal.h:1152
        .def(py::init<>())    // imgui_internal.h:1154
        ;


    auto pyClassImGuiWindowStackData =
        py::class_<ImGuiWindowStackData>    // imgui_internal.h:1160
            (m, "ImGuiWindowStackData", "Data saved for each window pushed into the stack")
        .def(py::init<>([](
        ImGuiLastItemData ParentLastItemDataBackup = ImGuiLastItemData(), ImGuiStackSizes StackSizesOnBegin = ImGuiStackSizes())
        {
            auto r = std::make_unique<ImGuiWindowStackData>();
            r->ParentLastItemDataBackup = ParentLastItemDataBackup;
            r->StackSizesOnBegin = StackSizesOnBegin;
            return r;
        })
        , py::arg("parent_last_item_data_backup") = ImGuiLastItemData(), py::arg("stack_sizes_on_begin") = ImGuiStackSizes()
        )
        .def_readwrite("window", &ImGuiWindowStackData::Window, "")    // imgui_internal.h:1162
        .def_readwrite("parent_last_item_data_backup", &ImGuiWindowStackData::ParentLastItemDataBackup, "")    // imgui_internal.h:1163
        .def_readwrite("stack_sizes_on_begin", &ImGuiWindowStackData::StackSizesOnBegin, "Store size of various stacks for asserting")    // imgui_internal.h:1164
        ;


    auto pyClassImGuiShrinkWidthItem =
        py::class_<ImGuiShrinkWidthItem>    // imgui_internal.h:1167
            (m, "ImGuiShrinkWidthItem", "")
        .def(py::init<>([](
        int Index = int(), float Width = float(), float InitialWidth = float())
        {
            auto r = std::make_unique<ImGuiShrinkWidthItem>();
            r->Index = Index;
            r->Width = Width;
            r->InitialWidth = InitialWidth;
            return r;
        })
        , py::arg("index") = int(), py::arg("width") = float(), py::arg("initial_width") = float()
        )
        .def_readwrite("index", &ImGuiShrinkWidthItem::Index, "")    // imgui_internal.h:1169
        .def_readwrite("width", &ImGuiShrinkWidthItem::Width, "")    // imgui_internal.h:1170
        .def_readwrite("initial_width", &ImGuiShrinkWidthItem::InitialWidth, "")    // imgui_internal.h:1171
        ;


    auto pyClassImGuiPtrOrIndex =
        py::class_<ImGuiPtrOrIndex>    // imgui_internal.h:1174
            (m, "ImGuiPtrOrIndex", "")
        .def_readwrite("ptr", &ImGuiPtrOrIndex::Ptr, "Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.")    // imgui_internal.h:1176
        .def_readwrite("index", &ImGuiPtrOrIndex::Index, "Usually index in a main pool.")    // imgui_internal.h:1177
        .def(py::init<void *>(),    // imgui_internal.h:1179
            py::arg("ptr"))
        .def(py::init<int>(),    // imgui_internal.h:1180
            py::arg("index"))
        ;


    py::enum_<ImGuiKeyPrivate_>(m, "ImGuiKeyPrivate_", py::arithmetic(), "")    // imgui_internal.h:1189
        .value("im_gui_key_legacy_native_key_begin", ImGuiKey_LegacyNativeKey_BEGIN, "")
        .value("im_gui_key_legacy_native_key_end", ImGuiKey_LegacyNativeKey_END, "")
        .value("im_gui_key_gamepad_begin", ImGuiKey_Gamepad_BEGIN, "")
        .value("im_gui_key_gamepad_end", ImGuiKey_Gamepad_END, "");


    py::enum_<ImGuiInputEventType>(m, "ImGuiInputEventType", py::arithmetic(), "")    // imgui_internal.h:1197
        .value("none", ImGuiInputEventType_None, "")
        .value("mouse_pos", ImGuiInputEventType_MousePos, "")
        .value("mouse_wheel", ImGuiInputEventType_MouseWheel, "")
        .value("mouse_button", ImGuiInputEventType_MouseButton, "")
        .value("mouse_viewport", ImGuiInputEventType_MouseViewport, "")
        .value("key", ImGuiInputEventType_Key, "")
        .value("text", ImGuiInputEventType_Text, "")
        .value("focus", ImGuiInputEventType_Focus, "")
        .value("count", ImGuiInputEventType_COUNT, "");


    py::enum_<ImGuiInputSource>(m, "ImGuiInputSource", py::arithmetic(), "")    // imgui_internal.h:1210
        .value("none", ImGuiInputSource_None, "")
        .value("mouse", ImGuiInputSource_Mouse, "")
        .value("keyboard", ImGuiInputSource_Keyboard, "")
        .value("gamepad", ImGuiInputSource_Gamepad, "")
        .value("clipboard", ImGuiInputSource_Clipboard, "Currently only used by InputText()")
        .value("nav", ImGuiInputSource_Nav, "Stored in g.ActiveIdSource only")
        .value("count", ImGuiInputSource_COUNT, "");


    auto pyClassImGuiInputEventMousePos =
        py::class_<ImGuiInputEventMousePos>    // imgui_internal.h:1223
            (m, "ImGuiInputEventMousePos", "")
        .def(py::init<>([](
        float PosX = float(), float PosY = float())
        {
            auto r = std::make_unique<ImGuiInputEventMousePos>();
            r->PosX = PosX;
            r->PosY = PosY;
            return r;
        })
        , py::arg("pos_x") = float(), py::arg("pos_y") = float()
        )
        .def_readwrite("pos_x", &ImGuiInputEventMousePos::PosX, "")    // imgui_internal.h:1223
        .def_readwrite("pos_y", &ImGuiInputEventMousePos::PosY, "")    // imgui_internal.h:1223
        ;


    auto pyClassImGuiInputEventMouseWheel =
        py::class_<ImGuiInputEventMouseWheel>    // imgui_internal.h:1224
            (m, "ImGuiInputEventMouseWheel", "")
        .def(py::init<>([](
        float WheelX = float(), float WheelY = float())
        {
            auto r = std::make_unique<ImGuiInputEventMouseWheel>();
            r->WheelX = WheelX;
            r->WheelY = WheelY;
            return r;
        })
        , py::arg("wheel_x") = float(), py::arg("wheel_y") = float()
        )
        .def_readwrite("wheel_x", &ImGuiInputEventMouseWheel::WheelX, "")    // imgui_internal.h:1224
        .def_readwrite("wheel_y", &ImGuiInputEventMouseWheel::WheelY, "")    // imgui_internal.h:1224
        ;


    auto pyClassImGuiInputEventMouseButton =
        py::class_<ImGuiInputEventMouseButton>    // imgui_internal.h:1225
            (m, "ImGuiInputEventMouseButton", "")
        .def(py::init<>([](
        int Button = int(), bool Down = bool())
        {
            auto r = std::make_unique<ImGuiInputEventMouseButton>();
            r->Button = Button;
            r->Down = Down;
            return r;
        })
        , py::arg("button") = int(), py::arg("down") = bool()
        )
        .def_readwrite("button", &ImGuiInputEventMouseButton::Button, "")    // imgui_internal.h:1225
        .def_readwrite("down", &ImGuiInputEventMouseButton::Down, "")    // imgui_internal.h:1225
        ;


    auto pyClassImGuiInputEventMouseViewport =
        py::class_<ImGuiInputEventMouseViewport>    // imgui_internal.h:1226
            (m, "ImGuiInputEventMouseViewport", "")
        .def(py::init<>([](
        ImGuiID HoveredViewportID = ImGuiID())
        {
            auto r = std::make_unique<ImGuiInputEventMouseViewport>();
            r->HoveredViewportID = HoveredViewportID;
            return r;
        })
        , py::arg("hovered_viewport_id") = ImGuiID()
        )
        .def_readwrite("hovered_viewport_id", &ImGuiInputEventMouseViewport::HoveredViewportID, "")    // imgui_internal.h:1226
        ;


    auto pyClassImGuiInputEventKey =
        py::class_<ImGuiInputEventKey>    // imgui_internal.h:1227
            (m, "ImGuiInputEventKey", "")
        .def(py::init<>([](
        ImGuiKey Key = ImGuiKey(), bool Down = bool(), float AnalogValue = float())
        {
            auto r = std::make_unique<ImGuiInputEventKey>();
            r->Key = Key;
            r->Down = Down;
            r->AnalogValue = AnalogValue;
            return r;
        })
        , py::arg("key") = ImGuiKey(), py::arg("down") = bool(), py::arg("analog_value") = float()
        )
        .def_readwrite("key", &ImGuiInputEventKey::Key, "")    // imgui_internal.h:1227
        .def_readwrite("down", &ImGuiInputEventKey::Down, "")    // imgui_internal.h:1227
        .def_readwrite("analog_value", &ImGuiInputEventKey::AnalogValue, "")    // imgui_internal.h:1227
        ;


    auto pyClassImGuiInputEventText =
        py::class_<ImGuiInputEventText>    // imgui_internal.h:1228
            (m, "ImGuiInputEventText", "")
        .def(py::init<>()) // implicit default constructor
        .def_readwrite("char", &ImGuiInputEventText::Char, "")    // imgui_internal.h:1228
        ;


    auto pyClassImGuiInputEventAppFocused =
        py::class_<ImGuiInputEventAppFocused>    // imgui_internal.h:1229
            (m, "ImGuiInputEventAppFocused", "")
        .def(py::init<>([](
        bool Focused = bool())
        {
            auto r = std::make_unique<ImGuiInputEventAppFocused>();
            r->Focused = Focused;
            return r;
        })
        , py::arg("focused") = bool()
        )
        .def_readwrite("focused", &ImGuiInputEventAppFocused::Focused, "")    // imgui_internal.h:1229
        ;


    auto pyClassImGuiInputEvent =
        py::class_<ImGuiInputEvent>    // imgui_internal.h:1231
            (m, "ImGuiInputEvent", "")
        .def(py::init<>([](
        ImGuiInputEventType Type = ImGuiInputEventType(), ImGuiInputSource Source = ImGuiInputSource(), bool AddedByTestEngine = bool())
        {
            auto r = std::make_unique<ImGuiInputEvent>();
            r->Type = Type;
            r->Source = Source;
            r->AddedByTestEngine = AddedByTestEngine;
            return r;
        })
        , py::arg("type") = ImGuiInputEventType(), py::arg("source") = ImGuiInputSource(), py::arg("added_by_test_engine") = bool()
        )
        .def_readwrite("type", &ImGuiInputEvent::Type, "")    // imgui_internal.h:1233
        .def_readwrite("source", &ImGuiInputEvent::Source, "")    // imgui_internal.h:1234
        .def_readwrite("added_by_test_engine", &ImGuiInputEvent::AddedByTestEngine, "")    // imgui_internal.h:1245
        .def(py::init<>())    // imgui_internal.h:1247
        ;


    py::enum_<ImGuiNavReadMode>(m, "ImGuiNavReadMode", py::arithmetic(), "FIXME-NAV: Clarify/expose various repeat delay/rate")    // imgui_internal.h:1251
        .value("down", ImGuiNavReadMode_Down, "")
        .value("pressed", ImGuiNavReadMode_Pressed, "")
        .value("released", ImGuiNavReadMode_Released, "")
        .value("repeat", ImGuiNavReadMode_Repeat, "")
        .value("repeat_slow", ImGuiNavReadMode_RepeatSlow, "")
        .value("repeat_fast", ImGuiNavReadMode_RepeatFast, "");


    auto pyClassImGuiListClipperRange =
        py::class_<ImGuiListClipperRange>    // imgui_internal.h:1265
            (m, "ImGuiListClipperRange", "")
        .def(py::init<>([](
        int Min = int(), int Max = int(), bool PosToIndexConvert = bool(), ImS8 PosToIndexOffsetMin = ImS8(), ImS8 PosToIndexOffsetMax = ImS8())
        {
            auto r = std::make_unique<ImGuiListClipperRange>();
            r->Min = Min;
            r->Max = Max;
            r->PosToIndexConvert = PosToIndexConvert;
            r->PosToIndexOffsetMin = PosToIndexOffsetMin;
            r->PosToIndexOffsetMax = PosToIndexOffsetMax;
            return r;
        })
        , py::arg("min") = int(), py::arg("max") = int(), py::arg("pos_to_index_convert") = bool(), py::arg("pos_to_index_offset_min") = ImS8(), py::arg("pos_to_index_offset_max") = ImS8()
        )
        .def_readwrite("min", &ImGuiListClipperRange::Min, "")    // imgui_internal.h:1267
        .def_readwrite("max", &ImGuiListClipperRange::Max, "")    // imgui_internal.h:1268
        .def_readwrite("pos_to_index_convert", &ImGuiListClipperRange::PosToIndexConvert, "Begin/End are absolute position (will be converted to indices later)")    // imgui_internal.h:1269
        .def_readwrite("pos_to_index_offset_min", &ImGuiListClipperRange::PosToIndexOffsetMin, "Add to Min after converting to indices")    // imgui_internal.h:1270
        .def_readwrite("pos_to_index_offset_max", &ImGuiListClipperRange::PosToIndexOffsetMax, "Add to Min after converting to indices")    // imgui_internal.h:1271
        ;


    auto pyClassImGuiListClipperData =
        py::class_<ImGuiListClipperData>    // imgui_internal.h:1278
            (m, "ImGuiListClipperData", "Temporary clipper data, buffers shared/reused between instances")
        .def(py::init<>([](
        float LossynessOffset = float(), int StepNo = int(), int ItemsFrozen = int())
        {
            auto r = std::make_unique<ImGuiListClipperData>();
            r->LossynessOffset = LossynessOffset;
            r->StepNo = StepNo;
            r->ItemsFrozen = ItemsFrozen;
            return r;
        })
        , py::arg("lossyness_offset") = float(), py::arg("step_no") = int(), py::arg("items_frozen") = int()
        )
        .def_readwrite("list_clipper", &ImGuiListClipperData::ListClipper, "")    // imgui_internal.h:1280
        .def_readwrite("lossyness_offset", &ImGuiListClipperData::LossynessOffset, "")    // imgui_internal.h:1281
        .def_readwrite("step_no", &ImGuiListClipperData::StepNo, "")    // imgui_internal.h:1282
        .def_readwrite("items_frozen", &ImGuiListClipperData::ItemsFrozen, "")    // imgui_internal.h:1283
        .def(py::init<>())    // imgui_internal.h:1286
        ;


    py::enum_<ImGuiActivateFlags_>(m, "ImGuiActivateFlags_", py::arithmetic(), "")    // imgui_internal.h:1294
        .value("none", ImGuiActivateFlags_None, "")
        .value("prefer_input", ImGuiActivateFlags_PreferInput, "Favor activation that requires keyboard text input (e.g. for Slider/Drag). Default if keyboard is available.")
        .value("prefer_tweak", ImGuiActivateFlags_PreferTweak, "Favor activation for tweaking with arrows or gamepad (e.g. for Slider/Drag). Default if keyboard is not available.")
        .value("try_to_preserve_state", ImGuiActivateFlags_TryToPreserveState, "Request widget to preserve state if it can (e.g. InputText will try to preserve cursor/selection)");


    py::enum_<ImGuiScrollFlags_>(m, "ImGuiScrollFlags_", py::arithmetic(), "Early work-in-progress API for ScrollToItem()")    // imgui_internal.h:1303
        .value("none", ImGuiScrollFlags_None, "")
        .value("keep_visible_edge_x", ImGuiScrollFlags_KeepVisibleEdgeX, "If item is not visible: scroll as little as possible on X axis to bring item back into view [default for X axis]")
        .value("keep_visible_edge_y", ImGuiScrollFlags_KeepVisibleEdgeY, "If item is not visible: scroll as little as possible on Y axis to bring item back into view [default for Y axis for windows that are already visible]")
        .value("keep_visible_center_x", ImGuiScrollFlags_KeepVisibleCenterX, "If item is not visible: scroll to make the item centered on X axis [rarely used]")
        .value("keep_visible_center_y", ImGuiScrollFlags_KeepVisibleCenterY, "If item is not visible: scroll to make the item centered on Y axis")
        .value("always_center_x", ImGuiScrollFlags_AlwaysCenterX, "Always center the result item on X axis [rarely used]")
        .value("always_center_y", ImGuiScrollFlags_AlwaysCenterY, "Always center the result item on Y axis [default for Y axis for appearing window)")
        .value("no_scroll_parent", ImGuiScrollFlags_NoScrollParent, "Disable forwarding scrolling to parent window if required to keep item/rect visible (only scroll window the function was applied to).")
        .value("mask_x_", ImGuiScrollFlags_MaskX_, "")
        .value("mask_y_", ImGuiScrollFlags_MaskY_, "");


    py::enum_<ImGuiNavHighlightFlags_>(m, "ImGuiNavHighlightFlags_", py::arithmetic(), "")    // imgui_internal.h:1317
        .value("none", ImGuiNavHighlightFlags_None, "")
        .value("type_default", ImGuiNavHighlightFlags_TypeDefault, "")
        .value("type_thin", ImGuiNavHighlightFlags_TypeThin, "")
        .value("always_draw", ImGuiNavHighlightFlags_AlwaysDraw, "Draw rectangular highlight if (g.NavId == id) _even_ when using the mouse.")
        .value("no_rounding", ImGuiNavHighlightFlags_NoRounding, "");


    py::enum_<ImGuiNavDirSourceFlags_>(m, "ImGuiNavDirSourceFlags_", py::arithmetic(), "")    // imgui_internal.h:1326
        .value("none", ImGuiNavDirSourceFlags_None, "")
        .value("raw_keyboard", ImGuiNavDirSourceFlags_RawKeyboard, "Raw keyboard (not pulled from nav), facilitate use of some functions before we can unify nav and keys")
        .value("keyboard", ImGuiNavDirSourceFlags_Keyboard, "")
        .value("pad_d_pad", ImGuiNavDirSourceFlags_PadDPad, "")
        .value("pad_l_stick", ImGuiNavDirSourceFlags_PadLStick, "");


    py::enum_<ImGuiNavMoveFlags_>(m, "ImGuiNavMoveFlags_", py::arithmetic(), "")    // imgui_internal.h:1335
        .value("none", ImGuiNavMoveFlags_None, "")
        .value("loop_x", ImGuiNavMoveFlags_LoopX, "On failed request, restart from opposite side")
        .value("loop_y", ImGuiNavMoveFlags_LoopY, "")
        .value("wrap_x", ImGuiNavMoveFlags_WrapX, "On failed request, request from opposite side one line down (when NavDir==right) or one line up (when NavDir==left)")
        .value("wrap_y", ImGuiNavMoveFlags_WrapY, "This is not super useful but provided for completeness")
        .value("allow_current_nav_id", ImGuiNavMoveFlags_AllowCurrentNavId, "Allow scoring and considering the current NavId as a move target candidate. This is used when the move source is offset (e.g. pressing PageDown actually needs to send a Up move request, if we are pressing PageDown from the bottom-most item we need to stay in place)")
        .value("also_score_visible_set", ImGuiNavMoveFlags_AlsoScoreVisibleSet, "Store alternate result in NavMoveResultLocalVisible that only comprise elements that are already fully visible (used by PageUp/PageDown)")
        .value("scroll_to_edge_y", ImGuiNavMoveFlags_ScrollToEdgeY, "Force scrolling to min/max (used by Home/End) // FIXME-NAV: Aim to remove or reword, probably unnecessary")
        .value("forwarded", ImGuiNavMoveFlags_Forwarded, "")
        .value("debug_no_result", ImGuiNavMoveFlags_DebugNoResult, "Dummy scoring for debug purpose, don't apply result")
        .value("focus_api", ImGuiNavMoveFlags_FocusApi, "")
        .value("tabbing", ImGuiNavMoveFlags_Tabbing, "== Focus + Activate if item is Inputable + DontChangeNavHighlight")
        .value("activate", ImGuiNavMoveFlags_Activate, "")
        .value("dont_set_nav_highlight", ImGuiNavMoveFlags_DontSetNavHighlight, "Do not alter the visible state of keyboard vs mouse nav highlight");


    py::enum_<ImGuiNavLayer>(m, "ImGuiNavLayer", py::arithmetic(), "")    // imgui_internal.h:1353
        .value("main", ImGuiNavLayer_Main, "Main scrolling layer")
        .value("menu", ImGuiNavLayer_Menu, "Menu layer (access with Alt/ImGuiNavInput_Menu)")
        .value("count", ImGuiNavLayer_COUNT, "");


    auto pyClassImGuiNavItemData =
        py::class_<ImGuiNavItemData>    // imgui_internal.h:1360
            (m, "ImGuiNavItemData", "")
        .def(py::init<>([](
        ImGuiID ID = ImGuiID(), ImGuiID FocusScopeId = ImGuiID(), ImRect RectRel = ImRect(), ImGuiItemFlags InFlags = ImGuiItemFlags(), float DistBox = float(), float DistCenter = float(), float DistAxial = float())
        {
            auto r = std::make_unique<ImGuiNavItemData>();
            r->ID = ID;
            r->FocusScopeId = FocusScopeId;
            r->RectRel = RectRel;
            r->InFlags = InFlags;
            r->DistBox = DistBox;
            r->DistCenter = DistCenter;
            r->DistAxial = DistAxial;
            return r;
        })
        , py::arg("id") = ImGuiID(), py::arg("focus_scope_id") = ImGuiID(), py::arg("rect_rel") = ImRect(), py::arg("in_flags") = ImGuiItemFlags(), py::arg("dist_box") = float(), py::arg("dist_center") = float(), py::arg("dist_axial") = float()
        )
        .def_readwrite("window", &ImGuiNavItemData::Window, "Init,Move    // Best candidate window (result->ItemWindow->RootWindowForNav == request->Window)")    // imgui_internal.h:1362
        .def_readwrite("id", &ImGuiNavItemData::ID, "Init,Move    // Best candidate item ID")    // imgui_internal.h:1363
        .def_readwrite("focus_scope_id", &ImGuiNavItemData::FocusScopeId, "Init,Move    // Best candidate focus scope ID")    // imgui_internal.h:1364
        .def_readwrite("rect_rel", &ImGuiNavItemData::RectRel, "Init,Move    // Best candidate bounding box in window relative space")    // imgui_internal.h:1365
        .def_readwrite("in_flags", &ImGuiNavItemData::InFlags, "????,Move    // Best candidate item flags")    // imgui_internal.h:1366
        .def_readwrite("dist_box", &ImGuiNavItemData::DistBox, "Move    // Best candidate box distance to current NavId")    // imgui_internal.h:1367
        .def_readwrite("dist_center", &ImGuiNavItemData::DistCenter, "Move    // Best candidate center distance to current NavId")    // imgui_internal.h:1368
        .def_readwrite("dist_axial", &ImGuiNavItemData::DistAxial, "Move    // Best candidate axial distance to current NavId")    // imgui_internal.h:1369
        .def(py::init<>())    // imgui_internal.h:1371
        ;


    py::enum_<ImGuiOldColumnFlags_>(m, "ImGuiOldColumnFlags_", py::arithmetic(), "Flags for internal's BeginColumns(). Prefix using BeginTable() nowadays!")    // imgui_internal.h:1380
        .value("none", ImGuiOldColumnFlags_None, "")
        .value("no_border", ImGuiOldColumnFlags_NoBorder, "Disable column dividers")
        .value("no_resize", ImGuiOldColumnFlags_NoResize, "Disable resizing columns when clicking on the dividers")
        .value("no_preserve_widths", ImGuiOldColumnFlags_NoPreserveWidths, "Disable column width preservation when adjusting columns")
        .value("no_force_within_window", ImGuiOldColumnFlags_NoForceWithinWindow, "Disable forcing columns to fit within window")
        .value("grow_parent_contents_size", ImGuiOldColumnFlags_GrowParentContentsSize, "");


    auto pyClassImGuiOldColumnData =
        py::class_<ImGuiOldColumnData>    // imgui_internal.h:1400
            (m, "ImGuiOldColumnData", "")
        .def(py::init<>([](
        float OffsetNorm = float(), float OffsetNormBeforeResize = float(), ImGuiOldColumnFlags Flags = ImGuiOldColumnFlags(), ImRect ClipRect = ImRect())
        {
            auto r = std::make_unique<ImGuiOldColumnData>();
            r->OffsetNorm = OffsetNorm;
            r->OffsetNormBeforeResize = OffsetNormBeforeResize;
            r->Flags = Flags;
            r->ClipRect = ClipRect;
            return r;
        })
        , py::arg("offset_norm") = float(), py::arg("offset_norm_before_resize") = float(), py::arg("flags") = ImGuiOldColumnFlags(), py::arg("clip_rect") = ImRect()
        )
        .def_readwrite("offset_norm", &ImGuiOldColumnData::OffsetNorm, "Column start offset, normalized 0.0 (far left) -> 1.0 (far right)")    // imgui_internal.h:1402
        .def_readwrite("offset_norm_before_resize", &ImGuiOldColumnData::OffsetNormBeforeResize, "")    // imgui_internal.h:1403
        .def_readwrite("flags", &ImGuiOldColumnData::Flags, "Not exposed")    // imgui_internal.h:1404
        .def_readwrite("clip_rect", &ImGuiOldColumnData::ClipRect, "")    // imgui_internal.h:1405
        .def(py::init<>())    // imgui_internal.h:1407
        ;


    auto pyClassImGuiOldColumns =
        py::class_<ImGuiOldColumns>    // imgui_internal.h:1410
            (m, "ImGuiOldColumns", "")
        .def(py::init<>([](
        ImGuiID ID = ImGuiID(), ImGuiOldColumnFlags Flags = ImGuiOldColumnFlags(), bool IsFirstFrame = bool(), bool IsBeingResized = bool(), int Current = int(), int Count = int(), float OffMinX = float(), float OffMaxX = float(), float LineMinY = float(), float LineMaxY = float(), float HostCursorPosY = float(), float HostCursorMaxPosX = float(), ImRect HostInitialClipRect = ImRect(), ImRect HostBackupClipRect = ImRect(), ImRect HostBackupParentWorkRect = ImRect(), ImDrawListSplitter Splitter = ImDrawListSplitter())
        {
            auto r = std::make_unique<ImGuiOldColumns>();
            r->ID = ID;
            r->Flags = Flags;
            r->IsFirstFrame = IsFirstFrame;
            r->IsBeingResized = IsBeingResized;
            r->Current = Current;
            r->Count = Count;
            r->OffMinX = OffMinX;
            r->OffMaxX = OffMaxX;
            r->LineMinY = LineMinY;
            r->LineMaxY = LineMaxY;
            r->HostCursorPosY = HostCursorPosY;
            r->HostCursorMaxPosX = HostCursorMaxPosX;
            r->HostInitialClipRect = HostInitialClipRect;
            r->HostBackupClipRect = HostBackupClipRect;
            r->HostBackupParentWorkRect = HostBackupParentWorkRect;
            r->Splitter = Splitter;
            return r;
        })
        , py::arg("id") = ImGuiID(), py::arg("flags") = ImGuiOldColumnFlags(), py::arg("is_first_frame") = bool(), py::arg("is_being_resized") = bool(), py::arg("current") = int(), py::arg("count") = int(), py::arg("off_min_x") = float(), py::arg("off_max_x") = float(), py::arg("line_min_y") = float(), py::arg("line_max_y") = float(), py::arg("host_cursor_pos_y") = float(), py::arg("host_cursor_max_pos_x") = float(), py::arg("host_initial_clip_rect") = ImRect(), py::arg("host_backup_clip_rect") = ImRect(), py::arg("host_backup_parent_work_rect") = ImRect(), py::arg("splitter") = ImDrawListSplitter()
        )
        .def_readwrite("id", &ImGuiOldColumns::ID, "")    // imgui_internal.h:1412
        .def_readwrite("flags", &ImGuiOldColumns::Flags, "")    // imgui_internal.h:1413
        .def_readwrite("is_first_frame", &ImGuiOldColumns::IsFirstFrame, "")    // imgui_internal.h:1414
        .def_readwrite("is_being_resized", &ImGuiOldColumns::IsBeingResized, "")    // imgui_internal.h:1415
        .def_readwrite("current", &ImGuiOldColumns::Current, "")    // imgui_internal.h:1416
        .def_readwrite("count", &ImGuiOldColumns::Count, "")    // imgui_internal.h:1417
        .def_readwrite("off_min_x", &ImGuiOldColumns::OffMinX, "Offsets from HostWorkRect.Min.x")    // imgui_internal.h:1418
        .def_readwrite("off_max_x", &ImGuiOldColumns::OffMaxX, "Offsets from HostWorkRect.Min.x")    // imgui_internal.h:1418
        .def_readwrite("line_min_y", &ImGuiOldColumns::LineMinY, "")    // imgui_internal.h:1419
        .def_readwrite("line_max_y", &ImGuiOldColumns::LineMaxY, "")    // imgui_internal.h:1419
        .def_readwrite("host_cursor_pos_y", &ImGuiOldColumns::HostCursorPosY, "Backup of CursorPos at the time of BeginColumns()")    // imgui_internal.h:1420
        .def_readwrite("host_cursor_max_pos_x", &ImGuiOldColumns::HostCursorMaxPosX, "Backup of CursorMaxPos at the time of BeginColumns()")    // imgui_internal.h:1421
        .def_readwrite("host_initial_clip_rect", &ImGuiOldColumns::HostInitialClipRect, "Backup of ClipRect at the time of BeginColumns()")    // imgui_internal.h:1422
        .def_readwrite("host_backup_clip_rect", &ImGuiOldColumns::HostBackupClipRect, "Backup of ClipRect during PushColumnsBackground()/PopColumnsBackground()")    // imgui_internal.h:1423
        .def_readwrite("host_backup_parent_work_rect", &ImGuiOldColumns::HostBackupParentWorkRect, "Backup of WorkRect at the time of BeginColumns()")    // imgui_internal.h:1424
        .def_readwrite("splitter", &ImGuiOldColumns::Splitter, "")    // imgui_internal.h:1426
        .def(py::init<>())    // imgui_internal.h:1428
        ;


    py::enum_<ImGuiDockNodeFlagsPrivate_>(m, "ImGuiDockNodeFlagsPrivate_", py::arithmetic(), "Extend ImGuiDockNodeFlags_")    // imgui_internal.h:1446
        .value("im_gui_dock_node_flags_dock_space", ImGuiDockNodeFlags_DockSpace, "Local, Saved  // A dockspace is a node that occupy space within an existing user window. Otherwise the node is floating and create its own window.")
        .value("im_gui_dock_node_flags_central_node", ImGuiDockNodeFlags_CentralNode, "Local, Saved  // The central node has 2 main properties: stay visible when empty, only use \"remaining\" spaces from its neighbor.")
        .value("im_gui_dock_node_flags_no_tab_bar", ImGuiDockNodeFlags_NoTabBar, "Local, Saved  // Tab bar is completely unavailable. No triangle in the corner to enable it back.")
        .value("im_gui_dock_node_flags_hidden_tab_bar", ImGuiDockNodeFlags_HiddenTabBar, "Local, Saved  // Tab bar is hidden, with a triangle in the corner to show it again (NB: actual tab-bar instance may be destroyed as this is only used for single-window tab bar)")
        .value("im_gui_dock_node_flags_no_window_menu_button", ImGuiDockNodeFlags_NoWindowMenuButton, "Local, Saved  // Disable window/docking menu (that one that appears instead of the collapse button)")
        .value("im_gui_dock_node_flags_no_close_button", ImGuiDockNodeFlags_NoCloseButton, "Local, Saved  //")
        .value("im_gui_dock_node_flags_no_docking", ImGuiDockNodeFlags_NoDocking, "Local, Saved  // Disable any form of docking in this dockspace or individual node. (On a whole dockspace, this pretty much defeat the purpose of using a dockspace at all). Note: when turned on, existing docked nodes will be preserved.")
        .value("im_gui_dock_node_flags_no_docking_split_me", ImGuiDockNodeFlags_NoDockingSplitMe, "[EXPERIMENTAL] Prevent another window/node from splitting this node.")
        .value("im_gui_dock_node_flags_no_docking_split_other", ImGuiDockNodeFlags_NoDockingSplitOther, "[EXPERIMENTAL] Prevent this node from splitting another window/node.")
        .value("im_gui_dock_node_flags_no_docking_over_me", ImGuiDockNodeFlags_NoDockingOverMe, "[EXPERIMENTAL] Prevent another window/node to be docked over this node.")
        .value("im_gui_dock_node_flags_no_docking_over_other", ImGuiDockNodeFlags_NoDockingOverOther, "[EXPERIMENTAL] Prevent this node to be docked over another window or non-empty node.")
        .value("im_gui_dock_node_flags_no_docking_over_empty", ImGuiDockNodeFlags_NoDockingOverEmpty, "[EXPERIMENTAL] Prevent this node to be docked over an empty node (e.g. DockSpace with no other windows)")
        .value("im_gui_dock_node_flags_no_resize_x", ImGuiDockNodeFlags_NoResizeX, "[EXPERIMENTAL]")
        .value("im_gui_dock_node_flags_no_resize_y", ImGuiDockNodeFlags_NoResizeY, "[EXPERIMENTAL]")
        .value("im_gui_dock_node_flags_shared_flags_inherit_mask_", ImGuiDockNodeFlags_SharedFlagsInheritMask_, "")
        .value("im_gui_dock_node_flags_no_resize_flags_mask_", ImGuiDockNodeFlags_NoResizeFlagsMask_, "")
        .value("im_gui_dock_node_flags_local_flags_mask_", ImGuiDockNodeFlags_LocalFlagsMask_, "")
        .value("im_gui_dock_node_flags_local_flags_transfer_mask_", ImGuiDockNodeFlags_LocalFlagsTransferMask_, "When splitting those flags are moved to the inheriting child, never duplicated")
        .value("im_gui_dock_node_flags_saved_flags_mask_", ImGuiDockNodeFlags_SavedFlagsMask_, "");


    py::enum_<ImGuiDataAuthority_>(m, "ImGuiDataAuthority_", py::arithmetic(), "Store the source authority (dock node vs window) of a field")    // imgui_internal.h:1471
        .value("auto", ImGuiDataAuthority_Auto, "")
        .value("dock_node", ImGuiDataAuthority_DockNode, "")
        .value("window", ImGuiDataAuthority_Window, "");


    py::enum_<ImGuiDockNodeState>(m, "ImGuiDockNodeState", py::arithmetic(), "")    // imgui_internal.h:1478
        .value("unknown", ImGuiDockNodeState_Unknown, "")
        .value("host_window_hidden_because_single_window", ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow, "")
        .value("host_window_hidden_because_windows_are_resizing", ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing, "")
        .value("host_window_visible", ImGuiDockNodeState_HostWindowVisible, "");


    auto pyClassImGuiDockNode =
        py::class_<ImGuiDockNode>    // imgui_internal.h:1487
            (m, "ImGuiDockNode", "sizeof() 156~192")
        .def_readwrite("id", &ImGuiDockNode::ID, "")    // imgui_internal.h:1489
        .def_readwrite("shared_flags", &ImGuiDockNode::SharedFlags, "(Write) Flags shared by all nodes of a same dockspace hierarchy (inherited from the root node)")    // imgui_internal.h:1490
        .def_readwrite("local_flags", &ImGuiDockNode::LocalFlags, "(Write) Flags specific to this node")    // imgui_internal.h:1491
        .def_readwrite("local_flags_in_windows", &ImGuiDockNode::LocalFlagsInWindows, "(Write) Flags specific to this node, applied from windows")    // imgui_internal.h:1492
        .def_readwrite("merged_flags", &ImGuiDockNode::MergedFlags, "(Read)  Effective flags (== SharedFlags | LocalFlagsInNode | LocalFlagsInWindows)")    // imgui_internal.h:1493
        .def_readwrite("state", &ImGuiDockNode::State, "")    // imgui_internal.h:1494
        .def_readwrite("parent_node", &ImGuiDockNode::ParentNode, "")    // imgui_internal.h:1495
        .def_readwrite("tab_bar", &ImGuiDockNode::TabBar, "")    // imgui_internal.h:1498
        .def_readwrite("pos", &ImGuiDockNode::Pos, "Current position")    // imgui_internal.h:1499
        .def_readwrite("size", &ImGuiDockNode::Size, "Current size")    // imgui_internal.h:1500
        .def_readwrite("size_ref", &ImGuiDockNode::SizeRef, "[Split node only] Last explicitly written-to size (overridden when using a splitter affecting the node), used to calculate Size.")    // imgui_internal.h:1501
        .def_readwrite("split_axis", &ImGuiDockNode::SplitAxis, "[Split node only] Split axis (X or Y)")    // imgui_internal.h:1502
        .def_readwrite("window_class", &ImGuiDockNode::WindowClass, "[Root node only]")    // imgui_internal.h:1503
        .def_readwrite("last_bg_color", &ImGuiDockNode::LastBgColor, "")    // imgui_internal.h:1504
        .def_readwrite("host_window", &ImGuiDockNode::HostWindow, "")    // imgui_internal.h:1506
        .def_readwrite("visible_window", &ImGuiDockNode::VisibleWindow, "Generally point to window which is ID is == SelectedTabID, but when CTRL+Tabbing this can be a different window.")    // imgui_internal.h:1507
        .def_readwrite("central_node", &ImGuiDockNode::CentralNode, "[Root node only] Pointer to central node.")    // imgui_internal.h:1508
        .def_readwrite("only_node_with_windows", &ImGuiDockNode::OnlyNodeWithWindows, "[Root node only] Set when there is a single visible node within the hierarchy.")    // imgui_internal.h:1509
        .def_readwrite("count_node_with_windows", &ImGuiDockNode::CountNodeWithWindows, "[Root node only]")    // imgui_internal.h:1510
        .def_readwrite("last_frame_alive", &ImGuiDockNode::LastFrameAlive, "Last frame number the node was updated or kept alive explicitly with DockSpace() + ImGuiDockNodeFlags_KeepAliveOnly")    // imgui_internal.h:1511
        .def_readwrite("last_frame_active", &ImGuiDockNode::LastFrameActive, "Last frame number the node was updated.")    // imgui_internal.h:1512
        .def_readwrite("last_frame_focused", &ImGuiDockNode::LastFrameFocused, "Last frame number the node was focused.")    // imgui_internal.h:1513
        .def_readwrite("last_focused_node_id", &ImGuiDockNode::LastFocusedNodeId, "[Root node only] Which of our child docking node (any ancestor in the hierarchy) was last focused.")    // imgui_internal.h:1514
        .def_readwrite("selected_tab_id", &ImGuiDockNode::SelectedTabId, "[Leaf node only] Which of our tab/window is selected.")    // imgui_internal.h:1515
        .def_readwrite("want_close_tab_id", &ImGuiDockNode::WantCloseTabId, "[Leaf node only] Set when closing a specific tab/window.")    // imgui_internal.h:1516
        .def(py::init<ImGuiID>(),    // imgui_internal.h:1532
            py::arg("id"))
        ;


    py::enum_<ImGuiWindowDockStyleCol>(m, "ImGuiWindowDockStyleCol", py::arithmetic(), " List of colors that are stored at the time of Begin() into Docked Windows.\n We currently store the packed colors in a simple array window->DockStyle.Colors[].\n A better solution may involve appending into a log of colors in ImGuiContext + store offsets into those arrays in ImGuiWindow,\n but it would be more complex as we'd need to double-buffer both as e.g. drop target may refer to window from last frame.")    // imgui_internal.h:1553
        .value("text", ImGuiWindowDockStyleCol_Text, "")
        .value("tab", ImGuiWindowDockStyleCol_Tab, "")
        .value("tab_hovered", ImGuiWindowDockStyleCol_TabHovered, "")
        .value("tab_active", ImGuiWindowDockStyleCol_TabActive, "")
        .value("tab_unfocused", ImGuiWindowDockStyleCol_TabUnfocused, "")
        .value("tab_unfocused_active", ImGuiWindowDockStyleCol_TabUnfocusedActive, "")
        .value("count", ImGuiWindowDockStyleCol_COUNT, "");


    auto pyClassImGuiWindowDockStyle =
        py::class_<ImGuiWindowDockStyle>    // imgui_internal.h:1564
            (m, "ImGuiWindowDockStyle", "")
        .def(py::init<>()) // implicit default constructor
        ;


    auto pyClassImGuiDockContext =
        py::class_<ImGuiDockContext>    // imgui_internal.h:1569
            (m, "ImGuiDockContext", "")
        .def(py::init<>([](
        ImGuiStorage Nodes = ImGuiStorage(), bool WantFullRebuild = bool())
        {
            auto r = std::make_unique<ImGuiDockContext>();
            r->Nodes = Nodes;
            r->WantFullRebuild = WantFullRebuild;
            return r;
        })
        , py::arg("nodes") = ImGuiStorage(), py::arg("want_full_rebuild") = bool()
        )
        .def_readwrite("nodes", &ImGuiDockContext::Nodes, "Map ID -> ImGuiDockNode*: Active nodes")    // imgui_internal.h:1571
        .def_readwrite("want_full_rebuild", &ImGuiDockContext::WantFullRebuild, "")    // imgui_internal.h:1574
        .def(py::init<>())    // imgui_internal.h:1575
        ;


    auto pyClassImGuiViewportP =
        py::class_<ImGuiViewportP>    // imgui_internal.h:1586
            (m, "ImGuiViewportP", " ImGuiViewport Private/Internals fields (cardinal sin: we are using inheritance!)\n Every instance of ImGuiViewport is in fact a ImGuiViewportP.")
        .def(py::init<>([](
        int Idx = int(), int LastFrameActive = int(), int LastFrontMostStampCount = int(), ImGuiID LastNameHash = ImGuiID(), ImVec2 LastPos = ImVec2(), float Alpha = float(), float LastAlpha = float(), short PlatformMonitor = short(), bool PlatformWindowCreated = bool(), ImDrawData DrawDataP = ImDrawData(), ImDrawDataBuilder DrawDataBuilder = ImDrawDataBuilder(), ImVec2 LastPlatformPos = ImVec2(), ImVec2 LastPlatformSize = ImVec2(), ImVec2 LastRendererSize = ImVec2(), ImVec2 WorkOffsetMin = ImVec2(), ImVec2 WorkOffsetMax = ImVec2(), ImVec2 BuildWorkOffsetMin = ImVec2(), ImVec2 BuildWorkOffsetMax = ImVec2())
        {
            auto r = std::make_unique<ImGuiViewportP>();
            r->Idx = Idx;
            r->LastFrameActive = LastFrameActive;
            r->LastFrontMostStampCount = LastFrontMostStampCount;
            r->LastNameHash = LastNameHash;
            r->LastPos = LastPos;
            r->Alpha = Alpha;
            r->LastAlpha = LastAlpha;
            r->PlatformMonitor = PlatformMonitor;
            r->PlatformWindowCreated = PlatformWindowCreated;
            r->DrawDataP = DrawDataP;
            r->DrawDataBuilder = DrawDataBuilder;
            r->LastPlatformPos = LastPlatformPos;
            r->LastPlatformSize = LastPlatformSize;
            r->LastRendererSize = LastRendererSize;
            r->WorkOffsetMin = WorkOffsetMin;
            r->WorkOffsetMax = WorkOffsetMax;
            r->BuildWorkOffsetMin = BuildWorkOffsetMin;
            r->BuildWorkOffsetMax = BuildWorkOffsetMax;
            return r;
        })
        , py::arg("idx") = int(), py::arg("last_frame_active") = int(), py::arg("last_front_most_stamp_count") = int(), py::arg("last_name_hash") = ImGuiID(), py::arg("last_pos") = ImVec2(), py::arg("alpha") = float(), py::arg("last_alpha") = float(), py::arg("platform_monitor") = short(), py::arg("platform_window_created") = bool(), py::arg("draw_data_p") = ImDrawData(), py::arg("draw_data_builder") = ImDrawDataBuilder(), py::arg("last_platform_pos") = ImVec2(), py::arg("last_platform_size") = ImVec2(), py::arg("last_renderer_size") = ImVec2(), py::arg("work_offset_min") = ImVec2(), py::arg("work_offset_max") = ImVec2(), py::arg("build_work_offset_min") = ImVec2(), py::arg("build_work_offset_max") = ImVec2()
        )
        .def_readwrite("idx", &ImGuiViewportP::Idx, "")    // imgui_internal.h:1588
        .def_readwrite("last_frame_active", &ImGuiViewportP::LastFrameActive, "Last frame number this viewport was activated by a window")    // imgui_internal.h:1589
        .def_readwrite("last_front_most_stamp_count", &ImGuiViewportP::LastFrontMostStampCount, "Last stamp number from when a window hosted by this viewport was made front-most (by comparing this value between two viewport we have an implicit viewport z-order")    // imgui_internal.h:1590
        .def_readwrite("last_name_hash", &ImGuiViewportP::LastNameHash, "")    // imgui_internal.h:1591
        .def_readwrite("last_pos", &ImGuiViewportP::LastPos, "")    // imgui_internal.h:1592
        .def_readwrite("alpha", &ImGuiViewportP::Alpha, "Window opacity (when dragging dockable windows/viewports we make them transparent)")    // imgui_internal.h:1593
        .def_readwrite("last_alpha", &ImGuiViewportP::LastAlpha, "")    // imgui_internal.h:1594
        .def_readwrite("platform_monitor", &ImGuiViewportP::PlatformMonitor, "")    // imgui_internal.h:1595
        .def_readwrite("platform_window_created", &ImGuiViewportP::PlatformWindowCreated, "")    // imgui_internal.h:1596
        .def_readwrite("window", &ImGuiViewportP::Window, "Set when the viewport is owned by a window (and ImGuiViewportFlags_CanHostOtherWindows is NOT set)")    // imgui_internal.h:1597
        .def_property("draw_lists_last_frame",    // imgui_internal.h:1598
            [](ImGuiViewportP &self) -> pybind11::array
            {
                auto dtype = pybind11::dtype(pybind11::format_descriptor<int>::format());
                auto base = pybind11::array(dtype, {2}, {sizeof(int)});
                return pybind11::array(dtype, {2}, {sizeof(int)}, self.DrawListsLastFrame, base);
            }, [](ImGuiViewportP& self) {},
            "Last frame number the background (0) and foreground (1) draw lists were used")
        .def_readwrite("draw_data_p", &ImGuiViewportP::DrawDataP, "")    // imgui_internal.h:1600
        .def_readwrite("draw_data_builder", &ImGuiViewportP::DrawDataBuilder, "")    // imgui_internal.h:1601
        .def_readwrite("last_platform_pos", &ImGuiViewportP::LastPlatformPos, "")    // imgui_internal.h:1602
        .def_readwrite("last_platform_size", &ImGuiViewportP::LastPlatformSize, "")    // imgui_internal.h:1603
        .def_readwrite("last_renderer_size", &ImGuiViewportP::LastRendererSize, "")    // imgui_internal.h:1604
        .def_readwrite("work_offset_min", &ImGuiViewportP::WorkOffsetMin, "Work Area: Offset from Pos to top-left corner of Work Area. Generally (0,0) or (0,+main_menu_bar_height). Work Area is Full Area but without menu-bars/status-bars (so WorkArea always fit inside Pos/Size!)")    // imgui_internal.h:1605
        .def_readwrite("work_offset_max", &ImGuiViewportP::WorkOffsetMax, "Work Area: Offset from Pos+Size to bottom-right corner of Work Area. Generally (0,0) or (0,-status_bar_height).")    // imgui_internal.h:1606
        .def_readwrite("build_work_offset_min", &ImGuiViewportP::BuildWorkOffsetMin, "Work Area: Offset being built during current frame. Generally >= 0.0.")    // imgui_internal.h:1607
        .def_readwrite("build_work_offset_max", &ImGuiViewportP::BuildWorkOffsetMax, "Work Area: Offset being built during current frame. Generally <= 0.0.")    // imgui_internal.h:1608
        .def(py::init<>())    // imgui_internal.h:1610
        ;


    auto pyClassImGuiWindowSettings =
        py::class_<ImGuiWindowSettings>    // imgui_internal.h:1632
            (m, "ImGuiWindowSettings", " Windows data saved in imgui.ini file\n Because we never destroy or rename ImGuiWindowSettings, we can store the names in a separate buffer easily.\n (this is designed to be stored in a ImChunkStream buffer, with the variable-length Name following our structure)")
        .def(py::init<>([](
        ImGuiID ID = ImGuiID(), ImVec2ih Pos = ImVec2ih(), ImVec2ih Size = ImVec2ih(), ImVec2ih ViewportPos = ImVec2ih(), ImGuiID ViewportId = ImGuiID(), ImGuiID DockId = ImGuiID(), ImGuiID ClassId = ImGuiID(), short DockOrder = short(), bool Collapsed = bool(), bool WantApply = bool())
        {
            auto r = std::make_unique<ImGuiWindowSettings>();
            r->ID = ID;
            r->Pos = Pos;
            r->Size = Size;
            r->ViewportPos = ViewportPos;
            r->ViewportId = ViewportId;
            r->DockId = DockId;
            r->ClassId = ClassId;
            r->DockOrder = DockOrder;
            r->Collapsed = Collapsed;
            r->WantApply = WantApply;
            return r;
        })
        , py::arg("id") = ImGuiID(), py::arg("pos") = ImVec2ih(), py::arg("size") = ImVec2ih(), py::arg("viewport_pos") = ImVec2ih(), py::arg("viewport_id") = ImGuiID(), py::arg("dock_id") = ImGuiID(), py::arg("class_id") = ImGuiID(), py::arg("dock_order") = short(), py::arg("collapsed") = bool(), py::arg("want_apply") = bool()
        )
        .def_readwrite("id", &ImGuiWindowSettings::ID, "")    // imgui_internal.h:1634
        .def_readwrite("pos", &ImGuiWindowSettings::Pos, "NB: Settings position are stored RELATIVE to the viewport! Whereas runtime ones are absolute positions.")    // imgui_internal.h:1635
        .def_readwrite("size", &ImGuiWindowSettings::Size, "")    // imgui_internal.h:1636
        .def_readwrite("viewport_pos", &ImGuiWindowSettings::ViewportPos, "")    // imgui_internal.h:1637
        .def_readwrite("viewport_id", &ImGuiWindowSettings::ViewportId, "")    // imgui_internal.h:1638
        .def_readwrite("dock_id", &ImGuiWindowSettings::DockId, "ID of last known DockNode (even if the DockNode is invisible because it has only 1 active window), or 0 if none.")    // imgui_internal.h:1639
        .def_readwrite("class_id", &ImGuiWindowSettings::ClassId, "ID of window class if specified")    // imgui_internal.h:1640
        .def_readwrite("dock_order", &ImGuiWindowSettings::DockOrder, "Order of the last time the window was visible within its DockNode. This is used to reorder windows that are reappearing on the same frame. Same value between windows that were active and windows that were none are possible.")    // imgui_internal.h:1641
        .def_readwrite("collapsed", &ImGuiWindowSettings::Collapsed, "")    // imgui_internal.h:1642
        .def_readwrite("want_apply", &ImGuiWindowSettings::WantApply, "Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)")    // imgui_internal.h:1643
        .def(py::init<>())    // imgui_internal.h:1645
        ;


    auto pyClassImGuiSettingsHandler =
        py::class_<ImGuiSettingsHandler>    // imgui_internal.h:1649
            (m, "ImGuiSettingsHandler", "")
        .def(py::init<>([](
        ImGuiID TypeHash = ImGuiID())
        {
            auto r = std::make_unique<ImGuiSettingsHandler>();
            r->TypeHash = TypeHash;
            return r;
        })
        , py::arg("type_hash") = ImGuiID()
        )
        .def_readonly("type_name", &ImGuiSettingsHandler::TypeName, "Short description stored in .ini file. Disallowed characters: '[' ']'")    // imgui_internal.h:1651
        .def_readwrite("type_hash", &ImGuiSettingsHandler::TypeHash, "== ImHashStr(TypeName)")    // imgui_internal.h:1652
        .def_readwrite("user_data", &ImGuiSettingsHandler::UserData, "")    // imgui_internal.h:1659
        .def(py::init<>())    // imgui_internal.h:1661
        ;


    py::enum_<ImGuiDebugLogFlags_>(m, "ImGuiDebugLogFlags_", py::arithmetic(), "")    // imgui_internal.h:1668
        .value("none", ImGuiDebugLogFlags_None, "")
        .value("event_active_id", ImGuiDebugLogFlags_EventActiveId, "")
        .value("event_focus", ImGuiDebugLogFlags_EventFocus, "")
        .value("event_popup", ImGuiDebugLogFlags_EventPopup, "")
        .value("event_nav", ImGuiDebugLogFlags_EventNav, "")
        .value("event_io", ImGuiDebugLogFlags_EventIO, "")
        .value("event_docking", ImGuiDebugLogFlags_EventDocking, "")
        .value("event_viewport", ImGuiDebugLogFlags_EventViewport, "")
        .value("event_mask_", ImGuiDebugLogFlags_EventMask_, "")
        .value("output_to_tty", ImGuiDebugLogFlags_OutputToTTY, "Also send output to TTY");


    auto pyClassImGuiMetricsConfig =
        py::class_<ImGuiMetricsConfig>    // imgui_internal.h:1683
            (m, "ImGuiMetricsConfig", "")
        .def(py::init<>([](
        bool ShowDebugLog = bool(), bool ShowStackTool = bool(), bool ShowWindowsRects = bool(), bool ShowWindowsBeginOrder = bool(), bool ShowTablesRects = bool(), bool ShowDrawCmdMesh = bool(), bool ShowDrawCmdBoundingBoxes = bool(), bool ShowDockingNodes = bool(), int ShowWindowsRectsType = int(), int ShowTablesRectsType = int())
        {
            auto r = std::make_unique<ImGuiMetricsConfig>();
            r->ShowDebugLog = ShowDebugLog;
            r->ShowStackTool = ShowStackTool;
            r->ShowWindowsRects = ShowWindowsRects;
            r->ShowWindowsBeginOrder = ShowWindowsBeginOrder;
            r->ShowTablesRects = ShowTablesRects;
            r->ShowDrawCmdMesh = ShowDrawCmdMesh;
            r->ShowDrawCmdBoundingBoxes = ShowDrawCmdBoundingBoxes;
            r->ShowDockingNodes = ShowDockingNodes;
            r->ShowWindowsRectsType = ShowWindowsRectsType;
            r->ShowTablesRectsType = ShowTablesRectsType;
            return r;
        })
        , py::arg("show_debug_log") = bool(), py::arg("show_stack_tool") = bool(), py::arg("show_windows_rects") = bool(), py::arg("show_windows_begin_order") = bool(), py::arg("show_tables_rects") = bool(), py::arg("show_draw_cmd_mesh") = bool(), py::arg("show_draw_cmd_bounding_boxes") = bool(), py::arg("show_docking_nodes") = bool(), py::arg("show_windows_rects_type") = int(), py::arg("show_tables_rects_type") = int()
        )
        .def_readwrite("show_debug_log", &ImGuiMetricsConfig::ShowDebugLog, "")    // imgui_internal.h:1685
        .def_readwrite("show_stack_tool", &ImGuiMetricsConfig::ShowStackTool, "")    // imgui_internal.h:1686
        .def_readwrite("show_windows_rects", &ImGuiMetricsConfig::ShowWindowsRects, "")    // imgui_internal.h:1687
        .def_readwrite("show_windows_begin_order", &ImGuiMetricsConfig::ShowWindowsBeginOrder, "")    // imgui_internal.h:1688
        .def_readwrite("show_tables_rects", &ImGuiMetricsConfig::ShowTablesRects, "")    // imgui_internal.h:1689
        .def_readwrite("show_draw_cmd_mesh", &ImGuiMetricsConfig::ShowDrawCmdMesh, "")    // imgui_internal.h:1690
        .def_readwrite("show_draw_cmd_bounding_boxes", &ImGuiMetricsConfig::ShowDrawCmdBoundingBoxes, "")    // imgui_internal.h:1691
        .def_readwrite("show_docking_nodes", &ImGuiMetricsConfig::ShowDockingNodes, "")    // imgui_internal.h:1692
        .def_readwrite("show_windows_rects_type", &ImGuiMetricsConfig::ShowWindowsRectsType, "")    // imgui_internal.h:1693
        .def_readwrite("show_tables_rects_type", &ImGuiMetricsConfig::ShowTablesRectsType, "")    // imgui_internal.h:1694
        .def(py::init<>())    // imgui_internal.h:1696
        ;


    auto pyClassImGuiStackLevelInfo =
        py::class_<ImGuiStackLevelInfo>    // imgui_internal.h:1706
            (m, "ImGuiStackLevelInfo", "")
        .def(py::init<>([](
        ImGuiID ID = ImGuiID(), ImS8 QueryFrameCount = ImS8(), bool QuerySuccess = bool())
        {
            auto r = std::make_unique<ImGuiStackLevelInfo>();
            r->ID = ID;
            r->QueryFrameCount = QueryFrameCount;
            r->QuerySuccess = QuerySuccess;
            return r;
        })
        , py::arg("id") = ImGuiID(), py::arg("query_frame_count") = ImS8(), py::arg("query_success") = bool()
        )
        .def_readwrite("id", &ImGuiStackLevelInfo::ID, "")    // imgui_internal.h:1708
        .def_readwrite("query_frame_count", &ImGuiStackLevelInfo::QueryFrameCount, ">= 1: Query in progress")    // imgui_internal.h:1709
        .def_readwrite("query_success", &ImGuiStackLevelInfo::QuerySuccess, "Obtained result from DebugHookIdInfo()")    // imgui_internal.h:1710
        .def(py::init<>())    // imgui_internal.h:1714
        ;


    auto pyClassImGuiStackTool =
        py::class_<ImGuiStackTool>    // imgui_internal.h:1718
            (m, "ImGuiStackTool", "State for Stack tool queries")
        .def(py::init<>([](
        int LastActiveFrame = int(), int StackLevel = int(), ImGuiID QueryId = ImGuiID(), bool CopyToClipboardOnCtrlC = bool(), float CopyToClipboardLastTime = float())
        {
            auto r = std::make_unique<ImGuiStackTool>();
            r->LastActiveFrame = LastActiveFrame;
            r->StackLevel = StackLevel;
            r->QueryId = QueryId;
            r->CopyToClipboardOnCtrlC = CopyToClipboardOnCtrlC;
            r->CopyToClipboardLastTime = CopyToClipboardLastTime;
            return r;
        })
        , py::arg("last_active_frame") = int(), py::arg("stack_level") = int(), py::arg("query_id") = ImGuiID(), py::arg("copy_to_clipboard_on_ctrl_c") = bool(), py::arg("copy_to_clipboard_last_time") = float()
        )
        .def_readwrite("last_active_frame", &ImGuiStackTool::LastActiveFrame, "")    // imgui_internal.h:1720
        .def_readwrite("stack_level", &ImGuiStackTool::StackLevel, "-1: query stack and resize Results, >= 0: individual stack level")    // imgui_internal.h:1721
        .def_readwrite("query_id", &ImGuiStackTool::QueryId, "ID to query details for")    // imgui_internal.h:1722
        .def_readwrite("copy_to_clipboard_on_ctrl_c", &ImGuiStackTool::CopyToClipboardOnCtrlC, "")    // imgui_internal.h:1724
        .def_readwrite("copy_to_clipboard_last_time", &ImGuiStackTool::CopyToClipboardLastTime, "")    // imgui_internal.h:1725
        .def(py::init<>())    // imgui_internal.h:1727
        ;


    py::enum_<ImGuiContextHookType>(m, "ImGuiContextHookType", py::arithmetic(), "")    // imgui_internal.h:1735
        .value("new_frame_pre", ImGuiContextHookType_NewFramePre, "")
        .value("new_frame_post", ImGuiContextHookType_NewFramePost, "")
        .value("end_frame_pre", ImGuiContextHookType_EndFramePre, "")
        .value("end_frame_post", ImGuiContextHookType_EndFramePost, "")
        .value("render_pre", ImGuiContextHookType_RenderPre, "")
        .value("render_post", ImGuiContextHookType_RenderPost, "")
        .value("shutdown", ImGuiContextHookType_Shutdown, "")
        .value("pending_removal_", ImGuiContextHookType_PendingRemoval_, "");


    auto pyClassImGuiContextHook =
        py::class_<ImGuiContextHook>    // imgui_internal.h:1737
            (m, "ImGuiContextHook", "")
        .def(py::init<>([](
        ImGuiID HookId = ImGuiID(), ImGuiContextHookType Type = ImGuiContextHookType(), ImGuiID Owner = ImGuiID())
        {
            auto r = std::make_unique<ImGuiContextHook>();
            r->HookId = HookId;
            r->Type = Type;
            r->Owner = Owner;
            return r;
        })
        , py::arg("hook_id") = ImGuiID(), py::arg("type") = ImGuiContextHookType(), py::arg("owner") = ImGuiID()
        )
        .def_readwrite("hook_id", &ImGuiContextHook::HookId, "A unique ID assigned by AddContextHook()")    // imgui_internal.h:1739
        .def_readwrite("type", &ImGuiContextHook::Type, "")    // imgui_internal.h:1740
        .def_readwrite("owner", &ImGuiContextHook::Owner, "")    // imgui_internal.h:1741
        .def_readwrite("user_data", &ImGuiContextHook::UserData, "")    // imgui_internal.h:1743
        .def(py::init<>())    // imgui_internal.h:1745
        ;


    auto pyClassImGuiContext =
        py::class_<ImGuiContext>    // imgui_internal.h:1752
            (m, "ImGuiContext", "")
        .def_readwrite("initialized", &ImGuiContext::Initialized, "")    // imgui_internal.h:1754
        .def_readwrite("font_atlas_owned_by_context", &ImGuiContext::FontAtlasOwnedByContext, "IO.Fonts-> is owned by the ImGuiContext and will be destructed along with it.")    // imgui_internal.h:1755
        .def_readwrite("io", &ImGuiContext::IO, "")    // imgui_internal.h:1756
        .def_readwrite("platform_io", &ImGuiContext::PlatformIO, "")    // imgui_internal.h:1757
        .def_readwrite("style", &ImGuiContext::Style, "")    // imgui_internal.h:1760
        .def_readwrite("config_flags_curr_frame", &ImGuiContext::ConfigFlagsCurrFrame, "= g.IO.ConfigFlags at the time of NewFrame()")    // imgui_internal.h:1761
        .def_readwrite("config_flags_last_frame", &ImGuiContext::ConfigFlagsLastFrame, "")    // imgui_internal.h:1762
        .def_readwrite("font", &ImGuiContext::Font, "(Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()")    // imgui_internal.h:1763
        .def_readwrite("font_size", &ImGuiContext::FontSize, "(Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.")    // imgui_internal.h:1764
        .def_readwrite("font_base_size", &ImGuiContext::FontBaseSize, "(Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.")    // imgui_internal.h:1765
        .def_readwrite("draw_list_shared_data", &ImGuiContext::DrawListSharedData, "")    // imgui_internal.h:1766
        .def_readwrite("time", &ImGuiContext::Time, "")    // imgui_internal.h:1767
        .def_readwrite("frame_count", &ImGuiContext::FrameCount, "")    // imgui_internal.h:1768
        .def_readwrite("frame_count_ended", &ImGuiContext::FrameCountEnded, "")    // imgui_internal.h:1769
        .def_readwrite("frame_count_platform_ended", &ImGuiContext::FrameCountPlatformEnded, "")    // imgui_internal.h:1770
        .def_readwrite("frame_count_rendered", &ImGuiContext::FrameCountRendered, "")    // imgui_internal.h:1771
        .def_readwrite("within_frame_scope", &ImGuiContext::WithinFrameScope, "Set by NewFrame(), cleared by EndFrame()")    // imgui_internal.h:1772
        .def_readwrite("within_frame_scope_with_implicit_window", &ImGuiContext::WithinFrameScopeWithImplicitWindow, "Set by NewFrame(), cleared by EndFrame() when the implicit debug window has been pushed")    // imgui_internal.h:1773
        .def_readwrite("within_end_child", &ImGuiContext::WithinEndChild, "Set within EndChild()")    // imgui_internal.h:1774
        .def_readwrite("gc_compact_all", &ImGuiContext::GcCompactAll, "Request full GC")    // imgui_internal.h:1775
        .def_readwrite("test_engine_hook_items", &ImGuiContext::TestEngineHookItems, "Will call test engine hooks: ImGuiTestEngineHook_ItemAdd(), ImGuiTestEngineHook_ItemInfo(), ImGuiTestEngineHook_Log()")    // imgui_internal.h:1776
        .def_readwrite("test_engine", &ImGuiContext::TestEngine, "Test engine user data")    // imgui_internal.h:1777
        .def_readwrite("windows_by_id", &ImGuiContext::WindowsById, "Map window's ImGuiID to ImGuiWindow*")    // imgui_internal.h:1784
        .def_readwrite("windows_active_count", &ImGuiContext::WindowsActiveCount, "Number of unique windows submitted by frame")    // imgui_internal.h:1785
        .def_readwrite("windows_hover_padding", &ImGuiContext::WindowsHoverPadding, "Padding around resizable windows for which hovering on counts as hovering the window == ImMax(style.TouchExtraPadding, WINDOWS_HOVER_PADDING)")    // imgui_internal.h:1786
        .def_readwrite("current_window", &ImGuiContext::CurrentWindow, "Window being drawn into")    // imgui_internal.h:1787
        .def_readwrite("hovered_window", &ImGuiContext::HoveredWindow, "Window the mouse is hovering. Will typically catch mouse inputs.")    // imgui_internal.h:1788
        .def_readwrite("hovered_window_under_moving_window", &ImGuiContext::HoveredWindowUnderMovingWindow, "Hovered window ignoring MovingWindow. Only set if MovingWindow is set.")    // imgui_internal.h:1789
        .def_readwrite("hovered_dock_node", &ImGuiContext::HoveredDockNode, "[Debug] Hovered dock node.")    // imgui_internal.h:1790
        .def_readwrite("moving_window", &ImGuiContext::MovingWindow, "Track the window we clicked on (in order to preserve focus). The actual window that is moved is generally MovingWindow->RootWindowDockTree.")    // imgui_internal.h:1791
        .def_readwrite("wheeling_window", &ImGuiContext::WheelingWindow, "Track the window we started mouse-wheeling on. Until a timer elapse or mouse has moved, generally keep scrolling the same window even if during the course of scrolling the mouse ends up hovering a child window.")    // imgui_internal.h:1792
        .def_readwrite("wheeling_window_ref_mouse_pos", &ImGuiContext::WheelingWindowRefMousePos, "")    // imgui_internal.h:1793
        .def_readwrite("wheeling_window_timer", &ImGuiContext::WheelingWindowTimer, "")    // imgui_internal.h:1794
        .def_readwrite("debug_hook_id_info", &ImGuiContext::DebugHookIdInfo, "Will call core hooks: DebugHookIdInfo() from GetID functions, used by Stack Tool [next HoveredId/ActiveId to not pull in an extra cache-line]")    // imgui_internal.h:1797
        .def_readwrite("hovered_id", &ImGuiContext::HoveredId, "Hovered widget, filled during the frame")    // imgui_internal.h:1798
        .def_readwrite("hovered_id_previous_frame", &ImGuiContext::HoveredIdPreviousFrame, "")    // imgui_internal.h:1799
        .def_readwrite("hovered_id_allow_overlap", &ImGuiContext::HoveredIdAllowOverlap, "")    // imgui_internal.h:1800
        .def_readwrite("hovered_id_using_mouse_wheel", &ImGuiContext::HoveredIdUsingMouseWheel, "Hovered widget will use mouse wheel. Blocks scrolling the underlying window.")    // imgui_internal.h:1801
        .def_readwrite("hovered_id_previous_frame_using_mouse_wheel", &ImGuiContext::HoveredIdPreviousFrameUsingMouseWheel, "")    // imgui_internal.h:1802
        .def_readwrite("hovered_id_disabled", &ImGuiContext::HoveredIdDisabled, "At least one widget passed the rect test, but has been discarded by disabled flag or popup inhibit. May be True even if HoveredId == 0.")    // imgui_internal.h:1803
        .def_readwrite("hovered_id_timer", &ImGuiContext::HoveredIdTimer, "Measure contiguous hovering time")    // imgui_internal.h:1804
        .def_readwrite("hovered_id_not_active_timer", &ImGuiContext::HoveredIdNotActiveTimer, "Measure contiguous hovering time where the item has not been active")    // imgui_internal.h:1805
        .def_readwrite("active_id", &ImGuiContext::ActiveId, "Active widget")    // imgui_internal.h:1806
        .def_readwrite("active_id_is_alive", &ImGuiContext::ActiveIdIsAlive, "Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)")    // imgui_internal.h:1807
        .def_readwrite("active_id_timer", &ImGuiContext::ActiveIdTimer, "")    // imgui_internal.h:1808
        .def_readwrite("active_id_is_just_activated", &ImGuiContext::ActiveIdIsJustActivated, "Set at the time of activation for one frame")    // imgui_internal.h:1809
        .def_readwrite("active_id_allow_overlap", &ImGuiContext::ActiveIdAllowOverlap, "Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)")    // imgui_internal.h:1810
        .def_readwrite("active_id_no_clear_on_focus_loss", &ImGuiContext::ActiveIdNoClearOnFocusLoss, "Disable losing active id if the active id window gets unfocused.")    // imgui_internal.h:1811
        .def_readwrite("active_id_has_been_pressed_before", &ImGuiContext::ActiveIdHasBeenPressedBefore, "Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.")    // imgui_internal.h:1812
        .def_readwrite("active_id_has_been_edited_before", &ImGuiContext::ActiveIdHasBeenEditedBefore, "Was the value associated to the widget Edited over the course of the Active state.")    // imgui_internal.h:1813
        .def_readwrite("active_id_has_been_edited_this_frame", &ImGuiContext::ActiveIdHasBeenEditedThisFrame, "")    // imgui_internal.h:1814
        .def_readwrite("active_id_click_offset", &ImGuiContext::ActiveIdClickOffset, "Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)")    // imgui_internal.h:1815
        .def_readwrite("active_id_window", &ImGuiContext::ActiveIdWindow, "")    // imgui_internal.h:1816
        .def_readwrite("active_id_source", &ImGuiContext::ActiveIdSource, "Activating with mouse or nav (gamepad/keyboard)")    // imgui_internal.h:1817
        .def_readwrite("active_id_mouse_button", &ImGuiContext::ActiveIdMouseButton, "")    // imgui_internal.h:1818
        .def_readwrite("active_id_previous_frame", &ImGuiContext::ActiveIdPreviousFrame, "")    // imgui_internal.h:1819
        .def_readwrite("active_id_previous_frame_is_alive", &ImGuiContext::ActiveIdPreviousFrameIsAlive, "")    // imgui_internal.h:1820
        .def_readwrite("active_id_previous_frame_has_been_edited_before", &ImGuiContext::ActiveIdPreviousFrameHasBeenEditedBefore, "")    // imgui_internal.h:1821
        .def_readwrite("active_id_previous_frame_window", &ImGuiContext::ActiveIdPreviousFrameWindow, "")    // imgui_internal.h:1822
        .def_readwrite("last_active_id", &ImGuiContext::LastActiveId, "Store the last non-zero ActiveId, useful for animation.")    // imgui_internal.h:1823
        .def_readwrite("last_active_id_timer", &ImGuiContext::LastActiveIdTimer, "Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.")    // imgui_internal.h:1824
        .def_readwrite("active_id_using_mouse_wheel", &ImGuiContext::ActiveIdUsingMouseWheel, "Active widget will want to read mouse wheel. Blocks scrolling the underlying window.")    // imgui_internal.h:1827
        .def_readwrite("active_id_using_nav_dir_mask", &ImGuiContext::ActiveIdUsingNavDirMask, "Active widget will want to read those nav move requests (e.g. can activate a button and move away from it)")    // imgui_internal.h:1828
        .def_readwrite("active_id_using_nav_input_mask", &ImGuiContext::ActiveIdUsingNavInputMask, "Active widget will want to read those nav inputs.")    // imgui_internal.h:1829
        .def_readwrite("current_item_flags", &ImGuiContext::CurrentItemFlags, "== g.ItemFlagsStack.back()")    // imgui_internal.h:1833
        .def_readwrite("next_item_data", &ImGuiContext::NextItemData, "Storage for SetNextItem** functions")    // imgui_internal.h:1834
        .def_readwrite("last_item_data", &ImGuiContext::LastItemData, "Storage for last submitted item (setup by ItemAdd)")    // imgui_internal.h:1835
        .def_readwrite("next_window_data", &ImGuiContext::NextWindowData, "Storage for SetNextWindow** functions")    // imgui_internal.h:1836
        .def_readwrite("begin_menu_count", &ImGuiContext::BeginMenuCount, "")    // imgui_internal.h:1847
        .def_readwrite("current_dpi_scale", &ImGuiContext::CurrentDpiScale, "== CurrentViewport->DpiScale")    // imgui_internal.h:1851
        .def_readwrite("current_viewport", &ImGuiContext::CurrentViewport, "We track changes of viewport (happening in Begin) so we can call Platform_OnChangedViewport()")    // imgui_internal.h:1852
        .def_readwrite("mouse_viewport", &ImGuiContext::MouseViewport, "")    // imgui_internal.h:1853
        .def_readwrite("mouse_last_hovered_viewport", &ImGuiContext::MouseLastHoveredViewport, "Last known viewport that was hovered by mouse (even if we are not hovering any viewport any more) + honoring the _NoInputs flag.")    // imgui_internal.h:1854
        .def_readwrite("platform_last_focused_viewport_id", &ImGuiContext::PlatformLastFocusedViewportId, "")    // imgui_internal.h:1855
        .def_readwrite("fallback_monitor", &ImGuiContext::FallbackMonitor, "Virtual monitor used as fallback if backend doesn't provide monitor information.")    // imgui_internal.h:1856
        .def_readwrite("viewport_front_most_stamp_count", &ImGuiContext::ViewportFrontMostStampCount, "Every time the front-most window changes, we stamp its viewport with an incrementing counter")    // imgui_internal.h:1857
        .def_readwrite("nav_window", &ImGuiContext::NavWindow, "Focused window for navigation. Could be called 'FocusedWindow'")    // imgui_internal.h:1860
        .def_readwrite("nav_id", &ImGuiContext::NavId, "Focused item for navigation")    // imgui_internal.h:1861
        .def_readwrite("nav_focus_scope_id", &ImGuiContext::NavFocusScopeId, "Identify a selection scope (selection code often wants to \"clear other items\" when landing on an item of the selection set)")    // imgui_internal.h:1862
        .def_readwrite("nav_activate_id", &ImGuiContext::NavActivateId, "~~ (g.ActiveId == 0) && IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0, also set when calling ActivateItem()")    // imgui_internal.h:1863
        .def_readwrite("nav_activate_down_id", &ImGuiContext::NavActivateDownId, "~~ IsNavInputDown(ImGuiNavInput_Activate) ? NavId : 0")    // imgui_internal.h:1864
        .def_readwrite("nav_activate_pressed_id", &ImGuiContext::NavActivatePressedId, "~~ IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0")    // imgui_internal.h:1865
        .def_readwrite("nav_activate_input_id", &ImGuiContext::NavActivateInputId, "~~ IsNavInputPressed(ImGuiNavInput_Input) ? NavId : 0; ImGuiActivateFlags_PreferInput will be set and NavActivateId will be 0.")    // imgui_internal.h:1866
        .def_readwrite("nav_activate_flags", &ImGuiContext::NavActivateFlags, "")    // imgui_internal.h:1867
        .def_readwrite("nav_just_moved_to_id", &ImGuiContext::NavJustMovedToId, "Just navigated to this id (result of a successfully MoveRequest).")    // imgui_internal.h:1868
        .def_readwrite("nav_just_moved_to_focus_scope_id", &ImGuiContext::NavJustMovedToFocusScopeId, "Just navigated to this focus scope id (result of a successfully MoveRequest).")    // imgui_internal.h:1869
        .def_readwrite("nav_just_moved_to_key_mods", &ImGuiContext::NavJustMovedToKeyMods, "")    // imgui_internal.h:1870
        .def_readwrite("nav_next_activate_id", &ImGuiContext::NavNextActivateId, "Set by ActivateItem(), queued until next frame.")    // imgui_internal.h:1871
        .def_readwrite("nav_next_activate_flags", &ImGuiContext::NavNextActivateFlags, "")    // imgui_internal.h:1872
        .def_readwrite("nav_input_source", &ImGuiContext::NavInputSource, "Keyboard or Gamepad mode? THIS WILL ONLY BE None or NavGamepad or NavKeyboard.")    // imgui_internal.h:1873
        .def_readwrite("nav_layer", &ImGuiContext::NavLayer, "Layer we are navigating on. For now the system is hard-coded for 0=main contents and 1=menu/title bar, may expose layers later.")    // imgui_internal.h:1874
        .def_readwrite("nav_id_is_alive", &ImGuiContext::NavIdIsAlive, "Nav widget has been seen this frame ~~ NavRectRel is valid")    // imgui_internal.h:1875
        .def_readwrite("nav_mouse_pos_dirty", &ImGuiContext::NavMousePosDirty, "When set we will update mouse position if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)")    // imgui_internal.h:1876
        .def_readwrite("nav_disable_highlight", &ImGuiContext::NavDisableHighlight, "When user starts using mouse, we hide gamepad/keyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)")    // imgui_internal.h:1877
        .def_readwrite("nav_disable_mouse_hover", &ImGuiContext::NavDisableMouseHover, "When user starts using gamepad/keyboard, we hide mouse hovering highlight until mouse is touched again.")    // imgui_internal.h:1878
        .def_readwrite("nav_any_request", &ImGuiContext::NavAnyRequest, "~~ NavMoveRequest || NavInitRequest this is to perform early out in ItemAdd()")    // imgui_internal.h:1881
        .def_readwrite("nav_init_request", &ImGuiContext::NavInitRequest, "Init request for appearing window to select first item")    // imgui_internal.h:1882
        .def_readwrite("nav_init_request_from_move", &ImGuiContext::NavInitRequestFromMove, "")    // imgui_internal.h:1883
        .def_readwrite("nav_init_result_id", &ImGuiContext::NavInitResultId, "Init request result (first item of the window, or one for which SetItemDefaultFocus() was called)")    // imgui_internal.h:1884
        .def_readwrite("nav_init_result_rect_rel", &ImGuiContext::NavInitResultRectRel, "Init request result rectangle (relative to parent window)")    // imgui_internal.h:1885
        .def_readwrite("nav_move_submitted", &ImGuiContext::NavMoveSubmitted, "Move request submitted, will process result on next NewFrame()")    // imgui_internal.h:1886
        .def_readwrite("nav_move_scoring_items", &ImGuiContext::NavMoveScoringItems, "Move request submitted, still scoring incoming items")    // imgui_internal.h:1887
        .def_readwrite("nav_move_forward_to_next_frame", &ImGuiContext::NavMoveForwardToNextFrame, "")    // imgui_internal.h:1888
        .def_readwrite("nav_move_flags", &ImGuiContext::NavMoveFlags, "")    // imgui_internal.h:1889
        .def_readwrite("nav_move_scroll_flags", &ImGuiContext::NavMoveScrollFlags, "")    // imgui_internal.h:1890
        .def_readwrite("nav_move_key_mods", &ImGuiContext::NavMoveKeyMods, "")    // imgui_internal.h:1891
        .def_readwrite("nav_move_dir", &ImGuiContext::NavMoveDir, "Direction of the move request (left/right/up/down)")    // imgui_internal.h:1892
        .def_readwrite("nav_move_dir_for_debug", &ImGuiContext::NavMoveDirForDebug, "")    // imgui_internal.h:1893
        .def_readwrite("nav_move_clip_dir", &ImGuiContext::NavMoveClipDir, "FIXME-NAV: Describe the purpose of this better. Might want to rename?")    // imgui_internal.h:1894
        .def_readwrite("nav_scoring_rect", &ImGuiContext::NavScoringRect, "Rectangle used for scoring, in screen space. Based of window->NavRectRel[], modified for directional navigation scoring.")    // imgui_internal.h:1895
        .def_readwrite("nav_scoring_no_clip_rect", &ImGuiContext::NavScoringNoClipRect, "Some nav operations (such as PageUp/PageDown) enforce a region which clipper will attempt to always keep submitted")    // imgui_internal.h:1896
        .def_readwrite("nav_scoring_debug_count", &ImGuiContext::NavScoringDebugCount, "Metrics for debugging")    // imgui_internal.h:1897
        .def_readwrite("nav_tabbing_dir", &ImGuiContext::NavTabbingDir, "Generally -1 or +1, 0 when tabbing without a nav id")    // imgui_internal.h:1898
        .def_readwrite("nav_tabbing_counter", &ImGuiContext::NavTabbingCounter, ">0 when counting items for tabbing")    // imgui_internal.h:1899
        .def_readwrite("nav_move_result_local", &ImGuiContext::NavMoveResultLocal, "Best move request candidate within NavWindow")    // imgui_internal.h:1900
        .def_readwrite("nav_move_result_local_visible", &ImGuiContext::NavMoveResultLocalVisible, "Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)")    // imgui_internal.h:1901
        .def_readwrite("nav_move_result_other", &ImGuiContext::NavMoveResultOther, "Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)")    // imgui_internal.h:1902
        .def_readwrite("nav_tabbing_result_first", &ImGuiContext::NavTabbingResultFirst, "First tabbing request candidate within NavWindow and flattened hierarchy")    // imgui_internal.h:1903
        .def_readwrite("nav_windowing_target", &ImGuiContext::NavWindowingTarget, "Target window when doing CTRL+Tab (or Pad Menu + FocusPrev/Next), this window is temporarily displayed top-most!")    // imgui_internal.h:1906
        .def_readwrite("nav_windowing_target_anim", &ImGuiContext::NavWindowingTargetAnim, "Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0, so the fade-out can stay on it.")    // imgui_internal.h:1907
        .def_readwrite("nav_windowing_list_window", &ImGuiContext::NavWindowingListWindow, "Internal window actually listing the CTRL+Tab contents")    // imgui_internal.h:1908
        .def_readwrite("nav_windowing_timer", &ImGuiContext::NavWindowingTimer, "")    // imgui_internal.h:1909
        .def_readwrite("nav_windowing_highlight_alpha", &ImGuiContext::NavWindowingHighlightAlpha, "")    // imgui_internal.h:1910
        .def_readwrite("nav_windowing_toggle_layer", &ImGuiContext::NavWindowingToggleLayer, "")    // imgui_internal.h:1911
        .def_readwrite("dim_bg_ratio", &ImGuiContext::DimBgRatio, "0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)")    // imgui_internal.h:1914
        .def_readwrite("mouse_cursor", &ImGuiContext::MouseCursor, "")    // imgui_internal.h:1915
        .def_readwrite("drag_drop_active", &ImGuiContext::DragDropActive, "")    // imgui_internal.h:1918
        .def_readwrite("drag_drop_within_source", &ImGuiContext::DragDropWithinSource, "Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag source.")    // imgui_internal.h:1919
        .def_readwrite("drag_drop_within_target", &ImGuiContext::DragDropWithinTarget, "Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag target.")    // imgui_internal.h:1920
        .def_readwrite("drag_drop_source_flags", &ImGuiContext::DragDropSourceFlags, "")    // imgui_internal.h:1921
        .def_readwrite("drag_drop_source_frame_count", &ImGuiContext::DragDropSourceFrameCount, "")    // imgui_internal.h:1922
        .def_readwrite("drag_drop_mouse_button", &ImGuiContext::DragDropMouseButton, "")    // imgui_internal.h:1923
        .def_readwrite("drag_drop_payload", &ImGuiContext::DragDropPayload, "")    // imgui_internal.h:1924
        .def_readwrite("drag_drop_target_rect", &ImGuiContext::DragDropTargetRect, "Store rectangle of current target candidate (we favor small targets when overlapping)")    // imgui_internal.h:1925
        .def_readwrite("drag_drop_target_id", &ImGuiContext::DragDropTargetId, "")    // imgui_internal.h:1926
        .def_readwrite("drag_drop_accept_flags", &ImGuiContext::DragDropAcceptFlags, "")    // imgui_internal.h:1927
        .def_readwrite("drag_drop_accept_id_curr_rect_surface", &ImGuiContext::DragDropAcceptIdCurrRectSurface, "Target item surface (we resolve overlapping targets by prioritizing the smaller surface)")    // imgui_internal.h:1928
        .def_readwrite("drag_drop_accept_id_curr", &ImGuiContext::DragDropAcceptIdCurr, "Target item id (set at the time of accepting the payload)")    // imgui_internal.h:1929
        .def_readwrite("drag_drop_accept_id_prev", &ImGuiContext::DragDropAcceptIdPrev, "Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)")    // imgui_internal.h:1930
        .def_readwrite("drag_drop_accept_frame_count", &ImGuiContext::DragDropAcceptFrameCount, "Last time a target expressed a desire to accept the source")    // imgui_internal.h:1931
        .def_readwrite("drag_drop_hold_just_pressed_id", &ImGuiContext::DragDropHoldJustPressedId, "Set when holding a payload just made ButtonBehavior() return a press.")    // imgui_internal.h:1932
        .def_readwrite("clipper_temp_data_stacked", &ImGuiContext::ClipperTempDataStacked, "")    // imgui_internal.h:1937
        .def_readwrite("current_table", &ImGuiContext::CurrentTable, "")    // imgui_internal.h:1941
        .def_readwrite("tables_temp_data_stacked", &ImGuiContext::TablesTempDataStacked, "Temporary table data size (because we leave previous instances undestructed, we generally don't use TablesTempData.Size)")    // imgui_internal.h:1942
        .def_readwrite("current_tab_bar", &ImGuiContext::CurrentTabBar, "")    // imgui_internal.h:1949
        .def_readwrite("mouse_last_valid_pos", &ImGuiContext::MouseLastValidPos, "")    // imgui_internal.h:1955
        .def_readwrite("input_text_state", &ImGuiContext::InputTextState, "")    // imgui_internal.h:1956
        .def_readwrite("input_text_password_font", &ImGuiContext::InputTextPasswordFont, "")    // imgui_internal.h:1957
        .def_readwrite("temp_input_id", &ImGuiContext::TempInputId, "Temporary text input when CTRL+clicking on a slider, etc.")    // imgui_internal.h:1958
        .def_readwrite("color_edit_options", &ImGuiContext::ColorEditOptions, "Store user options for color edit widgets")    // imgui_internal.h:1959
        .def_readwrite("color_edit_last_hue", &ImGuiContext::ColorEditLastHue, "Backup of last Hue associated to LastColor, so we can restore Hue in lossy RGB<>HSV round trips")    // imgui_internal.h:1960
        .def_readwrite("color_edit_last_sat", &ImGuiContext::ColorEditLastSat, "Backup of last Saturation associated to LastColor, so we can restore Saturation in lossy RGB<>HSV round trips")    // imgui_internal.h:1961
        .def_readwrite("color_edit_last_color", &ImGuiContext::ColorEditLastColor, "RGB value with alpha set to 0.")    // imgui_internal.h:1962
        .def_readwrite("color_picker_ref", &ImGuiContext::ColorPickerRef, "Initial/reference color at the time of opening the color picker.")    // imgui_internal.h:1963
        .def_readwrite("combo_preview_data", &ImGuiContext::ComboPreviewData, "")    // imgui_internal.h:1964
        .def_readwrite("slider_grab_click_offset", &ImGuiContext::SliderGrabClickOffset, "")    // imgui_internal.h:1965
        .def_readwrite("slider_current_accum", &ImGuiContext::SliderCurrentAccum, "Accumulated slider delta when using navigation controls.")    // imgui_internal.h:1966
        .def_readwrite("slider_current_accum_dirty", &ImGuiContext::SliderCurrentAccumDirty, "Has the accumulated slider delta changed since last time we tried to apply it?")    // imgui_internal.h:1967
        .def_readwrite("drag_current_accum_dirty", &ImGuiContext::DragCurrentAccumDirty, "")    // imgui_internal.h:1968
        .def_readwrite("drag_current_accum", &ImGuiContext::DragCurrentAccum, "Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings")    // imgui_internal.h:1969
        .def_readwrite("drag_speed_default_ratio", &ImGuiContext::DragSpeedDefaultRatio, "If speed == 0.0, uses (max-min) * DragSpeedDefaultRatio")    // imgui_internal.h:1970
        .def_readwrite("scrollbar_click_delta_to_grab_center", &ImGuiContext::ScrollbarClickDeltaToGrabCenter, "Distance between mouse and center of grab box, normalized in parent space. Use storage?")    // imgui_internal.h:1971
        .def_readwrite("disabled_alpha_backup", &ImGuiContext::DisabledAlphaBackup, "Backup for style.Alpha for BeginDisabled()")    // imgui_internal.h:1972
        .def_readwrite("disabled_stack_size", &ImGuiContext::DisabledStackSize, "")    // imgui_internal.h:1973
        .def_readwrite("tooltip_override_count", &ImGuiContext::TooltipOverrideCount, "")    // imgui_internal.h:1974
        .def_readwrite("tooltip_slow_delay", &ImGuiContext::TooltipSlowDelay, "Time before slow tooltips appears (FIXME: This is temporary until we merge in tooltip timer+priority work)")    // imgui_internal.h:1975
        .def_readwrite("platform_ime_data", &ImGuiContext::PlatformImeData, "Data updated by current frame")    // imgui_internal.h:1980
        .def_readwrite("platform_ime_data_prev", &ImGuiContext::PlatformImeDataPrev, "Previous frame data (when changing we will call io.SetPlatformImeDataFn")    // imgui_internal.h:1981
        .def_readwrite("platform_ime_viewport", &ImGuiContext::PlatformImeViewport, "")    // imgui_internal.h:1982
        .def_readwrite("platform_locale_decimal_point", &ImGuiContext::PlatformLocaleDecimalPoint, "'.' or *localeconv()->decimal_point")    // imgui_internal.h:1983
        .def_readwrite("dock_context", &ImGuiContext::DockContext, " Extensions\n FIXME: We could provide an API to register one slot in an array held in ImGuiContext?")    // imgui_internal.h:1987
        .def_readwrite("settings_loaded", &ImGuiContext::SettingsLoaded, "")    // imgui_internal.h:1990
        .def_readwrite("settings_dirty_timer", &ImGuiContext::SettingsDirtyTimer, "Save .ini Settings to memory when time reaches zero")    // imgui_internal.h:1991
        .def_readwrite("settings_ini_data", &ImGuiContext::SettingsIniData, "In memory .ini settings")    // imgui_internal.h:1992
        .def_readwrite("hook_id_next", &ImGuiContext::HookIdNext, "Next available HookId")    // imgui_internal.h:1997
        .def_readwrite("log_enabled", &ImGuiContext::LogEnabled, "Currently capturing")    // imgui_internal.h:2000
        .def_readwrite("log_type", &ImGuiContext::LogType, "Capture target")    // imgui_internal.h:2001
        .def_readwrite("log_file", &ImGuiContext::LogFile, "If != None log to stdout/ file")    // imgui_internal.h:2002
        .def_readwrite("log_buffer", &ImGuiContext::LogBuffer, "Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.")    // imgui_internal.h:2003
        .def_readonly("log_next_prefix", &ImGuiContext::LogNextPrefix, "")    // imgui_internal.h:2004
        .def_readonly("log_next_suffix", &ImGuiContext::LogNextSuffix, "")    // imgui_internal.h:2005
        .def_readwrite("log_line_pos_y", &ImGuiContext::LogLinePosY, "")    // imgui_internal.h:2006
        .def_readwrite("log_line_first_item", &ImGuiContext::LogLineFirstItem, "")    // imgui_internal.h:2007
        .def_readwrite("log_depth_ref", &ImGuiContext::LogDepthRef, "")    // imgui_internal.h:2008
        .def_readwrite("log_depth_to_expand", &ImGuiContext::LogDepthToExpand, "")    // imgui_internal.h:2009
        .def_readwrite("log_depth_to_expand_default", &ImGuiContext::LogDepthToExpandDefault, "Default/stored value for LogDepthMaxExpand if not specified in the LogXXX function call.")    // imgui_internal.h:2010
        .def_readwrite("debug_log_flags", &ImGuiContext::DebugLogFlags, "")    // imgui_internal.h:2013
        .def_readwrite("debug_log_buf", &ImGuiContext::DebugLogBuf, "")    // imgui_internal.h:2014
        .def_readwrite("debug_item_picker_active", &ImGuiContext::DebugItemPickerActive, "Item picker is active (started with DebugStartItemPicker())")    // imgui_internal.h:2015
        .def_readwrite("debug_item_picker_break_id", &ImGuiContext::DebugItemPickerBreakId, "Will call IM_DEBUG_BREAK() when encountering this ID")    // imgui_internal.h:2016
        .def_readwrite("debug_metrics_config", &ImGuiContext::DebugMetricsConfig, "")    // imgui_internal.h:2017
        .def_readwrite("debug_stack_tool", &ImGuiContext::DebugStackTool, "")    // imgui_internal.h:2018
        .def_property("framerate_sec_per_frame",    // imgui_internal.h:2021
            [](ImGuiContext &self) -> pybind11::array
            {
                auto dtype = pybind11::dtype(pybind11::format_descriptor<float>::format());
                auto base = pybind11::array(dtype, {120}, {sizeof(float)});
                return pybind11::array(dtype, {120}, {sizeof(float)}, self.FramerateSecPerFrame, base);
            }, [](ImGuiContext& self) {},
            "Calculate estimate of framerate for user over the last 2 seconds.")
        .def_readwrite("framerate_sec_per_frame_idx", &ImGuiContext::FramerateSecPerFrameIdx, "")    // imgui_internal.h:2022
        .def_readwrite("framerate_sec_per_frame_count", &ImGuiContext::FramerateSecPerFrameCount, "")    // imgui_internal.h:2023
        .def_readwrite("framerate_sec_per_frame_accum", &ImGuiContext::FramerateSecPerFrameAccum, "")    // imgui_internal.h:2024
        .def_readwrite("want_capture_mouse_next_frame", &ImGuiContext::WantCaptureMouseNextFrame, "Explicit capture override via SetNextFrameWantCaptureMouse()/SetNextFrameWantCaptureKeyboard(). Default to -1.")    // imgui_internal.h:2025
        .def_readwrite("want_capture_keyboard_next_frame", &ImGuiContext::WantCaptureKeyboardNextFrame, "\"")    // imgui_internal.h:2026
        .def_readwrite("want_text_input_next_frame", &ImGuiContext::WantTextInputNextFrame, "")    // imgui_internal.h:2027
        .def(py::init<ImFontAtlas *>(),    // imgui_internal.h:2030
            py::arg("shared_font_atlas"))
        ;


    auto pyClassImGuiWindowTempData =
        py::class_<ImGuiWindowTempData>    // imgui_internal.h:2198
            (m, "ImGuiWindowTempData", " Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.\n (That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered..)\n (This doesn't need a constructor because we zero-clear it as part of ImGuiWindow and all frame-temporary data are setup on Begin)")
        .def(py::init<>([](
        ImVec2 CursorPos = ImVec2(), ImVec2 CursorPosPrevLine = ImVec2(), ImVec2 CursorStartPos = ImVec2(), ImVec2 CursorMaxPos = ImVec2(), ImVec2 IdealMaxPos = ImVec2(), ImVec2 CurrLineSize = ImVec2(), ImVec2 PrevLineSize = ImVec2(), float CurrLineTextBaseOffset = float(), float PrevLineTextBaseOffset = float(), bool IsSameLine = bool(), ImVec1 Indent = ImVec1(), ImVec1 ColumnsOffset = ImVec1(), ImVec1 GroupOffset = ImVec1(), ImVec2 CursorStartPosLossyness = ImVec2(), ImGuiNavLayer NavLayerCurrent = ImGuiNavLayer(), short NavLayersActiveMask = short(), short NavLayersActiveMaskNext = short(), ImGuiID NavFocusScopeIdCurrent = ImGuiID(), bool NavHideHighlightOneFrame = bool(), bool NavHasScroll = bool(), bool MenuBarAppending = bool(), ImVec2 MenuBarOffset = ImVec2(), ImGuiMenuColumns MenuColumns = ImGuiMenuColumns(), int TreeDepth = int(), ImU32 TreeJumpToParentOnPopMask = ImU32(), int CurrentTableIdx = int(), ImGuiLayoutType LayoutType = ImGuiLayoutType(), ImGuiLayoutType ParentLayoutType = ImGuiLayoutType(), float ItemWidth = float(), float TextWrapPos = float())
        {
            auto r = std::make_unique<ImGuiWindowTempData>();
            r->CursorPos = CursorPos;
            r->CursorPosPrevLine = CursorPosPrevLine;
            r->CursorStartPos = CursorStartPos;
            r->CursorMaxPos = CursorMaxPos;
            r->IdealMaxPos = IdealMaxPos;
            r->CurrLineSize = CurrLineSize;
            r->PrevLineSize = PrevLineSize;
            r->CurrLineTextBaseOffset = CurrLineTextBaseOffset;
            r->PrevLineTextBaseOffset = PrevLineTextBaseOffset;
            r->IsSameLine = IsSameLine;
            r->Indent = Indent;
            r->ColumnsOffset = ColumnsOffset;
            r->GroupOffset = GroupOffset;
            r->CursorStartPosLossyness = CursorStartPosLossyness;
            r->NavLayerCurrent = NavLayerCurrent;
            r->NavLayersActiveMask = NavLayersActiveMask;
            r->NavLayersActiveMaskNext = NavLayersActiveMaskNext;
            r->NavFocusScopeIdCurrent = NavFocusScopeIdCurrent;
            r->NavHideHighlightOneFrame = NavHideHighlightOneFrame;
            r->NavHasScroll = NavHasScroll;
            r->MenuBarAppending = MenuBarAppending;
            r->MenuBarOffset = MenuBarOffset;
            r->MenuColumns = MenuColumns;
            r->TreeDepth = TreeDepth;
            r->TreeJumpToParentOnPopMask = TreeJumpToParentOnPopMask;
            r->CurrentTableIdx = CurrentTableIdx;
            r->LayoutType = LayoutType;
            r->ParentLayoutType = ParentLayoutType;
            r->ItemWidth = ItemWidth;
            r->TextWrapPos = TextWrapPos;
            return r;
        })
        , py::arg("cursor_pos") = ImVec2(), py::arg("cursor_pos_prev_line") = ImVec2(), py::arg("cursor_start_pos") = ImVec2(), py::arg("cursor_max_pos") = ImVec2(), py::arg("ideal_max_pos") = ImVec2(), py::arg("curr_line_size") = ImVec2(), py::arg("prev_line_size") = ImVec2(), py::arg("curr_line_text_base_offset") = float(), py::arg("prev_line_text_base_offset") = float(), py::arg("is_same_line") = bool(), py::arg("indent") = ImVec1(), py::arg("columns_offset") = ImVec1(), py::arg("group_offset") = ImVec1(), py::arg("cursor_start_pos_lossyness") = ImVec2(), py::arg("nav_layer_current") = ImGuiNavLayer(), py::arg("nav_layers_active_mask") = short(), py::arg("nav_layers_active_mask_next") = short(), py::arg("nav_focus_scope_id_current") = ImGuiID(), py::arg("nav_hide_highlight_one_frame") = bool(), py::arg("nav_has_scroll") = bool(), py::arg("menu_bar_appending") = bool(), py::arg("menu_bar_offset") = ImVec2(), py::arg("menu_columns") = ImGuiMenuColumns(), py::arg("tree_depth") = int(), py::arg("tree_jump_to_parent_on_pop_mask") = ImU32(), py::arg("current_table_idx") = int(), py::arg("layout_type") = ImGuiLayoutType(), py::arg("parent_layout_type") = ImGuiLayoutType(), py::arg("item_width") = float(), py::arg("text_wrap_pos") = float()
        )
        .def_readwrite("cursor_pos", &ImGuiWindowTempData::CursorPos, "Current emitting position, in absolute coordinates.")    // imgui_internal.h:2201
        .def_readwrite("cursor_pos_prev_line", &ImGuiWindowTempData::CursorPosPrevLine, "")    // imgui_internal.h:2202
        .def_readwrite("cursor_start_pos", &ImGuiWindowTempData::CursorStartPos, "Initial position after Begin(), generally ~ window position + WindowPadding.")    // imgui_internal.h:2203
        .def_readwrite("cursor_max_pos", &ImGuiWindowTempData::CursorMaxPos, "Used to implicitly calculate ContentSize at the beginning of next frame, for scrolling range and auto-resize. Always growing during the frame.")    // imgui_internal.h:2204
        .def_readwrite("ideal_max_pos", &ImGuiWindowTempData::IdealMaxPos, "Used to implicitly calculate ContentSizeIdeal at the beginning of next frame, for auto-resize only. Always growing during the frame.")    // imgui_internal.h:2205
        .def_readwrite("curr_line_size", &ImGuiWindowTempData::CurrLineSize, "")    // imgui_internal.h:2206
        .def_readwrite("prev_line_size", &ImGuiWindowTempData::PrevLineSize, "")    // imgui_internal.h:2207
        .def_readwrite("curr_line_text_base_offset", &ImGuiWindowTempData::CurrLineTextBaseOffset, "Baseline offset (0.0 by default on a new line, generally == style.FramePadding.y when a framed item has been added).")    // imgui_internal.h:2208
        .def_readwrite("prev_line_text_base_offset", &ImGuiWindowTempData::PrevLineTextBaseOffset, "")    // imgui_internal.h:2209
        .def_readwrite("is_same_line", &ImGuiWindowTempData::IsSameLine, "")    // imgui_internal.h:2210
        .def_readwrite("indent", &ImGuiWindowTempData::Indent, "Indentation / start position from left of window (increased by TreePush/TreePop, etc.)")    // imgui_internal.h:2211
        .def_readwrite("columns_offset", &ImGuiWindowTempData::ColumnsOffset, "Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.")    // imgui_internal.h:2212
        .def_readwrite("group_offset", &ImGuiWindowTempData::GroupOffset, "")    // imgui_internal.h:2213
        .def_readwrite("cursor_start_pos_lossyness", &ImGuiWindowTempData::CursorStartPosLossyness, "Record the loss of precision of CursorStartPos due to really large scrolling amount. This is used by clipper to compensentate and fix the most common use case of large scroll area.")    // imgui_internal.h:2214
        .def_readwrite("nav_layer_current", &ImGuiWindowTempData::NavLayerCurrent, "Current layer, 0..31 (we currently only use 0..1)")    // imgui_internal.h:2217
        .def_readwrite("nav_layers_active_mask", &ImGuiWindowTempData::NavLayersActiveMask, "Which layers have been written to (result from previous frame)")    // imgui_internal.h:2218
        .def_readwrite("nav_layers_active_mask_next", &ImGuiWindowTempData::NavLayersActiveMaskNext, "Which layers have been written to (accumulator for current frame)")    // imgui_internal.h:2219
        .def_readwrite("nav_focus_scope_id_current", &ImGuiWindowTempData::NavFocusScopeIdCurrent, "Current focus scope ID while appending")    // imgui_internal.h:2220
        .def_readwrite("nav_hide_highlight_one_frame", &ImGuiWindowTempData::NavHideHighlightOneFrame, "")    // imgui_internal.h:2221
        .def_readwrite("nav_has_scroll", &ImGuiWindowTempData::NavHasScroll, "Set when scrolling can be used (ScrollMax > 0.0)")    // imgui_internal.h:2222
        .def_readwrite("menu_bar_appending", &ImGuiWindowTempData::MenuBarAppending, "FIXME: Remove this")    // imgui_internal.h:2225
        .def_readwrite("menu_bar_offset", &ImGuiWindowTempData::MenuBarOffset, "MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.")    // imgui_internal.h:2226
        .def_readwrite("menu_columns", &ImGuiWindowTempData::MenuColumns, "Simplified columns storage for menu items measurement")    // imgui_internal.h:2227
        .def_readwrite("tree_depth", &ImGuiWindowTempData::TreeDepth, "Current tree depth.")    // imgui_internal.h:2228
        .def_readwrite("tree_jump_to_parent_on_pop_mask", &ImGuiWindowTempData::TreeJumpToParentOnPopMask, "Store a copy of !g.NavIdIsAlive for TreeDepth 0..31.. Could be turned into a ImU64 if necessary.")    // imgui_internal.h:2229
        .def_readwrite("state_storage", &ImGuiWindowTempData::StateStorage, "Current persistent per-window storage (store e.g. tree node open/close state)")    // imgui_internal.h:2231
        .def_readwrite("current_columns", &ImGuiWindowTempData::CurrentColumns, "Current columns set")    // imgui_internal.h:2232
        .def_readwrite("current_table_idx", &ImGuiWindowTempData::CurrentTableIdx, "Current table index (into g.Tables)")    // imgui_internal.h:2233
        .def_readwrite("layout_type", &ImGuiWindowTempData::LayoutType, "")    // imgui_internal.h:2234
        .def_readwrite("parent_layout_type", &ImGuiWindowTempData::ParentLayoutType, "Layout type of parent window at the time of Begin()")    // imgui_internal.h:2235
        .def_readwrite("item_width", &ImGuiWindowTempData::ItemWidth, "Current item width (>0.0: width in pixels, <0.0: align xx pixels to the right of window).")    // imgui_internal.h:2239
        .def_readwrite("text_wrap_pos", &ImGuiWindowTempData::TextWrapPos, "Current text wrap pos.")    // imgui_internal.h:2240
        ;


    auto pyClassImGuiWindow =
        py::class_<ImGuiWindow>    // imgui_internal.h:2246
            (m, "ImGuiWindow", "Storage for one window")
        .def_readwrite("id", &ImGuiWindow::ID, "== ImHashStr(Name)")    // imgui_internal.h:2249
        .def_readwrite("flags", &ImGuiWindow::Flags, "See enum ImGuiWindowFlags_")    // imgui_internal.h:2250
        .def_readwrite("flags_previous_frame", &ImGuiWindow::FlagsPreviousFrame, "See enum ImGuiWindowFlags_")    // imgui_internal.h:2250
        .def_readwrite("window_class", &ImGuiWindow::WindowClass, "Advanced users only. Set with SetNextWindowClass()")    // imgui_internal.h:2251
        .def_readwrite("viewport", &ImGuiWindow::Viewport, "Always set in Begin(). Inactive windows may have a None value here if their viewport was discarded.")    // imgui_internal.h:2252
        .def_readwrite("viewport_id", &ImGuiWindow::ViewportId, "We backup the viewport id (since the viewport may disappear or never be created if the window is inactive)")    // imgui_internal.h:2253
        .def_readwrite("viewport_pos", &ImGuiWindow::ViewportPos, "We backup the viewport position (since the viewport may disappear or never be created if the window is inactive)")    // imgui_internal.h:2254
        .def_readwrite("viewport_allow_platform_monitor_extend", &ImGuiWindow::ViewportAllowPlatformMonitorExtend, "Reset to -1 every frame (index is guaranteed to be valid between NewFrame..EndFrame), only used in the Appearing frame of a tooltip/popup to enforce clamping to a given monitor")    // imgui_internal.h:2255
        .def_readwrite("pos", &ImGuiWindow::Pos, "Position (always rounded-up to nearest pixel)")    // imgui_internal.h:2256
        .def_readwrite("size", &ImGuiWindow::Size, "Current size (==SizeFull or collapsed title bar size)")    // imgui_internal.h:2257
        .def_readwrite("size_full", &ImGuiWindow::SizeFull, "Size when non collapsed")    // imgui_internal.h:2258
        .def_readwrite("content_size", &ImGuiWindow::ContentSize, "Size of contents/scrollable client area (calculated from the extents reach of the cursor) from previous frame. Does not include window decoration or window padding.")    // imgui_internal.h:2259
        .def_readwrite("content_size_ideal", &ImGuiWindow::ContentSizeIdeal, "")    // imgui_internal.h:2260
        .def_readwrite("content_size_explicit", &ImGuiWindow::ContentSizeExplicit, "Size of contents/scrollable client area explicitly request by the user via SetNextWindowContentSize().")    // imgui_internal.h:2261
        .def_readwrite("window_padding", &ImGuiWindow::WindowPadding, "Window padding at the time of Begin().")    // imgui_internal.h:2262
        .def_readwrite("window_rounding", &ImGuiWindow::WindowRounding, "Window rounding at the time of Begin(). May be clamped lower to avoid rendering artifacts with title bar, menu bar etc.")    // imgui_internal.h:2263
        .def_readwrite("window_border_size", &ImGuiWindow::WindowBorderSize, "Window border size at the time of Begin().")    // imgui_internal.h:2264
        .def_readwrite("name_buf_len", &ImGuiWindow::NameBufLen, "Size of buffer storing Name. May be larger than strlen(Name)!")    // imgui_internal.h:2265
        .def_readwrite("move_id", &ImGuiWindow::MoveId, "== window->GetID(\"#MOVE\")")    // imgui_internal.h:2266
        .def_readwrite("tab_id", &ImGuiWindow::TabId, "== window->GetID(\"#TAB\")")    // imgui_internal.h:2267
        .def_readwrite("child_id", &ImGuiWindow::ChildId, "ID of corresponding item in parent window (for navigation to return from child window to parent window)")    // imgui_internal.h:2268
        .def_readwrite("scroll", &ImGuiWindow::Scroll, "")    // imgui_internal.h:2269
        .def_readwrite("scroll_max", &ImGuiWindow::ScrollMax, "")    // imgui_internal.h:2270
        .def_readwrite("scroll_target", &ImGuiWindow::ScrollTarget, "target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0. (FLT_MAX for no change)")    // imgui_internal.h:2271
        .def_readwrite("scroll_target_center_ratio", &ImGuiWindow::ScrollTargetCenterRatio, "0.0 = scroll so that target position is at top, 0.5 = scroll so that target position is centered")    // imgui_internal.h:2272
        .def_readwrite("scroll_target_edge_snap_dist", &ImGuiWindow::ScrollTargetEdgeSnapDist, "0.0 = no snapping, >0.0 snapping threshold")    // imgui_internal.h:2273
        .def_readwrite("scrollbar_sizes", &ImGuiWindow::ScrollbarSizes, "Size taken by each scrollbars on their smaller axis. Pay attention! ScrollbarSizes.x == width of the vertical scrollbar, ScrollbarSizes.y = height of the horizontal scrollbar.")    // imgui_internal.h:2274
        .def_readwrite("scrollbar_x", &ImGuiWindow::ScrollbarX, "Are scrollbars visible?")    // imgui_internal.h:2275
        .def_readwrite("scrollbar_y", &ImGuiWindow::ScrollbarY, "Are scrollbars visible?")    // imgui_internal.h:2275
        .def_readwrite("viewport_owned", &ImGuiWindow::ViewportOwned, "")    // imgui_internal.h:2276
        .def_readwrite("active", &ImGuiWindow::Active, "Set to True on Begin(), unless Collapsed")    // imgui_internal.h:2277
        .def_readwrite("was_active", &ImGuiWindow::WasActive, "")    // imgui_internal.h:2278
        .def_readwrite("write_accessed", &ImGuiWindow::WriteAccessed, "Set to True when any widget access the current window")    // imgui_internal.h:2279
        .def_readwrite("collapsed", &ImGuiWindow::Collapsed, "Set when collapsing window to become only title-bar")    // imgui_internal.h:2280
        .def_readwrite("want_collapse_toggle", &ImGuiWindow::WantCollapseToggle, "")    // imgui_internal.h:2281
        .def_readwrite("skip_items", &ImGuiWindow::SkipItems, "Set when items can safely be all clipped (e.g. window not visible or collapsed)")    // imgui_internal.h:2282
        .def_readwrite("appearing", &ImGuiWindow::Appearing, "Set during the frame where the window is appearing (or re-appearing)")    // imgui_internal.h:2283
        .def_readwrite("hidden", &ImGuiWindow::Hidden, "Do not display (== HiddenFrames*** > 0)")    // imgui_internal.h:2284
        .def_readwrite("is_fallback_window", &ImGuiWindow::IsFallbackWindow, "Set on the \"Debug##Default\" window.")    // imgui_internal.h:2285
        .def_readwrite("is_explicit_child", &ImGuiWindow::IsExplicitChild, "Set when passed _ChildWindow, left to False by BeginDocked()")    // imgui_internal.h:2286
        .def_readwrite("has_close_button", &ImGuiWindow::HasCloseButton, "Set when the window has a close button (p_open != None)")    // imgui_internal.h:2287
        .def_readwrite("resize_border_held", &ImGuiWindow::ResizeBorderHeld, "Current border being held for resize (-1: none, otherwise 0-3)")    // imgui_internal.h:2288
        .def_readwrite("begin_count", &ImGuiWindow::BeginCount, "Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)")    // imgui_internal.h:2289
        .def_readwrite("begin_order_within_parent", &ImGuiWindow::BeginOrderWithinParent, "Begin() order within immediate parent window, if we are a child window. Otherwise 0.")    // imgui_internal.h:2290
        .def_readwrite("begin_order_within_context", &ImGuiWindow::BeginOrderWithinContext, "Begin() order within entire imgui context. This is mostly used for debugging submission order related issues.")    // imgui_internal.h:2291
        .def_readwrite("focus_order", &ImGuiWindow::FocusOrder, "Order within WindowsFocusOrder[], altered when windows are focused.")    // imgui_internal.h:2292
        .def_readwrite("popup_id", &ImGuiWindow::PopupId, "ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)")    // imgui_internal.h:2293
        .def_readwrite("auto_fit_frames_x", &ImGuiWindow::AutoFitFramesX, "")    // imgui_internal.h:2294
        .def_readwrite("auto_fit_frames_y", &ImGuiWindow::AutoFitFramesY, "")    // imgui_internal.h:2294
        .def_readwrite("auto_fit_child_axises", &ImGuiWindow::AutoFitChildAxises, "")    // imgui_internal.h:2295
        .def_readwrite("auto_fit_only_grows", &ImGuiWindow::AutoFitOnlyGrows, "")    // imgui_internal.h:2296
        .def_readwrite("auto_pos_last_direction", &ImGuiWindow::AutoPosLastDirection, "")    // imgui_internal.h:2297
        .def_readwrite("hidden_frames_can_skip_items", &ImGuiWindow::HiddenFramesCanSkipItems, "Hide the window for N frames")    // imgui_internal.h:2298
        .def_readwrite("hidden_frames_cannot_skip_items", &ImGuiWindow::HiddenFramesCannotSkipItems, "Hide the window for N frames while allowing items to be submitted so we can measure their size")    // imgui_internal.h:2299
        .def_readwrite("hidden_frames_for_render_only", &ImGuiWindow::HiddenFramesForRenderOnly, "Hide the window until frame N at Render() time only")    // imgui_internal.h:2300
        .def_readwrite("disable_inputs_frames", &ImGuiWindow::DisableInputsFrames, "Disable window interactions for N frames")    // imgui_internal.h:2301
        .def_readwrite("set_window_pos_val", &ImGuiWindow::SetWindowPosVal, "store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)")    // imgui_internal.h:2306
        .def_readwrite("set_window_pos_pivot", &ImGuiWindow::SetWindowPosPivot, "store window pivot for positioning. ImVec2(0, 0) when positioning from top-left corner; ImVec2(0.5, 0.5) for centering; ImVec2(1, 1) for bottom right.")    // imgui_internal.h:2307
        .def_readwrite("dc", &ImGuiWindow::DC, "Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the \"DC\" variable name.")    // imgui_internal.h:2310
        .def_readwrite("outer_rect_clipped", &ImGuiWindow::OuterRectClipped, "== Window->Rect() just after setup in Begin(). == window->Rect() for root window.")    // imgui_internal.h:2314
        .def_readwrite("inner_rect", &ImGuiWindow::InnerRect, "Inner rectangle (omit title bar, menu bar, scroll bar)")    // imgui_internal.h:2315
        .def_readwrite("inner_clip_rect", &ImGuiWindow::InnerClipRect, "== InnerRect shrunk by WindowPadding*0.5 on each side, clipped within viewport or parent clip rect.")    // imgui_internal.h:2316
        .def_readwrite("work_rect", &ImGuiWindow::WorkRect, "Initially covers the whole scrolling region. Reduced by containers e.g columns/tables when active. Shrunk by WindowPadding*1.0 on each side. This is meant to replace ContentRegionRect over time (from 1.71+ onward).")    // imgui_internal.h:2317
        .def_readwrite("parent_work_rect", &ImGuiWindow::ParentWorkRect, "Backup of WorkRect before entering a container such as columns/tables. Used by e.g. SpanAllColumns functions to easily access. Stacked containers are responsible for maintaining this. // FIXME-WORKRECT: Could be a stack?")    // imgui_internal.h:2318
        .def_readwrite("clip_rect", &ImGuiWindow::ClipRect, "Current clipping/scissoring rectangle, evolve as we are using PushClipRect(), etc. == DrawList->clip_rect_stack.back().")    // imgui_internal.h:2319
        .def_readwrite("content_region_rect", &ImGuiWindow::ContentRegionRect, "FIXME: This is currently confusing/misleading. It is essentially WorkRect but not handling of scrolling. We currently rely on it as right/bottom aligned sizing operation need some size to rely on.")    // imgui_internal.h:2320
        .def_readwrite("hit_test_hole_size", &ImGuiWindow::HitTestHoleSize, "Define an optional rectangular hole where mouse will pass-through the window.")    // imgui_internal.h:2321
        .def_readwrite("hit_test_hole_offset", &ImGuiWindow::HitTestHoleOffset, "")    // imgui_internal.h:2322
        .def_readwrite("last_frame_active", &ImGuiWindow::LastFrameActive, "Last frame number the window was Active.")    // imgui_internal.h:2324
        .def_readwrite("last_frame_just_focused", &ImGuiWindow::LastFrameJustFocused, "Last frame number the window was made Focused.")    // imgui_internal.h:2325
        .def_readwrite("last_time_active", &ImGuiWindow::LastTimeActive, "Last timestamp the window was Active (using float as we don't need high precision there)")    // imgui_internal.h:2326
        .def_readwrite("item_width_default", &ImGuiWindow::ItemWidthDefault, "")    // imgui_internal.h:2327
        .def_readwrite("state_storage", &ImGuiWindow::StateStorage, "")    // imgui_internal.h:2328
        .def_readwrite("font_window_scale", &ImGuiWindow::FontWindowScale, "User scale multiplier per-window, via SetWindowFontScale()")    // imgui_internal.h:2330
        .def_readwrite("font_dpi_scale", &ImGuiWindow::FontDpiScale, "")    // imgui_internal.h:2331
        .def_readwrite("settings_offset", &ImGuiWindow::SettingsOffset, "Offset into SettingsWindows[] (offsets are always valid as we only grow the array from the back)")    // imgui_internal.h:2332
        .def_readwrite("draw_list", &ImGuiWindow::DrawList, "== &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)")    // imgui_internal.h:2334
        .def_readwrite("draw_list_inst", &ImGuiWindow::DrawListInst, "")    // imgui_internal.h:2335
        .def_readwrite("parent_window", &ImGuiWindow::ParentWindow, "If we are a child _or_ popup _or_ docked window, this is pointing to our parent. Otherwise None.")    // imgui_internal.h:2336
        .def_readwrite("parent_window_in_begin_stack", &ImGuiWindow::ParentWindowInBeginStack, "")    // imgui_internal.h:2337
        .def_readwrite("root_window", &ImGuiWindow::RootWindow, "Point to ourself or first ancestor that is not a child window. Doesn't cross through popups/dock nodes.")    // imgui_internal.h:2338
        .def_readwrite("root_window_popup_tree", &ImGuiWindow::RootWindowPopupTree, "Point to ourself or first ancestor that is not a child window. Cross through popups parent<>child.")    // imgui_internal.h:2339
        .def_readwrite("root_window_dock_tree", &ImGuiWindow::RootWindowDockTree, "Point to ourself or first ancestor that is not a child window. Cross through dock nodes.")    // imgui_internal.h:2340
        .def_readwrite("root_window_for_title_bar_highlight", &ImGuiWindow::RootWindowForTitleBarHighlight, "Point to ourself or first ancestor which will display TitleBgActive color when this window is active.")    // imgui_internal.h:2341
        .def_readwrite("root_window_for_nav", &ImGuiWindow::RootWindowForNav, "Point to ourself or first ancestor which doesn't have the NavFlattened flag.")    // imgui_internal.h:2342
        .def_readwrite("nav_last_child_nav_window", &ImGuiWindow::NavLastChildNavWindow, "When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)")    // imgui_internal.h:2344
        .def_readwrite("memory_draw_list_idx_capacity", &ImGuiWindow::MemoryDrawListIdxCapacity, "Backup of last idx/vtx count, so when waking up the window we can preallocate and avoid iterative alloc/copy")    // imgui_internal.h:2348
        .def_readwrite("memory_draw_list_vtx_capacity", &ImGuiWindow::MemoryDrawListVtxCapacity, "")    // imgui_internal.h:2349
        .def_readwrite("memory_compacted", &ImGuiWindow::MemoryCompacted, "Set when window extraneous data have been garbage collected")    // imgui_internal.h:2350
        .def_readwrite("dock_order", &ImGuiWindow::DockOrder, "Order of the last time the window was visible within its DockNode. This is used to reorder windows that are reappearing on the same frame. Same value between windows that were active and windows that were none are possible.")    // imgui_internal.h:2357
        .def_readwrite("dock_style", &ImGuiWindow::DockStyle, "")    // imgui_internal.h:2358
        .def_readwrite("dock_node", &ImGuiWindow::DockNode, "Which node are we docked into. Important: Prefer testing DockIsActive in many cases as this will still be set when the dock node is hidden.")    // imgui_internal.h:2359
        .def_readwrite("dock_node_as_host", &ImGuiWindow::DockNodeAsHost, "Which node are we owning (for parent windows)")    // imgui_internal.h:2360
        .def_readwrite("dock_id", &ImGuiWindow::DockId, "Backup of last valid DockNode->ID, so single window remember their dock node id even when they are not bound any more")    // imgui_internal.h:2361
        .def_readwrite("dock_tab_item_status_flags", &ImGuiWindow::DockTabItemStatusFlags, "")    // imgui_internal.h:2362
        .def_readwrite("dock_tab_item_rect", &ImGuiWindow::DockTabItemRect, "")    // imgui_internal.h:2363
        .def(py::init<ImGuiContext *, const char *>(),    // imgui_internal.h:2366
            py::arg("context"), py::arg("name"))
        ;


    py::enum_<ImGuiTabBarFlagsPrivate_>(m, "ImGuiTabBarFlagsPrivate_", py::arithmetic(), "Extend ImGuiTabBarFlags_")    // imgui_internal.h:2388
        .value("im_gui_tab_bar_flags_dock_node", ImGuiTabBarFlags_DockNode, "Part of a dock node [we don't use this in the master branch but it facilitate branch syncing to keep this around]")
        .value("im_gui_tab_bar_flags_is_focused", ImGuiTabBarFlags_IsFocused, "")
        .value("im_gui_tab_bar_flags_save_settings", ImGuiTabBarFlags_SaveSettings, "FIXME: Settings are handled by the docking system, this only request the tab bar to mark settings dirty when reordering tabs");


    py::enum_<ImGuiTabItemFlagsPrivate_>(m, "ImGuiTabItemFlagsPrivate_", py::arithmetic(), "Extend ImGuiTabItemFlags_")    // imgui_internal.h:2396
        .value("im_gui_tab_item_flags_section_mask_", ImGuiTabItemFlags_SectionMask_, "")
        .value("im_gui_tab_item_flags_no_close_button", ImGuiTabItemFlags_NoCloseButton, "Track whether p_open was set or not (we'll need this info on the next frame to recompute ContentWidth during layout)")
        .value("im_gui_tab_item_flags_button", ImGuiTabItemFlags_Button, "Used by TabItemButton, change the tab item behavior to mimic a button")
        .value("im_gui_tab_item_flags_unsorted", ImGuiTabItemFlags_Unsorted, "[Docking] Trailing tabs with the _Unsorted flag will be sorted based on the DockOrder of their Window.")
        .value("im_gui_tab_item_flags_preview", ImGuiTabItemFlags_Preview, "[Docking] Display tab shape for docking preview (height is adjusted slightly to compensate for the yet missing tab bar)");


    auto pyClassImGuiTabItem =
        py::class_<ImGuiTabItem>    // imgui_internal.h:2406
            (m, "ImGuiTabItem", "Storage for one active tab item (sizeof() 48 bytes)")
        .def(py::init<>([](
        ImGuiID ID = ImGuiID(), ImGuiTabItemFlags Flags = ImGuiTabItemFlags(), int LastFrameVisible = int(), int LastFrameSelected = int(), float Offset = float(), float Width = float(), float ContentWidth = float(), float RequestedWidth = float(), ImS32 NameOffset = ImS32(), ImS16 BeginOrder = ImS16(), ImS16 IndexDuringLayout = ImS16(), bool WantClose = bool())
        {
            auto r = std::make_unique<ImGuiTabItem>();
            r->ID = ID;
            r->Flags = Flags;
            r->LastFrameVisible = LastFrameVisible;
            r->LastFrameSelected = LastFrameSelected;
            r->Offset = Offset;
            r->Width = Width;
            r->ContentWidth = ContentWidth;
            r->RequestedWidth = RequestedWidth;
            r->NameOffset = NameOffset;
            r->BeginOrder = BeginOrder;
            r->IndexDuringLayout = IndexDuringLayout;
            r->WantClose = WantClose;
            return r;
        })
        , py::arg("id") = ImGuiID(), py::arg("flags") = ImGuiTabItemFlags(), py::arg("last_frame_visible") = int(), py::arg("last_frame_selected") = int(), py::arg("offset") = float(), py::arg("width") = float(), py::arg("content_width") = float(), py::arg("requested_width") = float(), py::arg("name_offset") = ImS32(), py::arg("begin_order") = ImS16(), py::arg("index_during_layout") = ImS16(), py::arg("want_close") = bool()
        )
        .def_readwrite("id", &ImGuiTabItem::ID, "")    // imgui_internal.h:2408
        .def_readwrite("flags", &ImGuiTabItem::Flags, "")    // imgui_internal.h:2409
        .def_readwrite("window", &ImGuiTabItem::Window, "When TabItem is part of a DockNode's TabBar, we hold on to a window.")    // imgui_internal.h:2410
        .def_readwrite("last_frame_visible", &ImGuiTabItem::LastFrameVisible, "")    // imgui_internal.h:2411
        .def_readwrite("last_frame_selected", &ImGuiTabItem::LastFrameSelected, "This allows us to infer an ordered list of the last activated tabs with little maintenance")    // imgui_internal.h:2412
        .def_readwrite("offset", &ImGuiTabItem::Offset, "Position relative to beginning of tab")    // imgui_internal.h:2413
        .def_readwrite("width", &ImGuiTabItem::Width, "Width currently displayed")    // imgui_internal.h:2414
        .def_readwrite("content_width", &ImGuiTabItem::ContentWidth, "Width of label, stored during BeginTabItem() call")    // imgui_internal.h:2415
        .def_readwrite("requested_width", &ImGuiTabItem::RequestedWidth, "Width optionally requested by caller, -1.0 is unused")    // imgui_internal.h:2416
        .def_readwrite("name_offset", &ImGuiTabItem::NameOffset, "When Window==None, offset to name within parent ImGuiTabBar::TabsNames")    // imgui_internal.h:2417
        .def_readwrite("begin_order", &ImGuiTabItem::BeginOrder, "BeginTabItem() order, used to re-order tabs after toggling ImGuiTabBarFlags_Reorderable")    // imgui_internal.h:2418
        .def_readwrite("index_during_layout", &ImGuiTabItem::IndexDuringLayout, "Index only used during TabBarLayout()")    // imgui_internal.h:2419
        .def_readwrite("want_close", &ImGuiTabItem::WantClose, "Marked as closed by SetTabItemClosed()")    // imgui_internal.h:2420
        .def(py::init<>())    // imgui_internal.h:2422
        ;


    auto pyClassImGuiTabBar =
        py::class_<ImGuiTabBar>    // imgui_internal.h:2426
            (m, "ImGuiTabBar", "Storage for a tab bar (sizeof() 152 bytes)")
        .def(py::init<>([](
        ImGuiTabBarFlags Flags = ImGuiTabBarFlags(), ImGuiID ID = ImGuiID(), ImGuiID SelectedTabId = ImGuiID(), ImGuiID NextSelectedTabId = ImGuiID(), ImGuiID VisibleTabId = ImGuiID(), int CurrFrameVisible = int(), int PrevFrameVisible = int(), ImRect BarRect = ImRect(), float CurrTabsContentsHeight = float(), float PrevTabsContentsHeight = float(), float WidthAllTabs = float(), float WidthAllTabsIdeal = float(), float ScrollingAnim = float(), float ScrollingTarget = float(), float ScrollingTargetDistToVisibility = float(), float ScrollingSpeed = float(), float ScrollingRectMinX = float(), float ScrollingRectMaxX = float(), ImGuiID ReorderRequestTabId = ImGuiID(), ImS16 ReorderRequestOffset = ImS16(), ImS8 BeginCount = ImS8(), bool WantLayout = bool(), bool VisibleTabWasSubmitted = bool(), bool TabsAddedNew = bool(), ImS16 TabsActiveCount = ImS16(), ImS16 LastTabItemIdx = ImS16(), float ItemSpacingY = float(), ImVec2 FramePadding = ImVec2(), ImVec2 BackupCursorPos = ImVec2(), ImGuiTextBuffer TabsNames = ImGuiTextBuffer())
        {
            auto r = std::make_unique<ImGuiTabBar>();
            r->Flags = Flags;
            r->ID = ID;
            r->SelectedTabId = SelectedTabId;
            r->NextSelectedTabId = NextSelectedTabId;
            r->VisibleTabId = VisibleTabId;
            r->CurrFrameVisible = CurrFrameVisible;
            r->PrevFrameVisible = PrevFrameVisible;
            r->BarRect = BarRect;
            r->CurrTabsContentsHeight = CurrTabsContentsHeight;
            r->PrevTabsContentsHeight = PrevTabsContentsHeight;
            r->WidthAllTabs = WidthAllTabs;
            r->WidthAllTabsIdeal = WidthAllTabsIdeal;
            r->ScrollingAnim = ScrollingAnim;
            r->ScrollingTarget = ScrollingTarget;
            r->ScrollingTargetDistToVisibility = ScrollingTargetDistToVisibility;
            r->ScrollingSpeed = ScrollingSpeed;
            r->ScrollingRectMinX = ScrollingRectMinX;
            r->ScrollingRectMaxX = ScrollingRectMaxX;
            r->ReorderRequestTabId = ReorderRequestTabId;
            r->ReorderRequestOffset = ReorderRequestOffset;
            r->BeginCount = BeginCount;
            r->WantLayout = WantLayout;
            r->VisibleTabWasSubmitted = VisibleTabWasSubmitted;
            r->TabsAddedNew = TabsAddedNew;
            r->TabsActiveCount = TabsActiveCount;
            r->LastTabItemIdx = LastTabItemIdx;
            r->ItemSpacingY = ItemSpacingY;
            r->FramePadding = FramePadding;
            r->BackupCursorPos = BackupCursorPos;
            r->TabsNames = TabsNames;
            return r;
        })
        , py::arg("flags") = ImGuiTabBarFlags(), py::arg("id") = ImGuiID(), py::arg("selected_tab_id") = ImGuiID(), py::arg("next_selected_tab_id") = ImGuiID(), py::arg("visible_tab_id") = ImGuiID(), py::arg("curr_frame_visible") = int(), py::arg("prev_frame_visible") = int(), py::arg("bar_rect") = ImRect(), py::arg("curr_tabs_contents_height") = float(), py::arg("prev_tabs_contents_height") = float(), py::arg("width_all_tabs") = float(), py::arg("width_all_tabs_ideal") = float(), py::arg("scrolling_anim") = float(), py::arg("scrolling_target") = float(), py::arg("scrolling_target_dist_to_visibility") = float(), py::arg("scrolling_speed") = float(), py::arg("scrolling_rect_min_x") = float(), py::arg("scrolling_rect_max_x") = float(), py::arg("reorder_request_tab_id") = ImGuiID(), py::arg("reorder_request_offset") = ImS16(), py::arg("begin_count") = ImS8(), py::arg("want_layout") = bool(), py::arg("visible_tab_was_submitted") = bool(), py::arg("tabs_added_new") = bool(), py::arg("tabs_active_count") = ImS16(), py::arg("last_tab_item_idx") = ImS16(), py::arg("item_spacing_y") = float(), py::arg("frame_padding") = ImVec2(), py::arg("backup_cursor_pos") = ImVec2(), py::arg("tabs_names") = ImGuiTextBuffer()
        )
        .def_readwrite("flags", &ImGuiTabBar::Flags, "")    // imgui_internal.h:2429
        .def_readwrite("id", &ImGuiTabBar::ID, "Zero for tab-bars used by docking")    // imgui_internal.h:2430
        .def_readwrite("selected_tab_id", &ImGuiTabBar::SelectedTabId, "Selected tab/window")    // imgui_internal.h:2431
        .def_readwrite("next_selected_tab_id", &ImGuiTabBar::NextSelectedTabId, "Next selected tab/window. Will also trigger a scrolling animation")    // imgui_internal.h:2432
        .def_readwrite("visible_tab_id", &ImGuiTabBar::VisibleTabId, "Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)")    // imgui_internal.h:2433
        .def_readwrite("curr_frame_visible", &ImGuiTabBar::CurrFrameVisible, "")    // imgui_internal.h:2434
        .def_readwrite("prev_frame_visible", &ImGuiTabBar::PrevFrameVisible, "")    // imgui_internal.h:2435
        .def_readwrite("bar_rect", &ImGuiTabBar::BarRect, "")    // imgui_internal.h:2436
        .def_readwrite("curr_tabs_contents_height", &ImGuiTabBar::CurrTabsContentsHeight, "")    // imgui_internal.h:2437
        .def_readwrite("prev_tabs_contents_height", &ImGuiTabBar::PrevTabsContentsHeight, "Record the height of contents submitted below the tab bar")    // imgui_internal.h:2438
        .def_readwrite("width_all_tabs", &ImGuiTabBar::WidthAllTabs, "Actual width of all tabs (locked during layout)")    // imgui_internal.h:2439
        .def_readwrite("width_all_tabs_ideal", &ImGuiTabBar::WidthAllTabsIdeal, "Ideal width if all tabs were visible and not clipped")    // imgui_internal.h:2440
        .def_readwrite("scrolling_anim", &ImGuiTabBar::ScrollingAnim, "")    // imgui_internal.h:2441
        .def_readwrite("scrolling_target", &ImGuiTabBar::ScrollingTarget, "")    // imgui_internal.h:2442
        .def_readwrite("scrolling_target_dist_to_visibility", &ImGuiTabBar::ScrollingTargetDistToVisibility, "")    // imgui_internal.h:2443
        .def_readwrite("scrolling_speed", &ImGuiTabBar::ScrollingSpeed, "")    // imgui_internal.h:2444
        .def_readwrite("scrolling_rect_min_x", &ImGuiTabBar::ScrollingRectMinX, "")    // imgui_internal.h:2445
        .def_readwrite("scrolling_rect_max_x", &ImGuiTabBar::ScrollingRectMaxX, "")    // imgui_internal.h:2446
        .def_readwrite("reorder_request_tab_id", &ImGuiTabBar::ReorderRequestTabId, "")    // imgui_internal.h:2447
        .def_readwrite("reorder_request_offset", &ImGuiTabBar::ReorderRequestOffset, "")    // imgui_internal.h:2448
        .def_readwrite("begin_count", &ImGuiTabBar::BeginCount, "")    // imgui_internal.h:2449
        .def_readwrite("want_layout", &ImGuiTabBar::WantLayout, "")    // imgui_internal.h:2450
        .def_readwrite("visible_tab_was_submitted", &ImGuiTabBar::VisibleTabWasSubmitted, "")    // imgui_internal.h:2451
        .def_readwrite("tabs_added_new", &ImGuiTabBar::TabsAddedNew, "Set to True when a new tab item or button has been added to the tab bar during last frame")    // imgui_internal.h:2452
        .def_readwrite("tabs_active_count", &ImGuiTabBar::TabsActiveCount, "Number of tabs submitted this frame.")    // imgui_internal.h:2453
        .def_readwrite("last_tab_item_idx", &ImGuiTabBar::LastTabItemIdx, "Index of last BeginTabItem() tab for use by EndTabItem()")    // imgui_internal.h:2454
        .def_readwrite("item_spacing_y", &ImGuiTabBar::ItemSpacingY, "")    // imgui_internal.h:2455
        .def_readwrite("frame_padding", &ImGuiTabBar::FramePadding, "style.FramePadding locked at the time of BeginTabBar()")    // imgui_internal.h:2456
        .def_readwrite("backup_cursor_pos", &ImGuiTabBar::BackupCursorPos, "")    // imgui_internal.h:2457
        .def_readwrite("tabs_names", &ImGuiTabBar::TabsNames, "For non-docking tab bar we re-append names in a contiguous buffer.")    // imgui_internal.h:2458
        .def(py::init<>())    // imgui_internal.h:2460
        ;


    auto pyClassImGuiTableColumn =
        py::class_<ImGuiTableColumn>    // imgui_internal.h:2487
            (m, "ImGuiTableColumn", " [Internal] sizeof() ~ 104\n We use the terminology \"Enabled\" to refer to a column that is not Hidden by user/api.\n We use the terminology \"Clipped\" to refer to a column that is out of sight because of scrolling/clipping.\n This is in contrast with some user-facing api such as IsItemVisible() / IsRectVisible() which use \"Visible\" to mean \"not clipped\".")
        .def(py::init<>([](
        ImGuiTableColumnFlags Flags = ImGuiTableColumnFlags(), float WidthGiven = float(), float MinX = float(), float MaxX = float(), float WidthRequest = float(), float WidthAuto = float(), float StretchWeight = float(), float InitStretchWeightOrWidth = float(), ImRect ClipRect = ImRect(), ImGuiID UserID = ImGuiID(), float WorkMinX = float(), float WorkMaxX = float(), float ItemWidth = float(), float ContentMaxXFrozen = float(), float ContentMaxXUnfrozen = float(), float ContentMaxXHeadersUsed = float(), float ContentMaxXHeadersIdeal = float(), ImS16 NameOffset = ImS16(), ImGuiTableColumnIdx DisplayOrder = ImGuiTableColumnIdx(), ImGuiTableColumnIdx IndexWithinEnabledSet = ImGuiTableColumnIdx(), ImGuiTableColumnIdx PrevEnabledColumn = ImGuiTableColumnIdx(), ImGuiTableColumnIdx NextEnabledColumn = ImGuiTableColumnIdx(), ImGuiTableColumnIdx SortOrder = ImGuiTableColumnIdx(), ImGuiTableDrawChannelIdx DrawChannelCurrent = ImGuiTableDrawChannelIdx(), ImGuiTableDrawChannelIdx DrawChannelFrozen = ImGuiTableDrawChannelIdx(), ImGuiTableDrawChannelIdx DrawChannelUnfrozen = ImGuiTableDrawChannelIdx(), bool IsEnabled = bool(), bool IsUserEnabled = bool(), bool IsUserEnabledNextFrame = bool(), bool IsVisibleX = bool(), bool IsVisibleY = bool(), bool IsRequestOutput = bool(), bool IsSkipItems = bool(), bool IsPreserveWidthAuto = bool(), ImS8 NavLayerCurrent = ImS8(), ImU8 AutoFitQueue = ImU8(), ImU8 CannotSkipItemsQueue = ImU8(), ImU8 SortDirectionsAvailList = ImU8())
        {
            auto r = std::make_unique<ImGuiTableColumn>();
            r->Flags = Flags;
            r->WidthGiven = WidthGiven;
            r->MinX = MinX;
            r->MaxX = MaxX;
            r->WidthRequest = WidthRequest;
            r->WidthAuto = WidthAuto;
            r->StretchWeight = StretchWeight;
            r->InitStretchWeightOrWidth = InitStretchWeightOrWidth;
            r->ClipRect = ClipRect;
            r->UserID = UserID;
            r->WorkMinX = WorkMinX;
            r->WorkMaxX = WorkMaxX;
            r->ItemWidth = ItemWidth;
            r->ContentMaxXFrozen = ContentMaxXFrozen;
            r->ContentMaxXUnfrozen = ContentMaxXUnfrozen;
            r->ContentMaxXHeadersUsed = ContentMaxXHeadersUsed;
            r->ContentMaxXHeadersIdeal = ContentMaxXHeadersIdeal;
            r->NameOffset = NameOffset;
            r->DisplayOrder = DisplayOrder;
            r->IndexWithinEnabledSet = IndexWithinEnabledSet;
            r->PrevEnabledColumn = PrevEnabledColumn;
            r->NextEnabledColumn = NextEnabledColumn;
            r->SortOrder = SortOrder;
            r->DrawChannelCurrent = DrawChannelCurrent;
            r->DrawChannelFrozen = DrawChannelFrozen;
            r->DrawChannelUnfrozen = DrawChannelUnfrozen;
            r->IsEnabled = IsEnabled;
            r->IsUserEnabled = IsUserEnabled;
            r->IsUserEnabledNextFrame = IsUserEnabledNextFrame;
            r->IsVisibleX = IsVisibleX;
            r->IsVisibleY = IsVisibleY;
            r->IsRequestOutput = IsRequestOutput;
            r->IsSkipItems = IsSkipItems;
            r->IsPreserveWidthAuto = IsPreserveWidthAuto;
            r->NavLayerCurrent = NavLayerCurrent;
            r->AutoFitQueue = AutoFitQueue;
            r->CannotSkipItemsQueue = CannotSkipItemsQueue;
            r->SortDirectionsAvailList = SortDirectionsAvailList;
            return r;
        })
        , py::arg("flags") = ImGuiTableColumnFlags(), py::arg("width_given") = float(), py::arg("min_x") = float(), py::arg("max_x") = float(), py::arg("width_request") = float(), py::arg("width_auto") = float(), py::arg("stretch_weight") = float(), py::arg("init_stretch_weight_or_width") = float(), py::arg("clip_rect") = ImRect(), py::arg("user_id") = ImGuiID(), py::arg("work_min_x") = float(), py::arg("work_max_x") = float(), py::arg("item_width") = float(), py::arg("content_max_x_frozen") = float(), py::arg("content_max_x_unfrozen") = float(), py::arg("content_max_x_headers_used") = float(), py::arg("content_max_x_headers_ideal") = float(), py::arg("name_offset") = ImS16(), py::arg("display_order") = ImGuiTableColumnIdx(), py::arg("index_within_enabled_set") = ImGuiTableColumnIdx(), py::arg("prev_enabled_column") = ImGuiTableColumnIdx(), py::arg("next_enabled_column") = ImGuiTableColumnIdx(), py::arg("sort_order") = ImGuiTableColumnIdx(), py::arg("draw_channel_current") = ImGuiTableDrawChannelIdx(), py::arg("draw_channel_frozen") = ImGuiTableDrawChannelIdx(), py::arg("draw_channel_unfrozen") = ImGuiTableDrawChannelIdx(), py::arg("is_enabled") = bool(), py::arg("is_user_enabled") = bool(), py::arg("is_user_enabled_next_frame") = bool(), py::arg("is_visible_x") = bool(), py::arg("is_visible_y") = bool(), py::arg("is_request_output") = bool(), py::arg("is_skip_items") = bool(), py::arg("is_preserve_width_auto") = bool(), py::arg("nav_layer_current") = ImS8(), py::arg("auto_fit_queue") = ImU8(), py::arg("cannot_skip_items_queue") = ImU8(), py::arg("sort_directions_avail_list") = ImU8()
        )
        .def_readwrite("flags", &ImGuiTableColumn::Flags, "Flags after some patching (not directly same as provided by user). See ImGuiTableColumnFlags_")    // imgui_internal.h:2489
        .def_readwrite("width_given", &ImGuiTableColumn::WidthGiven, "Final/actual width visible == (MaxX - MinX), locked in TableUpdateLayout(). May be > WidthRequest to honor minimum width, may be < WidthRequest to honor shrinking columns down in tight space.")    // imgui_internal.h:2490
        .def_readwrite("min_x", &ImGuiTableColumn::MinX, "Absolute positions")    // imgui_internal.h:2491
        .def_readwrite("max_x", &ImGuiTableColumn::MaxX, "")    // imgui_internal.h:2492
        .def_readwrite("width_request", &ImGuiTableColumn::WidthRequest, "Master width absolute value when !(Flags & _WidthStretch). When Stretch this is derived every frame from StretchWeight in TableUpdateLayout()")    // imgui_internal.h:2493
        .def_readwrite("width_auto", &ImGuiTableColumn::WidthAuto, "Automatic width")    // imgui_internal.h:2494
        .def_readwrite("stretch_weight", &ImGuiTableColumn::StretchWeight, "Master width weight when (Flags & _WidthStretch). Often around ~1.0 initially.")    // imgui_internal.h:2495
        .def_readwrite("init_stretch_weight_or_width", &ImGuiTableColumn::InitStretchWeightOrWidth, "Value passed to TableSetupColumn(). For Width it is a content width (_without padding_).")    // imgui_internal.h:2496
        .def_readwrite("clip_rect", &ImGuiTableColumn::ClipRect, "Clipping rectangle for the column")    // imgui_internal.h:2497
        .def_readwrite("user_id", &ImGuiTableColumn::UserID, "Optional, value passed to TableSetupColumn()")    // imgui_internal.h:2498
        .def_readwrite("work_min_x", &ImGuiTableColumn::WorkMinX, "Contents region min ~(MinX + CellPaddingX + CellSpacingX1) == cursor start position when entering column")    // imgui_internal.h:2499
        .def_readwrite("work_max_x", &ImGuiTableColumn::WorkMaxX, "Contents region max ~(MaxX - CellPaddingX - CellSpacingX2)")    // imgui_internal.h:2500
        .def_readwrite("item_width", &ImGuiTableColumn::ItemWidth, "Current item width for the column, preserved across rows")    // imgui_internal.h:2501
        .def_readwrite("content_max_x_frozen", &ImGuiTableColumn::ContentMaxXFrozen, "Contents maximum position for frozen rows (apart from headers), from which we can infer content width.")    // imgui_internal.h:2502
        .def_readwrite("content_max_x_unfrozen", &ImGuiTableColumn::ContentMaxXUnfrozen, "")    // imgui_internal.h:2503
        .def_readwrite("content_max_x_headers_used", &ImGuiTableColumn::ContentMaxXHeadersUsed, "Contents maximum position for headers rows (regardless of freezing). TableHeader() automatically softclip itself + report ideal desired size, to avoid creating extraneous draw calls")    // imgui_internal.h:2504
        .def_readwrite("content_max_x_headers_ideal", &ImGuiTableColumn::ContentMaxXHeadersIdeal, "")    // imgui_internal.h:2505
        .def_readwrite("name_offset", &ImGuiTableColumn::NameOffset, "Offset into parent ColumnsNames[]")    // imgui_internal.h:2506
        .def_readwrite("display_order", &ImGuiTableColumn::DisplayOrder, "Index within Table's IndexToDisplayOrder[] (column may be reordered by users)")    // imgui_internal.h:2507
        .def_readwrite("index_within_enabled_set", &ImGuiTableColumn::IndexWithinEnabledSet, "Index within enabled/visible set (<= IndexToDisplayOrder)")    // imgui_internal.h:2508
        .def_readwrite("prev_enabled_column", &ImGuiTableColumn::PrevEnabledColumn, "Index of prev enabled/visible column within Columns[], -1 if first enabled/visible column")    // imgui_internal.h:2509
        .def_readwrite("next_enabled_column", &ImGuiTableColumn::NextEnabledColumn, "Index of next enabled/visible column within Columns[], -1 if last enabled/visible column")    // imgui_internal.h:2510
        .def_readwrite("sort_order", &ImGuiTableColumn::SortOrder, "Index of this column within sort specs, -1 if not sorting on this column, 0 for single-sort, may be >0 on multi-sort")    // imgui_internal.h:2511
        .def_readwrite("draw_channel_current", &ImGuiTableColumn::DrawChannelCurrent, "Index within DrawSplitter.Channels[]")    // imgui_internal.h:2512
        .def_readwrite("draw_channel_frozen", &ImGuiTableColumn::DrawChannelFrozen, "Draw channels for frozen rows (often headers)")    // imgui_internal.h:2513
        .def_readwrite("draw_channel_unfrozen", &ImGuiTableColumn::DrawChannelUnfrozen, "Draw channels for unfrozen rows")    // imgui_internal.h:2514
        .def_readwrite("is_enabled", &ImGuiTableColumn::IsEnabled, "IsUserEnabled && (Flags & ImGuiTableColumnFlags_Disabled) == 0")    // imgui_internal.h:2515
        .def_readwrite("is_user_enabled", &ImGuiTableColumn::IsUserEnabled, "Is the column not marked Hidden by the user? (unrelated to being off view, e.g. clipped by scrolling).")    // imgui_internal.h:2516
        .def_readwrite("is_user_enabled_next_frame", &ImGuiTableColumn::IsUserEnabledNextFrame, "")    // imgui_internal.h:2517
        .def_readwrite("is_visible_x", &ImGuiTableColumn::IsVisibleX, "Is actually in view (e.g. overlapping the host window clipping rectangle, not scrolled).")    // imgui_internal.h:2518
        .def_readwrite("is_visible_y", &ImGuiTableColumn::IsVisibleY, "")    // imgui_internal.h:2519
        .def_readwrite("is_request_output", &ImGuiTableColumn::IsRequestOutput, "Return value for TableSetColumnIndex() / TableNextColumn(): whether we request user to output contents or not.")    // imgui_internal.h:2520
        .def_readwrite("is_skip_items", &ImGuiTableColumn::IsSkipItems, "Do we want item submissions to this column to be completely ignored (no layout will happen).")    // imgui_internal.h:2521
        .def_readwrite("is_preserve_width_auto", &ImGuiTableColumn::IsPreserveWidthAuto, "")    // imgui_internal.h:2522
        .def_readwrite("nav_layer_current", &ImGuiTableColumn::NavLayerCurrent, "ImGuiNavLayer in 1 byte")    // imgui_internal.h:2523
        .def_readwrite("auto_fit_queue", &ImGuiTableColumn::AutoFitQueue, "Queue of 8 values for the next 8 frames to request auto-fit")    // imgui_internal.h:2524
        .def_readwrite("cannot_skip_items_queue", &ImGuiTableColumn::CannotSkipItemsQueue, "Queue of 8 values for the next 8 frames to disable Clipped/SkipItem")    // imgui_internal.h:2525
        .def_readwrite("sort_directions_avail_list", &ImGuiTableColumn::SortDirectionsAvailList, "Ordered of available sort directions (2-bits each)")    // imgui_internal.h:2529
        .def(py::init<>())    // imgui_internal.h:2531
        ;


    auto pyClassImGuiTableCellData =
        py::class_<ImGuiTableCellData>    // imgui_internal.h:2546
            (m, "ImGuiTableCellData", " Transient cell data stored per row.\n sizeof() ~ 6")
        .def(py::init<>([](
        ImU32 BgColor = ImU32(), ImGuiTableColumnIdx Column = ImGuiTableColumnIdx())
        {
            auto r = std::make_unique<ImGuiTableCellData>();
            r->BgColor = BgColor;
            r->Column = Column;
            return r;
        })
        , py::arg("bg_color") = ImU32(), py::arg("column") = ImGuiTableColumnIdx()
        )
        .def_readwrite("bg_color", &ImGuiTableCellData::BgColor, "Actual color")    // imgui_internal.h:2548
        .def_readwrite("column", &ImGuiTableCellData::Column, "Column number")    // imgui_internal.h:2549
        ;


    auto pyClassImGuiTableInstanceData =
        py::class_<ImGuiTableInstanceData>    // imgui_internal.h:2553
            (m, "ImGuiTableInstanceData", "Per-instance data that needs preserving across frames (seemingly most others do not need to be preserved aside from debug needs, does that needs they could be moved to ImGuiTableTempData ?)")
        .def(py::init<>([](
        float LastOuterHeight = float(), float LastFirstRowHeight = float())
        {
            auto r = std::make_unique<ImGuiTableInstanceData>();
            r->LastOuterHeight = LastOuterHeight;
            r->LastFirstRowHeight = LastFirstRowHeight;
            return r;
        })
        , py::arg("last_outer_height") = float(), py::arg("last_first_row_height") = float()
        )
        .def_readwrite("last_outer_height", &ImGuiTableInstanceData::LastOuterHeight, "Outer height from last frame // FIXME: multi-instance issue (#3955)")    // imgui_internal.h:2555
        .def_readwrite("last_first_row_height", &ImGuiTableInstanceData::LastFirstRowHeight, "Height of first row from last frame // FIXME: possible multi-instance issue?")    // imgui_internal.h:2556
        .def(py::init<>())    // imgui_internal.h:2558
        ;


    auto pyClassImGuiTable =
        py::class_<ImGuiTable>    // imgui_internal.h:2562
            (m, "ImGuiTable", "FIXME-TABLE: more transient data could be stored in a per-stacked table structure: DrawSplitter, SortSpecs, incoming RowData")
        .def(py::init<>([](
        ImGuiID ID = ImGuiID(), ImGuiTableFlags Flags = ImGuiTableFlags(), ImU64 EnabledMaskByDisplayOrder = ImU64(), ImU64 EnabledMaskByIndex = ImU64(), ImU64 VisibleMaskByIndex = ImU64(), ImU64 RequestOutputMaskByIndex = ImU64(), ImGuiTableFlags SettingsLoadedFlags = ImGuiTableFlags(), int SettingsOffset = int(), int LastFrameActive = int(), int ColumnsCount = int(), int CurrentRow = int(), int CurrentColumn = int(), ImS16 InstanceCurrent = ImS16(), ImS16 InstanceInteracted = ImS16(), float RowPosY1 = float(), float RowPosY2 = float(), float RowMinHeight = float(), float RowTextBaseline = float(), float RowIndentOffsetX = float(), int RowBgColorCounter = int(), ImU32 BorderColorStrong = ImU32(), ImU32 BorderColorLight = ImU32(), float BorderX1 = float(), float BorderX2 = float(), float HostIndentX = float(), float MinColumnWidth = float(), float OuterPaddingX = float(), float CellPaddingX = float(), float CellPaddingY = float(), float CellSpacingX1 = float(), float CellSpacingX2 = float(), float InnerWidth = float(), float ColumnsGivenWidth = float(), float ColumnsAutoFitWidth = float(), float ColumnsStretchSumWeights = float(), float ResizedColumnNextWidth = float(), float ResizeLockMinContentsX2 = float(), float RefScale = float(), ImRect OuterRect = ImRect(), ImRect InnerRect = ImRect(), ImRect WorkRect = ImRect(), ImRect InnerClipRect = ImRect(), ImRect BgClipRect = ImRect(), ImRect Bg0ClipRectForDrawCmd = ImRect(), ImRect Bg2ClipRectForDrawCmd = ImRect(), ImRect HostClipRect = ImRect(), ImRect HostBackupInnerClipRect = ImRect(), ImGuiTextBuffer ColumnsNames = ImGuiTextBuffer(), ImGuiTableInstanceData InstanceDataFirst = ImGuiTableInstanceData(), ImGuiTableColumnSortSpecs SortSpecsSingle = ImGuiTableColumnSortSpecs(), ImGuiTableSortSpecs SortSpecs = ImGuiTableSortSpecs(), ImGuiTableColumnIdx SortSpecsCount = ImGuiTableColumnIdx(), ImGuiTableColumnIdx ColumnsEnabledCount = ImGuiTableColumnIdx(), ImGuiTableColumnIdx ColumnsEnabledFixedCount = ImGuiTableColumnIdx(), ImGuiTableColumnIdx DeclColumnsCount = ImGuiTableColumnIdx(), ImGuiTableColumnIdx HoveredColumnBody = ImGuiTableColumnIdx(), ImGuiTableColumnIdx HoveredColumnBorder = ImGuiTableColumnIdx(), ImGuiTableColumnIdx AutoFitSingleColumn = ImGuiTableColumnIdx(), ImGuiTableColumnIdx ResizedColumn = ImGuiTableColumnIdx(), ImGuiTableColumnIdx LastResizedColumn = ImGuiTableColumnIdx(), ImGuiTableColumnIdx HeldHeaderColumn = ImGuiTableColumnIdx(), ImGuiTableColumnIdx ReorderColumn = ImGuiTableColumnIdx(), ImGuiTableColumnIdx ReorderColumnDir = ImGuiTableColumnIdx(), ImGuiTableColumnIdx LeftMostEnabledColumn = ImGuiTableColumnIdx(), ImGuiTableColumnIdx RightMostEnabledColumn = ImGuiTableColumnIdx(), ImGuiTableColumnIdx LeftMostStretchedColumn = ImGuiTableColumnIdx(), ImGuiTableColumnIdx RightMostStretchedColumn = ImGuiTableColumnIdx(), ImGuiTableColumnIdx ContextPopupColumn = ImGuiTableColumnIdx(), ImGuiTableColumnIdx FreezeRowsRequest = ImGuiTableColumnIdx(), ImGuiTableColumnIdx FreezeRowsCount = ImGuiTableColumnIdx(), ImGuiTableColumnIdx FreezeColumnsRequest = ImGuiTableColumnIdx(), ImGuiTableColumnIdx FreezeColumnsCount = ImGuiTableColumnIdx(), ImGuiTableColumnIdx RowCellDataCurrent = ImGuiTableColumnIdx(), ImGuiTableDrawChannelIdx DummyDrawChannel = ImGuiTableDrawChannelIdx(), ImGuiTableDrawChannelIdx Bg2DrawChannelCurrent = ImGuiTableDrawChannelIdx(), ImGuiTableDrawChannelIdx Bg2DrawChannelUnfrozen = ImGuiTableDrawChannelIdx(), bool IsLayoutLocked = bool(), bool IsInsideRow = bool(), bool IsInitializing = bool(), bool IsSortSpecsDirty = bool(), bool IsUsingHeaders = bool(), bool IsContextPopupOpen = bool(), bool IsSettingsRequestLoad = bool(), bool IsSettingsDirty = bool(), bool IsDefaultDisplayOrder = bool(), bool IsResetAllRequest = bool(), bool IsResetDisplayOrderRequest = bool(), bool IsUnfrozenRows = bool(), bool IsDefaultSizingPolicy = bool(), bool MemoryCompacted = bool(), bool HostSkipItems = bool())
        {
            auto r = std::make_unique<ImGuiTable>();
            r->ID = ID;
            r->Flags = Flags;
            r->EnabledMaskByDisplayOrder = EnabledMaskByDisplayOrder;
            r->EnabledMaskByIndex = EnabledMaskByIndex;
            r->VisibleMaskByIndex = VisibleMaskByIndex;
            r->RequestOutputMaskByIndex = RequestOutputMaskByIndex;
            r->SettingsLoadedFlags = SettingsLoadedFlags;
            r->SettingsOffset = SettingsOffset;
            r->LastFrameActive = LastFrameActive;
            r->ColumnsCount = ColumnsCount;
            r->CurrentRow = CurrentRow;
            r->CurrentColumn = CurrentColumn;
            r->InstanceCurrent = InstanceCurrent;
            r->InstanceInteracted = InstanceInteracted;
            r->RowPosY1 = RowPosY1;
            r->RowPosY2 = RowPosY2;
            r->RowMinHeight = RowMinHeight;
            r->RowTextBaseline = RowTextBaseline;
            r->RowIndentOffsetX = RowIndentOffsetX;
            r->RowBgColorCounter = RowBgColorCounter;
            r->BorderColorStrong = BorderColorStrong;
            r->BorderColorLight = BorderColorLight;
            r->BorderX1 = BorderX1;
            r->BorderX2 = BorderX2;
            r->HostIndentX = HostIndentX;
            r->MinColumnWidth = MinColumnWidth;
            r->OuterPaddingX = OuterPaddingX;
            r->CellPaddingX = CellPaddingX;
            r->CellPaddingY = CellPaddingY;
            r->CellSpacingX1 = CellSpacingX1;
            r->CellSpacingX2 = CellSpacingX2;
            r->InnerWidth = InnerWidth;
            r->ColumnsGivenWidth = ColumnsGivenWidth;
            r->ColumnsAutoFitWidth = ColumnsAutoFitWidth;
            r->ColumnsStretchSumWeights = ColumnsStretchSumWeights;
            r->ResizedColumnNextWidth = ResizedColumnNextWidth;
            r->ResizeLockMinContentsX2 = ResizeLockMinContentsX2;
            r->RefScale = RefScale;
            r->OuterRect = OuterRect;
            r->InnerRect = InnerRect;
            r->WorkRect = WorkRect;
            r->InnerClipRect = InnerClipRect;
            r->BgClipRect = BgClipRect;
            r->Bg0ClipRectForDrawCmd = Bg0ClipRectForDrawCmd;
            r->Bg2ClipRectForDrawCmd = Bg2ClipRectForDrawCmd;
            r->HostClipRect = HostClipRect;
            r->HostBackupInnerClipRect = HostBackupInnerClipRect;
            r->ColumnsNames = ColumnsNames;
            r->InstanceDataFirst = InstanceDataFirst;
            r->SortSpecsSingle = SortSpecsSingle;
            r->SortSpecs = SortSpecs;
            r->SortSpecsCount = SortSpecsCount;
            r->ColumnsEnabledCount = ColumnsEnabledCount;
            r->ColumnsEnabledFixedCount = ColumnsEnabledFixedCount;
            r->DeclColumnsCount = DeclColumnsCount;
            r->HoveredColumnBody = HoveredColumnBody;
            r->HoveredColumnBorder = HoveredColumnBorder;
            r->AutoFitSingleColumn = AutoFitSingleColumn;
            r->ResizedColumn = ResizedColumn;
            r->LastResizedColumn = LastResizedColumn;
            r->HeldHeaderColumn = HeldHeaderColumn;
            r->ReorderColumn = ReorderColumn;
            r->ReorderColumnDir = ReorderColumnDir;
            r->LeftMostEnabledColumn = LeftMostEnabledColumn;
            r->RightMostEnabledColumn = RightMostEnabledColumn;
            r->LeftMostStretchedColumn = LeftMostStretchedColumn;
            r->RightMostStretchedColumn = RightMostStretchedColumn;
            r->ContextPopupColumn = ContextPopupColumn;
            r->FreezeRowsRequest = FreezeRowsRequest;
            r->FreezeRowsCount = FreezeRowsCount;
            r->FreezeColumnsRequest = FreezeColumnsRequest;
            r->FreezeColumnsCount = FreezeColumnsCount;
            r->RowCellDataCurrent = RowCellDataCurrent;
            r->DummyDrawChannel = DummyDrawChannel;
            r->Bg2DrawChannelCurrent = Bg2DrawChannelCurrent;
            r->Bg2DrawChannelUnfrozen = Bg2DrawChannelUnfrozen;
            r->IsLayoutLocked = IsLayoutLocked;
            r->IsInsideRow = IsInsideRow;
            r->IsInitializing = IsInitializing;
            r->IsSortSpecsDirty = IsSortSpecsDirty;
            r->IsUsingHeaders = IsUsingHeaders;
            r->IsContextPopupOpen = IsContextPopupOpen;
            r->IsSettingsRequestLoad = IsSettingsRequestLoad;
            r->IsSettingsDirty = IsSettingsDirty;
            r->IsDefaultDisplayOrder = IsDefaultDisplayOrder;
            r->IsResetAllRequest = IsResetAllRequest;
            r->IsResetDisplayOrderRequest = IsResetDisplayOrderRequest;
            r->IsUnfrozenRows = IsUnfrozenRows;
            r->IsDefaultSizingPolicy = IsDefaultSizingPolicy;
            r->MemoryCompacted = MemoryCompacted;
            r->HostSkipItems = HostSkipItems;
            return r;
        })
        , py::arg("id") = ImGuiID(), py::arg("flags") = ImGuiTableFlags(), py::arg("enabled_mask_by_display_order") = ImU64(), py::arg("enabled_mask_by_index") = ImU64(), py::arg("visible_mask_by_index") = ImU64(), py::arg("request_output_mask_by_index") = ImU64(), py::arg("settings_loaded_flags") = ImGuiTableFlags(), py::arg("settings_offset") = int(), py::arg("last_frame_active") = int(), py::arg("columns_count") = int(), py::arg("current_row") = int(), py::arg("current_column") = int(), py::arg("instance_current") = ImS16(), py::arg("instance_interacted") = ImS16(), py::arg("row_pos_y1") = float(), py::arg("row_pos_y2") = float(), py::arg("row_min_height") = float(), py::arg("row_text_baseline") = float(), py::arg("row_indent_offset_x") = float(), py::arg("row_bg_color_counter") = int(), py::arg("border_color_strong") = ImU32(), py::arg("border_color_light") = ImU32(), py::arg("border_x1") = float(), py::arg("border_x2") = float(), py::arg("host_indent_x") = float(), py::arg("min_column_width") = float(), py::arg("outer_padding_x") = float(), py::arg("cell_padding_x") = float(), py::arg("cell_padding_y") = float(), py::arg("cell_spacing_x1") = float(), py::arg("cell_spacing_x2") = float(), py::arg("inner_width") = float(), py::arg("columns_given_width") = float(), py::arg("columns_auto_fit_width") = float(), py::arg("columns_stretch_sum_weights") = float(), py::arg("resized_column_next_width") = float(), py::arg("resize_lock_min_contents_x2") = float(), py::arg("ref_scale") = float(), py::arg("outer_rect") = ImRect(), py::arg("inner_rect") = ImRect(), py::arg("work_rect") = ImRect(), py::arg("inner_clip_rect") = ImRect(), py::arg("bg_clip_rect") = ImRect(), py::arg("bg0_clip_rect_for_draw_cmd") = ImRect(), py::arg("bg2_clip_rect_for_draw_cmd") = ImRect(), py::arg("host_clip_rect") = ImRect(), py::arg("host_backup_inner_clip_rect") = ImRect(), py::arg("columns_names") = ImGuiTextBuffer(), py::arg("instance_data_first") = ImGuiTableInstanceData(), py::arg("sort_specs_single") = ImGuiTableColumnSortSpecs(), py::arg("sort_specs") = ImGuiTableSortSpecs(), py::arg("sort_specs_count") = ImGuiTableColumnIdx(), py::arg("columns_enabled_count") = ImGuiTableColumnIdx(), py::arg("columns_enabled_fixed_count") = ImGuiTableColumnIdx(), py::arg("decl_columns_count") = ImGuiTableColumnIdx(), py::arg("hovered_column_body") = ImGuiTableColumnIdx(), py::arg("hovered_column_border") = ImGuiTableColumnIdx(), py::arg("auto_fit_single_column") = ImGuiTableColumnIdx(), py::arg("resized_column") = ImGuiTableColumnIdx(), py::arg("last_resized_column") = ImGuiTableColumnIdx(), py::arg("held_header_column") = ImGuiTableColumnIdx(), py::arg("reorder_column") = ImGuiTableColumnIdx(), py::arg("reorder_column_dir") = ImGuiTableColumnIdx(), py::arg("left_most_enabled_column") = ImGuiTableColumnIdx(), py::arg("right_most_enabled_column") = ImGuiTableColumnIdx(), py::arg("left_most_stretched_column") = ImGuiTableColumnIdx(), py::arg("right_most_stretched_column") = ImGuiTableColumnIdx(), py::arg("context_popup_column") = ImGuiTableColumnIdx(), py::arg("freeze_rows_request") = ImGuiTableColumnIdx(), py::arg("freeze_rows_count") = ImGuiTableColumnIdx(), py::arg("freeze_columns_request") = ImGuiTableColumnIdx(), py::arg("freeze_columns_count") = ImGuiTableColumnIdx(), py::arg("row_cell_data_current") = ImGuiTableColumnIdx(), py::arg("dummy_draw_channel") = ImGuiTableDrawChannelIdx(), py::arg("bg2_draw_channel_current") = ImGuiTableDrawChannelIdx(), py::arg("bg2_draw_channel_unfrozen") = ImGuiTableDrawChannelIdx(), py::arg("is_layout_locked") = bool(), py::arg("is_inside_row") = bool(), py::arg("is_initializing") = bool(), py::arg("is_sort_specs_dirty") = bool(), py::arg("is_using_headers") = bool(), py::arg("is_context_popup_open") = bool(), py::arg("is_settings_request_load") = bool(), py::arg("is_settings_dirty") = bool(), py::arg("is_default_display_order") = bool(), py::arg("is_reset_all_request") = bool(), py::arg("is_reset_display_order_request") = bool(), py::arg("is_unfrozen_rows") = bool(), py::arg("is_default_sizing_policy") = bool(), py::arg("memory_compacted") = bool(), py::arg("host_skip_items") = bool()
        )
        .def_readwrite("id", &ImGuiTable::ID, "")    // imgui_internal.h:2564
        .def_readwrite("flags", &ImGuiTable::Flags, "")    // imgui_internal.h:2565
        .def_readwrite("raw_data", &ImGuiTable::RawData, "Single allocation to hold Columns[], DisplayOrderToIndex[] and RowCellData[]")    // imgui_internal.h:2566
        .def_readwrite("temp_data", &ImGuiTable::TempData, "Transient data while table is active. Point within g.CurrentTableStack[]")    // imgui_internal.h:2567
        .def_readwrite("enabled_mask_by_display_order", &ImGuiTable::EnabledMaskByDisplayOrder, "Column DisplayOrder -> IsEnabled map")    // imgui_internal.h:2571
        .def_readwrite("enabled_mask_by_index", &ImGuiTable::EnabledMaskByIndex, "Column Index -> IsEnabled map (== not hidden by user/api) in a format adequate for iterating column without touching cold data")    // imgui_internal.h:2572
        .def_readwrite("visible_mask_by_index", &ImGuiTable::VisibleMaskByIndex, "Column Index -> IsVisibleX|IsVisibleY map (== not hidden by user/api && not hidden by scrolling/cliprect)")    // imgui_internal.h:2573
        .def_readwrite("request_output_mask_by_index", &ImGuiTable::RequestOutputMaskByIndex, "Column Index -> IsVisible || AutoFit (== expect user to submit items)")    // imgui_internal.h:2574
        .def_readwrite("settings_loaded_flags", &ImGuiTable::SettingsLoadedFlags, "Which data were loaded from the .ini file (e.g. when order is not altered we won't save order)")    // imgui_internal.h:2575
        .def_readwrite("settings_offset", &ImGuiTable::SettingsOffset, "Offset in g.SettingsTables")    // imgui_internal.h:2576
        .def_readwrite("last_frame_active", &ImGuiTable::LastFrameActive, "")    // imgui_internal.h:2577
        .def_readwrite("columns_count", &ImGuiTable::ColumnsCount, "Number of columns declared in BeginTable()")    // imgui_internal.h:2578
        .def_readwrite("current_row", &ImGuiTable::CurrentRow, "")    // imgui_internal.h:2579
        .def_readwrite("current_column", &ImGuiTable::CurrentColumn, "")    // imgui_internal.h:2580
        .def_readwrite("instance_current", &ImGuiTable::InstanceCurrent, "Count of BeginTable() calls with same ID in the same frame (generally 0). This is a little bit similar to BeginCount for a window, but multiple table with same ID look are multiple tables, they are just synched.")    // imgui_internal.h:2581
        .def_readwrite("instance_interacted", &ImGuiTable::InstanceInteracted, "Mark which instance (generally 0) of the same ID is being interacted with")    // imgui_internal.h:2582
        .def_readwrite("row_pos_y1", &ImGuiTable::RowPosY1, "")    // imgui_internal.h:2583
        .def_readwrite("row_pos_y2", &ImGuiTable::RowPosY2, "")    // imgui_internal.h:2584
        .def_readwrite("row_min_height", &ImGuiTable::RowMinHeight, "Height submitted to TableNextRow()")    // imgui_internal.h:2585
        .def_readwrite("row_text_baseline", &ImGuiTable::RowTextBaseline, "")    // imgui_internal.h:2586
        .def_readwrite("row_indent_offset_x", &ImGuiTable::RowIndentOffsetX, "")    // imgui_internal.h:2587
        .def_readwrite("row_bg_color_counter", &ImGuiTable::RowBgColorCounter, "Counter for alternating background colors (can be fast-forwarded by e.g clipper), not same as CurrentRow because header rows typically don't increase this.")    // imgui_internal.h:2590
        .def_property("row_bg_color",    // imgui_internal.h:2591
            [](ImGuiTable &self) -> pybind11::array
            {
                auto dtype = pybind11::dtype(pybind11::format_descriptor<ImU32>::format());
                auto base = pybind11::array(dtype, {2}, {sizeof(ImU32)});
                return pybind11::array(dtype, {2}, {sizeof(ImU32)}, self.RowBgColor, base);
            }, [](ImGuiTable& self) {},
            "Background color override for current row.")
        .def_readwrite("border_color_strong", &ImGuiTable::BorderColorStrong, "")    // imgui_internal.h:2592
        .def_readwrite("border_color_light", &ImGuiTable::BorderColorLight, "")    // imgui_internal.h:2593
        .def_readwrite("border_x1", &ImGuiTable::BorderX1, "")    // imgui_internal.h:2594
        .def_readwrite("border_x2", &ImGuiTable::BorderX2, "")    // imgui_internal.h:2595
        .def_readwrite("host_indent_x", &ImGuiTable::HostIndentX, "")    // imgui_internal.h:2596
        .def_readwrite("min_column_width", &ImGuiTable::MinColumnWidth, "")    // imgui_internal.h:2597
        .def_readwrite("outer_padding_x", &ImGuiTable::OuterPaddingX, "")    // imgui_internal.h:2598
        .def_readwrite("cell_padding_x", &ImGuiTable::CellPaddingX, "Padding from each borders")    // imgui_internal.h:2599
        .def_readwrite("cell_padding_y", &ImGuiTable::CellPaddingY, "")    // imgui_internal.h:2600
        .def_readwrite("cell_spacing_x1", &ImGuiTable::CellSpacingX1, "Spacing between non-bordered cells")    // imgui_internal.h:2601
        .def_readwrite("cell_spacing_x2", &ImGuiTable::CellSpacingX2, "")    // imgui_internal.h:2602
        .def_readwrite("inner_width", &ImGuiTable::InnerWidth, "User value passed to BeginTable(), see comments at the top of BeginTable() for details.")    // imgui_internal.h:2603
        .def_readwrite("columns_given_width", &ImGuiTable::ColumnsGivenWidth, "Sum of current column width")    // imgui_internal.h:2604
        .def_readwrite("columns_auto_fit_width", &ImGuiTable::ColumnsAutoFitWidth, "Sum of ideal column width in order nothing to be clipped, used for auto-fitting and content width submission in outer window")    // imgui_internal.h:2605
        .def_readwrite("columns_stretch_sum_weights", &ImGuiTable::ColumnsStretchSumWeights, "Sum of weight of all enabled stretching columns")    // imgui_internal.h:2606
        .def_readwrite("resized_column_next_width", &ImGuiTable::ResizedColumnNextWidth, "")    // imgui_internal.h:2607
        .def_readwrite("resize_lock_min_contents_x2", &ImGuiTable::ResizeLockMinContentsX2, "Lock minimum contents width while resizing down in order to not create feedback loops. But we allow growing the table.")    // imgui_internal.h:2608
        .def_readwrite("ref_scale", &ImGuiTable::RefScale, "Reference scale to be able to rescale columns on font/dpi changes.")    // imgui_internal.h:2609
        .def_readwrite("outer_rect", &ImGuiTable::OuterRect, "Note: for non-scrolling table, OuterRect.Max.y is often FLT_MAX until EndTable(), unless a height has been specified in BeginTable().")    // imgui_internal.h:2610
        .def_readwrite("inner_rect", &ImGuiTable::InnerRect, "InnerRect but without decoration. As with OuterRect, for non-scrolling tables, InnerRect.Max.y is")    // imgui_internal.h:2611
        .def_readwrite("work_rect", &ImGuiTable::WorkRect, "")    // imgui_internal.h:2612
        .def_readwrite("inner_clip_rect", &ImGuiTable::InnerClipRect, "")    // imgui_internal.h:2613
        .def_readwrite("bg_clip_rect", &ImGuiTable::BgClipRect, "We use this to cpu-clip cell background color fill, evolve during the frame as we cross frozen rows boundaries")    // imgui_internal.h:2614
        .def_readwrite("bg0_clip_rect_for_draw_cmd", &ImGuiTable::Bg0ClipRectForDrawCmd, "Actual ImDrawCmd clip rect for BG0/1 channel. This tends to be == OuterWindow->ClipRect at BeginTable() because output in BG0/BG1 is cpu-clipped")    // imgui_internal.h:2615
        .def_readwrite("bg2_clip_rect_for_draw_cmd", &ImGuiTable::Bg2ClipRectForDrawCmd, "Actual ImDrawCmd clip rect for BG2 channel. This tends to be a correct, tight-fit, because output to BG2 are done by widgets relying on regular ClipRect.")    // imgui_internal.h:2616
        .def_readwrite("host_clip_rect", &ImGuiTable::HostClipRect, "This is used to check if we can eventually merge our columns draw calls into the current draw call of the current window.")    // imgui_internal.h:2617
        .def_readwrite("host_backup_inner_clip_rect", &ImGuiTable::HostBackupInnerClipRect, "Backup of InnerWindow->ClipRect during PushTableBackground()/PopTableBackground()")    // imgui_internal.h:2618
        .def_readwrite("outer_window", &ImGuiTable::OuterWindow, "Parent window for the table")    // imgui_internal.h:2619
        .def_readwrite("inner_window", &ImGuiTable::InnerWindow, "Window holding the table data (== OuterWindow or a child window)")    // imgui_internal.h:2620
        .def_readwrite("columns_names", &ImGuiTable::ColumnsNames, "Contiguous buffer holding columns names")    // imgui_internal.h:2621
        .def_readwrite("draw_splitter", &ImGuiTable::DrawSplitter, "Shortcut to TempData->DrawSplitter while in table. Isolate draw commands per columns to avoid switching clip rect constantly")    // imgui_internal.h:2622
        .def_readwrite("instance_data_first", &ImGuiTable::InstanceDataFirst, "")    // imgui_internal.h:2623
        .def_readwrite("sort_specs_single", &ImGuiTable::SortSpecsSingle, "")    // imgui_internal.h:2625
        .def_readwrite("sort_specs", &ImGuiTable::SortSpecs, "Public facing sorts specs, this is what we return in TableGetSortSpecs()")    // imgui_internal.h:2627
        .def_readwrite("sort_specs_count", &ImGuiTable::SortSpecsCount, "")    // imgui_internal.h:2628
        .def_readwrite("columns_enabled_count", &ImGuiTable::ColumnsEnabledCount, "Number of enabled columns (<= ColumnsCount)")    // imgui_internal.h:2629
        .def_readwrite("columns_enabled_fixed_count", &ImGuiTable::ColumnsEnabledFixedCount, "Number of enabled columns (<= ColumnsCount)")    // imgui_internal.h:2630
        .def_readwrite("decl_columns_count", &ImGuiTable::DeclColumnsCount, "Count calls to TableSetupColumn()")    // imgui_internal.h:2631
        .def_readwrite("hovered_column_body", &ImGuiTable::HoveredColumnBody, "Index of column whose visible region is being hovered. Important: == ColumnsCount when hovering empty region after the right-most column!")    // imgui_internal.h:2632
        .def_readwrite("hovered_column_border", &ImGuiTable::HoveredColumnBorder, "Index of column whose right-border is being hovered (for resizing).")    // imgui_internal.h:2633
        .def_readwrite("auto_fit_single_column", &ImGuiTable::AutoFitSingleColumn, "Index of single column requesting auto-fit.")    // imgui_internal.h:2634
        .def_readwrite("resized_column", &ImGuiTable::ResizedColumn, "Index of column being resized. Reset when InstanceCurrent==0.")    // imgui_internal.h:2635
        .def_readwrite("last_resized_column", &ImGuiTable::LastResizedColumn, "Index of column being resized from previous frame.")    // imgui_internal.h:2636
        .def_readwrite("held_header_column", &ImGuiTable::HeldHeaderColumn, "Index of column header being held.")    // imgui_internal.h:2637
        .def_readwrite("reorder_column", &ImGuiTable::ReorderColumn, "Index of column being reordered. (not cleared)")    // imgui_internal.h:2638
        .def_readwrite("reorder_column_dir", &ImGuiTable::ReorderColumnDir, "-1 or +1")    // imgui_internal.h:2639
        .def_readwrite("left_most_enabled_column", &ImGuiTable::LeftMostEnabledColumn, "Index of left-most non-hidden column.")    // imgui_internal.h:2640
        .def_readwrite("right_most_enabled_column", &ImGuiTable::RightMostEnabledColumn, "Index of right-most non-hidden column.")    // imgui_internal.h:2641
        .def_readwrite("left_most_stretched_column", &ImGuiTable::LeftMostStretchedColumn, "Index of left-most stretched column.")    // imgui_internal.h:2642
        .def_readwrite("right_most_stretched_column", &ImGuiTable::RightMostStretchedColumn, "Index of right-most stretched column.")    // imgui_internal.h:2643
        .def_readwrite("context_popup_column", &ImGuiTable::ContextPopupColumn, "Column right-clicked on, of -1 if opening context menu from a neutral/empty spot")    // imgui_internal.h:2644
        .def_readwrite("freeze_rows_request", &ImGuiTable::FreezeRowsRequest, "Requested frozen rows count")    // imgui_internal.h:2645
        .def_readwrite("freeze_rows_count", &ImGuiTable::FreezeRowsCount, "Actual frozen row count (== FreezeRowsRequest, or == 0 when no scrolling offset)")    // imgui_internal.h:2646
        .def_readwrite("freeze_columns_request", &ImGuiTable::FreezeColumnsRequest, "Requested frozen columns count")    // imgui_internal.h:2647
        .def_readwrite("freeze_columns_count", &ImGuiTable::FreezeColumnsCount, "Actual frozen columns count (== FreezeColumnsRequest, or == 0 when no scrolling offset)")    // imgui_internal.h:2648
        .def_readwrite("row_cell_data_current", &ImGuiTable::RowCellDataCurrent, "Index of current RowCellData[] entry in current row")    // imgui_internal.h:2649
        .def_readwrite("dummy_draw_channel", &ImGuiTable::DummyDrawChannel, "Redirect non-visible columns here.")    // imgui_internal.h:2650
        .def_readwrite("bg2_draw_channel_current", &ImGuiTable::Bg2DrawChannelCurrent, "For Selectable() and other widgets drawing across columns after the freezing line. Index within DrawSplitter.Channels[]")    // imgui_internal.h:2651
        .def_readwrite("bg2_draw_channel_unfrozen", &ImGuiTable::Bg2DrawChannelUnfrozen, "")    // imgui_internal.h:2652
        .def_readwrite("is_layout_locked", &ImGuiTable::IsLayoutLocked, "Set by TableUpdateLayout() which is called when beginning the first row.")    // imgui_internal.h:2653
        .def_readwrite("is_inside_row", &ImGuiTable::IsInsideRow, "Set when inside TableBeginRow()/TableEndRow().")    // imgui_internal.h:2654
        .def_readwrite("is_initializing", &ImGuiTable::IsInitializing, "")    // imgui_internal.h:2655
        .def_readwrite("is_sort_specs_dirty", &ImGuiTable::IsSortSpecsDirty, "")    // imgui_internal.h:2656
        .def_readwrite("is_using_headers", &ImGuiTable::IsUsingHeaders, "Set when the first row had the ImGuiTableRowFlags_Headers flag.")    // imgui_internal.h:2657
        .def_readwrite("is_context_popup_open", &ImGuiTable::IsContextPopupOpen, "Set when default context menu is open (also see: ContextPopupColumn, InstanceInteracted).")    // imgui_internal.h:2658
        .def_readwrite("is_settings_request_load", &ImGuiTable::IsSettingsRequestLoad, "")    // imgui_internal.h:2659
        .def_readwrite("is_settings_dirty", &ImGuiTable::IsSettingsDirty, "Set when table settings have changed and needs to be reported into ImGuiTableSetttings data.")    // imgui_internal.h:2660
        .def_readwrite("is_default_display_order", &ImGuiTable::IsDefaultDisplayOrder, "Set when display order is unchanged from default (DisplayOrder contains 0...Count-1)")    // imgui_internal.h:2661
        .def_readwrite("is_reset_all_request", &ImGuiTable::IsResetAllRequest, "")    // imgui_internal.h:2662
        .def_readwrite("is_reset_display_order_request", &ImGuiTable::IsResetDisplayOrderRequest, "")    // imgui_internal.h:2663
        .def_readwrite("is_unfrozen_rows", &ImGuiTable::IsUnfrozenRows, "Set when we got past the frozen row.")    // imgui_internal.h:2664
        .def_readwrite("is_default_sizing_policy", &ImGuiTable::IsDefaultSizingPolicy, "Set if user didn't explicitly set a sizing policy in BeginTable()")    // imgui_internal.h:2665
        .def_readwrite("memory_compacted", &ImGuiTable::MemoryCompacted, "")    // imgui_internal.h:2666
        .def_readwrite("host_skip_items", &ImGuiTable::HostSkipItems, "Backup of InnerWindow->SkipItem at the end of BeginTable(), because we will overwrite InnerWindow->SkipItem on a per-column basis")    // imgui_internal.h:2667
        .def(py::init<>())    // imgui_internal.h:2669
        ;


    auto pyClassImGuiTableTempData =
        py::class_<ImGuiTableTempData>    // imgui_internal.h:2676
            (m, "ImGuiTableTempData", " Transient data that are only needed between BeginTable() and EndTable(), those buffers are shared (1 per level of stacked table).\n - Accessing those requires chasing an extra pointer so for very frequently used data we leave them in the main table structure.\n - We also leave out of this structure data that tend to be particularly useful for debugging/metrics.")
        .def(py::init<>([](
        int TableIndex = int(), float LastTimeActive = float(), ImVec2 UserOuterSize = ImVec2(), ImDrawListSplitter DrawSplitter = ImDrawListSplitter(), ImRect HostBackupWorkRect = ImRect(), ImRect HostBackupParentWorkRect = ImRect(), ImVec2 HostBackupPrevLineSize = ImVec2(), ImVec2 HostBackupCurrLineSize = ImVec2(), ImVec2 HostBackupCursorMaxPos = ImVec2(), ImVec1 HostBackupColumnsOffset = ImVec1(), float HostBackupItemWidth = float(), int HostBackupItemWidthStackSize = int())
        {
            auto r = std::make_unique<ImGuiTableTempData>();
            r->TableIndex = TableIndex;
            r->LastTimeActive = LastTimeActive;
            r->UserOuterSize = UserOuterSize;
            r->DrawSplitter = DrawSplitter;
            r->HostBackupWorkRect = HostBackupWorkRect;
            r->HostBackupParentWorkRect = HostBackupParentWorkRect;
            r->HostBackupPrevLineSize = HostBackupPrevLineSize;
            r->HostBackupCurrLineSize = HostBackupCurrLineSize;
            r->HostBackupCursorMaxPos = HostBackupCursorMaxPos;
            r->HostBackupColumnsOffset = HostBackupColumnsOffset;
            r->HostBackupItemWidth = HostBackupItemWidth;
            r->HostBackupItemWidthStackSize = HostBackupItemWidthStackSize;
            return r;
        })
        , py::arg("table_index") = int(), py::arg("last_time_active") = float(), py::arg("user_outer_size") = ImVec2(), py::arg("draw_splitter") = ImDrawListSplitter(), py::arg("host_backup_work_rect") = ImRect(), py::arg("host_backup_parent_work_rect") = ImRect(), py::arg("host_backup_prev_line_size") = ImVec2(), py::arg("host_backup_curr_line_size") = ImVec2(), py::arg("host_backup_cursor_max_pos") = ImVec2(), py::arg("host_backup_columns_offset") = ImVec1(), py::arg("host_backup_item_width") = float(), py::arg("host_backup_item_width_stack_size") = int()
        )
        .def_readwrite("table_index", &ImGuiTableTempData::TableIndex, "Index in g.Tables.Buf[] pool")    // imgui_internal.h:2678
        .def_readwrite("last_time_active", &ImGuiTableTempData::LastTimeActive, "Last timestamp this structure was used")    // imgui_internal.h:2679
        .def_readwrite("user_outer_size", &ImGuiTableTempData::UserOuterSize, "outer_size.x passed to BeginTable()")    // imgui_internal.h:2681
        .def_readwrite("draw_splitter", &ImGuiTableTempData::DrawSplitter, "")    // imgui_internal.h:2682
        .def_readwrite("host_backup_work_rect", &ImGuiTableTempData::HostBackupWorkRect, "Backup of InnerWindow->WorkRect at the end of BeginTable()")    // imgui_internal.h:2684
        .def_readwrite("host_backup_parent_work_rect", &ImGuiTableTempData::HostBackupParentWorkRect, "Backup of InnerWindow->ParentWorkRect at the end of BeginTable()")    // imgui_internal.h:2685
        .def_readwrite("host_backup_prev_line_size", &ImGuiTableTempData::HostBackupPrevLineSize, "Backup of InnerWindow->DC.PrevLineSize at the end of BeginTable()")    // imgui_internal.h:2686
        .def_readwrite("host_backup_curr_line_size", &ImGuiTableTempData::HostBackupCurrLineSize, "Backup of InnerWindow->DC.CurrLineSize at the end of BeginTable()")    // imgui_internal.h:2687
        .def_readwrite("host_backup_cursor_max_pos", &ImGuiTableTempData::HostBackupCursorMaxPos, "Backup of InnerWindow->DC.CursorMaxPos at the end of BeginTable()")    // imgui_internal.h:2688
        .def_readwrite("host_backup_columns_offset", &ImGuiTableTempData::HostBackupColumnsOffset, "Backup of OuterWindow->DC.ColumnsOffset at the end of BeginTable()")    // imgui_internal.h:2689
        .def_readwrite("host_backup_item_width", &ImGuiTableTempData::HostBackupItemWidth, "Backup of OuterWindow->DC.ItemWidth at the end of BeginTable()")    // imgui_internal.h:2690
        .def_readwrite("host_backup_item_width_stack_size", &ImGuiTableTempData::HostBackupItemWidthStackSize, "Backup of OuterWindow->DC.ItemWidthStack.Size at the end of BeginTable()")    // imgui_internal.h:2691
        .def(py::init<>())    // imgui_internal.h:2693
        ;


    auto pyClassImGuiTableColumnSettings =
        py::class_<ImGuiTableColumnSettings>    // imgui_internal.h:2697
            (m, "ImGuiTableColumnSettings", "sizeof() ~ 12")
        .def(py::init<>([](
        float WidthOrWeight = float(), ImGuiID UserID = ImGuiID(), ImGuiTableColumnIdx Index = ImGuiTableColumnIdx(), ImGuiTableColumnIdx DisplayOrder = ImGuiTableColumnIdx(), ImGuiTableColumnIdx SortOrder = ImGuiTableColumnIdx())
        {
            auto r = std::make_unique<ImGuiTableColumnSettings>();
            r->WidthOrWeight = WidthOrWeight;
            r->UserID = UserID;
            r->Index = Index;
            r->DisplayOrder = DisplayOrder;
            r->SortOrder = SortOrder;
            return r;
        })
        , py::arg("width_or_weight") = float(), py::arg("user_id") = ImGuiID(), py::arg("index") = ImGuiTableColumnIdx(), py::arg("display_order") = ImGuiTableColumnIdx(), py::arg("sort_order") = ImGuiTableColumnIdx()
        )
        .def_readwrite("width_or_weight", &ImGuiTableColumnSettings::WidthOrWeight, "")    // imgui_internal.h:2699
        .def_readwrite("user_id", &ImGuiTableColumnSettings::UserID, "")    // imgui_internal.h:2700
        .def_readwrite("index", &ImGuiTableColumnSettings::Index, "")    // imgui_internal.h:2701
        .def_readwrite("display_order", &ImGuiTableColumnSettings::DisplayOrder, "")    // imgui_internal.h:2702
        .def_readwrite("sort_order", &ImGuiTableColumnSettings::SortOrder, "")    // imgui_internal.h:2703
        .def(py::init<>())    // imgui_internal.h:2708
        ;


    auto pyClassImGuiTableSettings =
        py::class_<ImGuiTableSettings>    // imgui_internal.h:2721
            (m, "ImGuiTableSettings", "This is designed to be stored in a single ImChunkStream (1 header followed by N ImGuiTableColumnSettings, etc.)")
        .def(py::init<>([](
        ImGuiID ID = ImGuiID(), ImGuiTableFlags SaveFlags = ImGuiTableFlags(), float RefScale = float(), ImGuiTableColumnIdx ColumnsCount = ImGuiTableColumnIdx(), ImGuiTableColumnIdx ColumnsCountMax = ImGuiTableColumnIdx(), bool WantApply = bool())
        {
            auto r = std::make_unique<ImGuiTableSettings>();
            r->ID = ID;
            r->SaveFlags = SaveFlags;
            r->RefScale = RefScale;
            r->ColumnsCount = ColumnsCount;
            r->ColumnsCountMax = ColumnsCountMax;
            r->WantApply = WantApply;
            return r;
        })
        , py::arg("id") = ImGuiID(), py::arg("save_flags") = ImGuiTableFlags(), py::arg("ref_scale") = float(), py::arg("columns_count") = ImGuiTableColumnIdx(), py::arg("columns_count_max") = ImGuiTableColumnIdx(), py::arg("want_apply") = bool()
        )
        .def_readwrite("id", &ImGuiTableSettings::ID, "Set to 0 to invalidate/delete the setting")    // imgui_internal.h:2723
        .def_readwrite("save_flags", &ImGuiTableSettings::SaveFlags, "Indicate data we want to save using the Resizable/Reorderable/Sortable/Hideable flags (could be using its own flags..)")    // imgui_internal.h:2724
        .def_readwrite("ref_scale", &ImGuiTableSettings::RefScale, "Reference scale to be able to rescale columns on font/dpi changes.")    // imgui_internal.h:2725
        .def_readwrite("columns_count", &ImGuiTableSettings::ColumnsCount, "")    // imgui_internal.h:2726
        .def_readwrite("columns_count_max", &ImGuiTableSettings::ColumnsCountMax, "Maximum number of columns this settings instance can store, we can recycle a settings instance with lower number of columns but not higher")    // imgui_internal.h:2727
        .def_readwrite("want_apply", &ImGuiTableSettings::WantApply, "Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)")    // imgui_internal.h:2728
        .def(py::init<>())    // imgui_internal.h:2730
        ;


    m.def("find_window_by_id",    // imgui_internal.h:2748
        ImGui::FindWindowByID,
        py::arg("id"),
        pybind11::return_value_policy::reference);

    m.def("find_window_by_name",    // imgui_internal.h:2749
        ImGui::FindWindowByName,
        py::arg("name"),
        pybind11::return_value_policy::reference);

    m.def("update_window_parent_and_root_links",    // imgui_internal.h:2750
        ImGui::UpdateWindowParentAndRootLinks, py::arg("window"), py::arg("flags"), py::arg("parent_window"));

    m.def("calc_window_next_auto_fit_size",    // imgui_internal.h:2751
        ImGui::CalcWindowNextAutoFitSize, py::arg("window"));

    m.def("is_window_child_of",    // imgui_internal.h:2752
        ImGui::IsWindowChildOf, py::arg("window"), py::arg("potential_parent"), py::arg("popup_hierarchy"), py::arg("dock_hierarchy"));

    m.def("is_window_within_begin_stack_of",    // imgui_internal.h:2753
        ImGui::IsWindowWithinBeginStackOf, py::arg("window"), py::arg("potential_parent"));

    m.def("is_window_above",    // imgui_internal.h:2754
        ImGui::IsWindowAbove, py::arg("potential_above"), py::arg("potential_below"));

    m.def("is_window_nav_focusable",    // imgui_internal.h:2755
        ImGui::IsWindowNavFocusable, py::arg("window"));

    m.def("set_window_pos",    // imgui_internal.h:2756
        py::overload_cast<ImGuiWindow *, const ImVec2 &, ImGuiCond>(ImGui::SetWindowPos), py::arg("window"), py::arg("pos"), py::arg("cond") = 0);

    m.def("set_window_size",    // imgui_internal.h:2757
        py::overload_cast<ImGuiWindow *, const ImVec2 &, ImGuiCond>(ImGui::SetWindowSize), py::arg("window"), py::arg("size"), py::arg("cond") = 0);

    m.def("set_window_collapsed",    // imgui_internal.h:2758
        py::overload_cast<ImGuiWindow *, bool, ImGuiCond>(ImGui::SetWindowCollapsed), py::arg("window"), py::arg("collapsed"), py::arg("cond") = 0);

    m.def("set_window_hit_test_hole",    // imgui_internal.h:2759
        ImGui::SetWindowHitTestHole, py::arg("window"), py::arg("pos"), py::arg("size"));

    m.def("focus_window",    // imgui_internal.h:2764
        ImGui::FocusWindow, py::arg("window"));

    m.def("focus_top_most_window_under_one",    // imgui_internal.h:2765
        ImGui::FocusTopMostWindowUnderOne, py::arg("under_this_window"), py::arg("ignore_window"));

    m.def("bring_window_to_focus_front",    // imgui_internal.h:2766
        ImGui::BringWindowToFocusFront, py::arg("window"));

    m.def("bring_window_to_display_front",    // imgui_internal.h:2767
        ImGui::BringWindowToDisplayFront, py::arg("window"));

    m.def("bring_window_to_display_back",    // imgui_internal.h:2768
        ImGui::BringWindowToDisplayBack, py::arg("window"));

    m.def("bring_window_to_display_behind",    // imgui_internal.h:2769
        ImGui::BringWindowToDisplayBehind, py::arg("window"), py::arg("above_window"));

    m.def("find_window_display_index",    // imgui_internal.h:2770
        ImGui::FindWindowDisplayIndex, py::arg("window"));

    m.def("find_bottom_most_visible_window_within_begin_stack",    // imgui_internal.h:2771
        ImGui::FindBottomMostVisibleWindowWithinBeginStack,
        py::arg("window"),
        pybind11::return_value_policy::reference);

    m.def("set_current_font",    // imgui_internal.h:2774
        ImGui::SetCurrentFont,
        py::arg("font"),
        "Fonts, drawing");

    m.def("initialize",    // imgui_internal.h:2779
        ImGui::Initialize);

    m.def("shutdown",    // imgui_internal.h:2780
        ImGui::Shutdown, "Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().");

    m.def("update_input_events",    // imgui_internal.h:2783
        ImGui::UpdateInputEvents, py::arg("trickle_fast_inputs"));

    m.def("update_hovered_window_and_capture_flags",    // imgui_internal.h:2784
        ImGui::UpdateHoveredWindowAndCaptureFlags);

    m.def("start_mouse_moving_window",    // imgui_internal.h:2785
        ImGui::StartMouseMovingWindow, py::arg("window"));

    m.def("start_mouse_moving_window_or_node",    // imgui_internal.h:2786
        ImGui::StartMouseMovingWindowOrNode, py::arg("window"), py::arg("node"), py::arg("undock_floating_node"));

    m.def("update_mouse_moving_window_new_frame",    // imgui_internal.h:2787
        ImGui::UpdateMouseMovingWindowNewFrame);

    m.def("update_mouse_moving_window_end_frame",    // imgui_internal.h:2788
        ImGui::UpdateMouseMovingWindowEndFrame);

    m.def("add_context_hook",    // imgui_internal.h:2791
        ImGui::AddContextHook, py::arg("context"), py::arg("hook"));

    m.def("remove_context_hook",    // imgui_internal.h:2792
        ImGui::RemoveContextHook, py::arg("context"), py::arg("hook_to_remove"));

    m.def("call_context_hooks",    // imgui_internal.h:2793
        ImGui::CallContextHooks, py::arg("context"), py::arg("type"));

    m.def("translate_windows_in_viewport",    // imgui_internal.h:2796
        ImGui::TranslateWindowsInViewport, py::arg("viewport"), py::arg("old_pos"), py::arg("new_pos"));

    m.def("scale_windows_in_viewport",    // imgui_internal.h:2797
        ImGui::ScaleWindowsInViewport, py::arg("viewport"), py::arg("scale"));

    m.def("destroy_platform_window",    // imgui_internal.h:2798
        ImGui::DestroyPlatformWindow, py::arg("viewport"));

    m.def("set_window_viewport",    // imgui_internal.h:2799
        ImGui::SetWindowViewport, py::arg("window"), py::arg("viewport"));

    m.def("set_current_viewport",    // imgui_internal.h:2800
        ImGui::SetCurrentViewport, py::arg("window"), py::arg("viewport"));

    m.def("get_viewport_platform_monitor",    // imgui_internal.h:2801
        ImGui::GetViewportPlatformMonitor,
        py::arg("viewport"),
        pybind11::return_value_policy::reference);

    m.def("find_hovered_viewport_from_platform_window_stack",    // imgui_internal.h:2802
        ImGui::FindHoveredViewportFromPlatformWindowStack,
        py::arg("mouse_platform_pos"),
        pybind11::return_value_policy::reference);

    m.def("mark_ini_settings_dirty",    // imgui_internal.h:2805
        py::overload_cast<>(ImGui::MarkIniSettingsDirty));

    m.def("mark_ini_settings_dirty",    // imgui_internal.h:2806
        py::overload_cast<ImGuiWindow *>(ImGui::MarkIniSettingsDirty), py::arg("window"));

    m.def("clear_ini_settings",    // imgui_internal.h:2807
        ImGui::ClearIniSettings);

    m.def("create_new_window_settings",    // imgui_internal.h:2808
        ImGui::CreateNewWindowSettings,
        py::arg("name"),
        pybind11::return_value_policy::reference);

    m.def("find_window_settings",    // imgui_internal.h:2809
        ImGui::FindWindowSettings,
        py::arg("id"),
        pybind11::return_value_policy::reference);

    m.def("find_or_create_window_settings",    // imgui_internal.h:2810
        ImGui::FindOrCreateWindowSettings,
        py::arg("name"),
        pybind11::return_value_policy::reference);

    m.def("add_settings_handler",    // imgui_internal.h:2811
        ImGui::AddSettingsHandler, py::arg("handler"));

    m.def("remove_settings_handler",    // imgui_internal.h:2812
        ImGui::RemoveSettingsHandler, py::arg("type_name"));

    m.def("find_settings_handler",    // imgui_internal.h:2813
        ImGui::FindSettingsHandler,
        py::arg("type_name"),
        pybind11::return_value_policy::reference);

    m.def("set_next_window_scroll",    // imgui_internal.h:2816
        ImGui::SetNextWindowScroll,
        py::arg("scroll"),
        "Use -1.0 on one axis to leave as-is");

    m.def("set_scroll_x",    // imgui_internal.h:2817
        py::overload_cast<ImGuiWindow *, float>(ImGui::SetScrollX), py::arg("window"), py::arg("scroll_x"));

    m.def("set_scroll_y",    // imgui_internal.h:2818
        py::overload_cast<ImGuiWindow *, float>(ImGui::SetScrollY), py::arg("window"), py::arg("scroll_y"));

    m.def("set_scroll_from_pos_x",    // imgui_internal.h:2819
        py::overload_cast<ImGuiWindow *, float, float>(ImGui::SetScrollFromPosX), py::arg("window"), py::arg("local_x"), py::arg("center_x_ratio"));

    m.def("set_scroll_from_pos_y",    // imgui_internal.h:2820
        py::overload_cast<ImGuiWindow *, float, float>(ImGui::SetScrollFromPosY), py::arg("window"), py::arg("local_y"), py::arg("center_y_ratio"));

    m.def("scroll_to_item",    // imgui_internal.h:2823
        ImGui::ScrollToItem, py::arg("flags") = 0);

    m.def("scroll_to_rect",    // imgui_internal.h:2824
        ImGui::ScrollToRect, py::arg("window"), py::arg("rect"), py::arg("flags") = 0);

    m.def("scroll_to_rect_ex",    // imgui_internal.h:2825
        ImGui::ScrollToRectEx, py::arg("window"), py::arg("rect"), py::arg("flags") = 0);

    m.def("set_active_id",    // imgui_internal.h:2836
        ImGui::SetActiveID, py::arg("id"), py::arg("window"));

    m.def("set_focus_id",    // imgui_internal.h:2837
        ImGui::SetFocusID, py::arg("id"), py::arg("window"));

    m.def("clear_active_id",    // imgui_internal.h:2838
        ImGui::ClearActiveID);

    m.def("get_hovered_id",    // imgui_internal.h:2839
        ImGui::GetHoveredID);

    m.def("set_hovered_id",    // imgui_internal.h:2840
        ImGui::SetHoveredID, py::arg("id"));

    m.def("keep_alive_id",    // imgui_internal.h:2841
        ImGui::KeepAliveID, py::arg("id"));

    m.def("mark_item_edited",    // imgui_internal.h:2842
        ImGui::MarkItemEdited,
        py::arg("id"),
        "Mark data associated to given item as \"edited\", used by IsItemDeactivatedAfterEdit() function.");

    m.def("push_override_id",    // imgui_internal.h:2843
        ImGui::PushOverrideID,
        py::arg("id"),
        "Push given value as-is at the top of the ID stack (whereas PushID combines old and new hashes)");

    m.def("get_id_with_seed",    // imgui_internal.h:2844
        ImGui::GetIDWithSeed, py::arg("str_id_begin"), py::arg("str_id_end"), py::arg("seed"));

    m.def("item_size",    // imgui_internal.h:2847
        py::overload_cast<const ImVec2 &, float>(ImGui::ItemSize),
        py::arg("size"), py::arg("text_baseline_y") = -1.0f,
        "Basic Helpers for widget code");

    m.def("item_add",    // imgui_internal.h:2849
        ImGui::ItemAdd, py::arg("bb"), py::arg("id"), py::arg("nav_bb") = py::none(), py::arg("extra_flags") = 0);

    m.def("item_hoverable",    // imgui_internal.h:2850
        ImGui::ItemHoverable, py::arg("bb"), py::arg("id"));

    m.def("is_clipped_ex",    // imgui_internal.h:2851
        ImGui::IsClippedEx, py::arg("bb"), py::arg("id"));

    m.def("set_last_item_data",    // imgui_internal.h:2852
        ImGui::SetLastItemData, py::arg("item_id"), py::arg("in_flags"), py::arg("status_flags"), py::arg("item_rect"));

    m.def("calc_item_size",    // imgui_internal.h:2853
        ImGui::CalcItemSize, py::arg("size"), py::arg("default_w"), py::arg("default_h"));

    m.def("calc_wrap_width_for_pos",    // imgui_internal.h:2854
        ImGui::CalcWrapWidthForPos, py::arg("pos"), py::arg("wrap_pos_x"));

    m.def("push_multi_items_widths",    // imgui_internal.h:2855
        ImGui::PushMultiItemsWidths, py::arg("components"), py::arg("width_full"));

    m.def("is_item_toggled_selection",    // imgui_internal.h:2856
        ImGui::IsItemToggledSelection, "Was the last item selection toggled? (after Selectable(), TreeNode() etc. We only returns toggle _event_ in order to handle clipping correctly)");

    m.def("get_content_region_max_abs",    // imgui_internal.h:2857
        ImGui::GetContentRegionMaxAbs);

    m.def("shrink_widths",    // imgui_internal.h:2858
        ImGui::ShrinkWidths, py::arg("items"), py::arg("count"), py::arg("width_excess"));

    m.def("push_item_flag",    // imgui_internal.h:2861
        ImGui::PushItemFlag, py::arg("option"), py::arg("enabled"));

    m.def("pop_item_flag",    // imgui_internal.h:2862
        ImGui::PopItemFlag);

    m.def("log_begin",    // imgui_internal.h:2876
        ImGui::LogBegin,
        py::arg("type"), py::arg("auto_open_depth"),
        "-> BeginCapture() when we design v2 api, for now stay under the radar by using the old name.");

    m.def("log_to_buffer",    // imgui_internal.h:2877
        ImGui::LogToBuffer,
        py::arg("auto_open_depth") = -1,
        "Start logging/capturing to internal buffer");

    m.def("log_rendered_text",    // imgui_internal.h:2878
        ImGui::LogRenderedText, py::arg("ref_pos"), py::arg("text"), py::arg("text_end") = py::none());

    m.def("log_set_next_text_decoration",    // imgui_internal.h:2879
        ImGui::LogSetNextTextDecoration, py::arg("prefix"), py::arg("suffix"));

    m.def("begin_child_ex",    // imgui_internal.h:2882
        ImGui::BeginChildEx, py::arg("name"), py::arg("id"), py::arg("size_arg"), py::arg("border"), py::arg("flags"));

    m.def("open_popup_ex",    // imgui_internal.h:2883
        py::overload_cast<ImGuiID, ImGuiPopupFlags>(ImGui::OpenPopupEx), py::arg("id"), py::arg("popup_flags") = ImGuiPopupFlags_None);

    m.def("close_popup_to_level",    // imgui_internal.h:2884
        py::overload_cast<int, bool>(ImGui::ClosePopupToLevel), py::arg("remaining"), py::arg("restore_focus_to_window_under_popup"));

    m.def("close_popups_over_window",    // imgui_internal.h:2885
        py::overload_cast<ImGuiWindow *, bool>(ImGui::ClosePopupsOverWindow), py::arg("ref_window"), py::arg("restore_focus_to_window_under_popup"));

    m.def("close_popups_except_modals",    // imgui_internal.h:2886
        py::overload_cast<>(ImGui::ClosePopupsExceptModals));

    m.def("is_popup_open",    // imgui_internal.h:2887
        py::overload_cast<ImGuiID, ImGuiPopupFlags>(ImGui::IsPopupOpen), py::arg("id"), py::arg("popup_flags"));

    m.def("begin_popup_ex",    // imgui_internal.h:2888
        py::overload_cast<ImGuiID, ImGuiWindowFlags>(ImGui::BeginPopupEx), py::arg("id"), py::arg("extra_flags"));

    m.def("begin_tooltip_ex",    // imgui_internal.h:2889
        ImGui::BeginTooltipEx, py::arg("tooltip_flags"), py::arg("extra_window_flags"));

    m.def("get_popup_allowed_extent_rect",    // imgui_internal.h:2890
        py::overload_cast<ImGuiWindow *>(ImGui::GetPopupAllowedExtentRect), py::arg("window"));

    m.def("get_top_most_popup_modal",    // imgui_internal.h:2891
        py::overload_cast<>(ImGui::GetTopMostPopupModal), pybind11::return_value_policy::reference);

    m.def("get_top_most_and_visible_popup_modal",    // imgui_internal.h:2892
        py::overload_cast<>(ImGui::GetTopMostAndVisiblePopupModal), pybind11::return_value_policy::reference);

    m.def("find_best_window_pos_for_popup",    // imgui_internal.h:2893
        py::overload_cast<ImGuiWindow *>(ImGui::FindBestWindowPosForPopup), py::arg("window"));

    m.def("find_best_window_pos_for_popup_ex",    // imgui_internal.h:2894
        py::overload_cast<const ImVec2 &, const ImVec2 &, ImGuiDir *, const ImRect &, const ImRect &, ImGuiPopupPositionPolicy>(ImGui::FindBestWindowPosForPopupEx), py::arg("ref_pos"), py::arg("size"), py::arg("last_dir"), py::arg("r_outer"), py::arg("r_avoid"), py::arg("policy"));

    m.def("begin_viewport_side_bar",    // imgui_internal.h:2897
        ImGui::BeginViewportSideBar, py::arg("name"), py::arg("viewport"), py::arg("dir"), py::arg("size"), py::arg("window_flags"));

    m.def("begin_menu_ex",    // imgui_internal.h:2898
        ImGui::BeginMenuEx, py::arg("label"), py::arg("icon"), py::arg("enabled") = true);

    m.def("menu_item_ex",    // imgui_internal.h:2899
        ImGui::MenuItemEx, py::arg("label"), py::arg("icon"), py::arg("shortcut") = py::none(), py::arg("selected") = false, py::arg("enabled") = true);

    m.def("begin_combo_popup",    // imgui_internal.h:2902
        py::overload_cast<ImGuiID, const ImRect &, ImGuiComboFlags>(ImGui::BeginComboPopup), py::arg("popup_id"), py::arg("bb"), py::arg("flags"));

    m.def("begin_combo_preview",    // imgui_internal.h:2903
        ImGui::BeginComboPreview);

    m.def("end_combo_preview",    // imgui_internal.h:2904
        ImGui::EndComboPreview);

    m.def("nav_init_window",    // imgui_internal.h:2907
        ImGui::NavInitWindow, py::arg("window"), py::arg("force_reinit"));

    m.def("nav_init_request_apply_result",    // imgui_internal.h:2908
        ImGui::NavInitRequestApplyResult);

    m.def("nav_move_request_but_no_result_yet",    // imgui_internal.h:2909
        ImGui::NavMoveRequestButNoResultYet);

    m.def("nav_move_request_submit",    // imgui_internal.h:2910
        ImGui::NavMoveRequestSubmit, py::arg("move_dir"), py::arg("clip_dir"), py::arg("move_flags"), py::arg("scroll_flags"));

    m.def("nav_move_request_forward",    // imgui_internal.h:2911
        ImGui::NavMoveRequestForward, py::arg("move_dir"), py::arg("clip_dir"), py::arg("move_flags"), py::arg("scroll_flags"));

    m.def("nav_move_request_resolve_with_last_item",    // imgui_internal.h:2912
        ImGui::NavMoveRequestResolveWithLastItem, py::arg("result"));

    m.def("nav_move_request_cancel",    // imgui_internal.h:2913
        ImGui::NavMoveRequestCancel);

    m.def("nav_move_request_apply_result",    // imgui_internal.h:2914
        ImGui::NavMoveRequestApplyResult);

    m.def("nav_move_request_try_wrapping",    // imgui_internal.h:2915
        ImGui::NavMoveRequestTryWrapping, py::arg("window"), py::arg("move_flags"));

    m.def("get_nav_input_name",    // imgui_internal.h:2916
        ImGui::GetNavInputName,
        py::arg("n"),
        pybind11::return_value_policy::reference);

    m.def("get_nav_input_amount",    // imgui_internal.h:2917
        ImGui::GetNavInputAmount, py::arg("n"), py::arg("mode"));

    m.def("get_nav_input_amount2d",    // imgui_internal.h:2918
        ImGui::GetNavInputAmount2d, py::arg("dir_sources"), py::arg("mode"), py::arg("slow_factor") = 0.0f, py::arg("fast_factor") = 0.0f);

    m.def("calc_typematic_repeat_amount",    // imgui_internal.h:2919
        ImGui::CalcTypematicRepeatAmount, py::arg("t0"), py::arg("t1"), py::arg("repeat_delay"), py::arg("repeat_rate"));

    m.def("activate_item",    // imgui_internal.h:2920
        ImGui::ActivateItem,
        py::arg("id"),
        "Remotely activate a button, checkbox, tree node etc. given its unique ID. activation is queued and processed on the next frame when the item is encountered again.");

    m.def("set_nav_window",    // imgui_internal.h:2921
        ImGui::SetNavWindow, py::arg("window"));

    m.def("set_nav_id",    // imgui_internal.h:2922
        ImGui::SetNavID, py::arg("id"), py::arg("nav_layer"), py::arg("focus_scope_id"), py::arg("rect_rel"));

    m.def("push_focus_scope",    // imgui_internal.h:2927
        ImGui::PushFocusScope, py::arg("id"));

    m.def("pop_focus_scope",    // imgui_internal.h:2928
        ImGui::PopFocusScope);

    m.def("get_key_data",    // imgui_internal.h:2937
        ImGui::GetKeyData,
        py::arg("key"),
        pybind11::return_value_policy::reference);

    m.def("set_item_using_mouse_wheel",    // imgui_internal.h:2938
        ImGui::SetItemUsingMouseWheel);

    m.def("set_active_id_using_nav_and_keys",    // imgui_internal.h:2939
        ImGui::SetActiveIdUsingNavAndKeys);

    m.def("is_mouse_drag_past_threshold",    // imgui_internal.h:2944
        ImGui::IsMouseDragPastThreshold, py::arg("button"), py::arg("lock_threshold") = -1.0f);

    m.def("get_merged_mod_flags",    // imgui_internal.h:2947
        ImGui::GetMergedModFlags);

    m.def("dock_context_initialize",    // imgui_internal.h:2954
        ImGui::DockContextInitialize, py::arg("ctx"));

    m.def("dock_context_shutdown",    // imgui_internal.h:2955
        ImGui::DockContextShutdown, py::arg("ctx"));

    m.def("dock_context_clear_nodes",    // imgui_internal.h:2956
        ImGui::DockContextClearNodes,
        py::arg("ctx"), py::arg("root_id"), py::arg("clear_settings_refs"),
        "Use root_id==0 to clear all");

    m.def("dock_context_rebuild_nodes",    // imgui_internal.h:2957
        ImGui::DockContextRebuildNodes, py::arg("ctx"));

    m.def("dock_context_new_frame_update_undocking",    // imgui_internal.h:2958
        ImGui::DockContextNewFrameUpdateUndocking, py::arg("ctx"));

    m.def("dock_context_new_frame_update_docking",    // imgui_internal.h:2959
        ImGui::DockContextNewFrameUpdateDocking, py::arg("ctx"));

    m.def("dock_context_end_frame",    // imgui_internal.h:2960
        ImGui::DockContextEndFrame, py::arg("ctx"));

    m.def("dock_context_gen_node_id",    // imgui_internal.h:2961
        ImGui::DockContextGenNodeID, py::arg("ctx"));

    m.def("dock_context_queue_dock",    // imgui_internal.h:2962
        ImGui::DockContextQueueDock, py::arg("ctx"), py::arg("target"), py::arg("target_node"), py::arg("payload"), py::arg("split_dir"), py::arg("split_ratio"), py::arg("split_outer"));

    m.def("dock_context_queue_undock_window",    // imgui_internal.h:2963
        ImGui::DockContextQueueUndockWindow, py::arg("ctx"), py::arg("window"));

    m.def("dock_context_queue_undock_node",    // imgui_internal.h:2964
        ImGui::DockContextQueueUndockNode, py::arg("ctx"), py::arg("node"));

    m.def("dock_context_calc_drop_pos_for_docking",    // imgui_internal.h:2965
        ImGui::DockContextCalcDropPosForDocking, py::arg("target"), py::arg("target_node"), py::arg("payload"), py::arg("split_dir"), py::arg("split_outer"), py::arg("out_pos"));

    m.def("dock_node_begin_amend_tab_bar",    // imgui_internal.h:2966
        ImGui::DockNodeBeginAmendTabBar, py::arg("node"));

    m.def("dock_node_end_amend_tab_bar",    // imgui_internal.h:2967
        ImGui::DockNodeEndAmendTabBar);

    m.def("get_window_always_want_own_tab_bar",    // imgui_internal.h:2973
        ImGui::GetWindowAlwaysWantOwnTabBar, py::arg("window"));

    m.def("begin_docked",    // imgui_internal.h:2974
        [](ImGuiWindow * window, bool p_open) -> bool
        {
            auto BeginDocked_adapt_modifiable_immutable_to_return = [](ImGuiWindow * window, bool p_open) -> bool
            {
                bool * p_open_adapt_modifiable = & p_open;

                ImGui::BeginDocked(window, p_open_adapt_modifiable);
                return p_open;
            };

            return BeginDocked_adapt_modifiable_immutable_to_return(window, p_open);
        },     py::arg("window"), py::arg("p_open"));

    m.def("begin_dockable_drag_drop_source",    // imgui_internal.h:2975
        ImGui::BeginDockableDragDropSource, py::arg("window"));

    m.def("begin_dockable_drag_drop_target",    // imgui_internal.h:2976
        ImGui::BeginDockableDragDropTarget, py::arg("window"));

    m.def("set_window_dock",    // imgui_internal.h:2977
        ImGui::SetWindowDock, py::arg("window"), py::arg("dock_id"), py::arg("cond"));

    m.def("dock_builder_dock_window",    // imgui_internal.h:2988
        ImGui::DockBuilderDockWindow, py::arg("window_name"), py::arg("node_id"));

    m.def("dock_builder_get_node",    // imgui_internal.h:2989
        ImGui::DockBuilderGetNode,
        py::arg("node_id"),
        pybind11::return_value_policy::reference);

    m.def("dock_builder_add_node",    // imgui_internal.h:2991
        ImGui::DockBuilderAddNode, py::arg("node_id") = 0, py::arg("flags") = 0);

    m.def("dock_builder_remove_node",    // imgui_internal.h:2992
        ImGui::DockBuilderRemoveNode,
        py::arg("node_id"),
        "Remove node and all its child, undock all windows");

    m.def("dock_builder_remove_node_docked_windows",    // imgui_internal.h:2993
        ImGui::DockBuilderRemoveNodeDockedWindows, py::arg("node_id"), py::arg("clear_settings_refs") = true);

    m.def("dock_builder_remove_node_child_nodes",    // imgui_internal.h:2994
        ImGui::DockBuilderRemoveNodeChildNodes,
        py::arg("node_id"),
        "Remove all split/hierarchy. All remaining docked windows will be re-docked to the remaining root node (node_id).");

    m.def("dock_builder_set_node_pos",    // imgui_internal.h:2995
        ImGui::DockBuilderSetNodePos, py::arg("node_id"), py::arg("pos"));

    m.def("dock_builder_set_node_size",    // imgui_internal.h:2996
        ImGui::DockBuilderSetNodeSize, py::arg("node_id"), py::arg("size"));

    m.def("dock_builder_split_node",    // imgui_internal.h:2997
        ImGui::DockBuilderSplitNode,
        py::arg("node_id"), py::arg("split_dir"), py::arg("size_ratio_for_node_at_dir"), py::arg("out_id_at_dir"), py::arg("out_id_at_opposite_dir"),
        "Create 2 child nodes in this parent node.");

    m.def("dock_builder_copy_dock_space",    // imgui_internal.h:2998
        ImGui::DockBuilderCopyDockSpace, py::arg("src_dockspace_id"), py::arg("dst_dockspace_id"), py::arg("in_window_remap_pairs"));

    m.def("dock_builder_copy_node",    // imgui_internal.h:2999
        ImGui::DockBuilderCopyNode, py::arg("src_node_id"), py::arg("dst_node_id"), py::arg("out_node_remap_pairs"));

    m.def("dock_builder_copy_window_settings",    // imgui_internal.h:3000
        ImGui::DockBuilderCopyWindowSettings, py::arg("src_name"), py::arg("dst_name"));

    m.def("dock_builder_finish",    // imgui_internal.h:3001
        ImGui::DockBuilderFinish, py::arg("node_id"));

    m.def("is_drag_drop_active",    // imgui_internal.h:3004
        ImGui::IsDragDropActive);

    m.def("begin_drag_drop_target_custom",    // imgui_internal.h:3005
        ImGui::BeginDragDropTargetCustom, py::arg("bb"), py::arg("id"));

    m.def("clear_drag_drop",    // imgui_internal.h:3006
        ImGui::ClearDragDrop);

    m.def("is_drag_drop_payload_being_accepted",    // imgui_internal.h:3007
        ImGui::IsDragDropPayloadBeingAccepted);

    m.def("set_window_clip_rect_before_set_channel",    // imgui_internal.h:3010
        ImGui::SetWindowClipRectBeforeSetChannel, py::arg("window"), py::arg("clip_rect"));

    m.def("begin_columns",    // imgui_internal.h:3011
        ImGui::BeginColumns,
        py::arg("str_id"), py::arg("count"), py::arg("flags") = 0,
        "setup number of columns. use an identifier to distinguish multiple column sets. close with EndColumns().");

    m.def("end_columns",    // imgui_internal.h:3012
        ImGui::EndColumns, "close columns");

    m.def("push_column_clip_rect",    // imgui_internal.h:3013
        ImGui::PushColumnClipRect, py::arg("column_index"));

    m.def("push_columns_background",    // imgui_internal.h:3014
        ImGui::PushColumnsBackground);

    m.def("pop_columns_background",    // imgui_internal.h:3015
        ImGui::PopColumnsBackground);

    m.def("get_columns_id",    // imgui_internal.h:3016
        ImGui::GetColumnsID, py::arg("str_id"), py::arg("count"));

    m.def("find_or_create_columns",    // imgui_internal.h:3017
        ImGui::FindOrCreateColumns,
        py::arg("window"), py::arg("id"),
        pybind11::return_value_policy::reference);

    m.def("get_column_offset_from_norm",    // imgui_internal.h:3018
        ImGui::GetColumnOffsetFromNorm, py::arg("columns"), py::arg("offset_norm"));

    m.def("get_column_norm_from_offset",    // imgui_internal.h:3019
        ImGui::GetColumnNormFromOffset, py::arg("columns"), py::arg("offset"));

    m.def("table_open_context_menu",    // imgui_internal.h:3022
        py::overload_cast<int>(ImGui::TableOpenContextMenu), py::arg("column_n") = -1);

    m.def("table_set_column_width",    // imgui_internal.h:3023
        py::overload_cast<int, float>(ImGui::TableSetColumnWidth), py::arg("column_n"), py::arg("width"));

    m.def("table_set_column_sort_direction",    // imgui_internal.h:3024
        py::overload_cast<int, ImGuiSortDirection, bool>(ImGui::TableSetColumnSortDirection), py::arg("column_n"), py::arg("sort_direction"), py::arg("append_to_sort_specs"));

    m.def("table_get_hovered_column",    // imgui_internal.h:3025
        py::overload_cast<>(ImGui::TableGetHoveredColumn), "May use (TableGetColumnFlags() & ImGuiTableColumnFlags_IsHovered) instead. Return hovered column. return -1 when table is not hovered. return columns_count if the unused space at the right of visible columns is hovered.");

    m.def("table_get_header_row_height",    // imgui_internal.h:3026
        py::overload_cast<>(ImGui::TableGetHeaderRowHeight));

    m.def("table_push_background_channel",    // imgui_internal.h:3027
        py::overload_cast<>(ImGui::TablePushBackgroundChannel));

    m.def("table_pop_background_channel",    // imgui_internal.h:3028
        py::overload_cast<>(ImGui::TablePopBackgroundChannel));

    m.def("table_find_by_id",    // imgui_internal.h:3032
        py::overload_cast<ImGuiID>(ImGui::TableFindByID),
        py::arg("id"),
        pybind11::return_value_policy::reference);

    m.def("begin_table_ex",    // imgui_internal.h:3033
        ImGui::BeginTableEx, py::arg("name"), py::arg("id"), py::arg("columns_count"), py::arg("flags") = 0, py::arg("outer_size") = ImVec2(0, 0), py::arg("inner_width") = 0.0f);

    m.def("table_begin_init_memory",    // imgui_internal.h:3034
        py::overload_cast<ImGuiTable *, int>(ImGui::TableBeginInitMemory), py::arg("table"), py::arg("columns_count"));

    m.def("table_begin_apply_requests",    // imgui_internal.h:3035
        py::overload_cast<ImGuiTable *>(ImGui::TableBeginApplyRequests), py::arg("table"));

    m.def("table_setup_draw_channels",    // imgui_internal.h:3036
        py::overload_cast<ImGuiTable *>(ImGui::TableSetupDrawChannels), py::arg("table"));

    m.def("table_update_layout",    // imgui_internal.h:3037
        py::overload_cast<ImGuiTable *>(ImGui::TableUpdateLayout), py::arg("table"));

    m.def("table_update_borders",    // imgui_internal.h:3038
        py::overload_cast<ImGuiTable *>(ImGui::TableUpdateBorders), py::arg("table"));

    m.def("table_update_columns_weight_from_width",    // imgui_internal.h:3039
        py::overload_cast<ImGuiTable *>(ImGui::TableUpdateColumnsWeightFromWidth), py::arg("table"));

    m.def("table_draw_borders",    // imgui_internal.h:3040
        py::overload_cast<ImGuiTable *>(ImGui::TableDrawBorders), py::arg("table"));

    m.def("table_draw_context_menu",    // imgui_internal.h:3041
        py::overload_cast<ImGuiTable *>(ImGui::TableDrawContextMenu), py::arg("table"));

    m.def("table_merge_draw_channels",    // imgui_internal.h:3042
        py::overload_cast<ImGuiTable *>(ImGui::TableMergeDrawChannels), py::arg("table"));

    m.def("table_sort_specs_sanitize",    // imgui_internal.h:3044
        py::overload_cast<ImGuiTable *>(ImGui::TableSortSpecsSanitize), py::arg("table"));

    m.def("table_sort_specs_build",    // imgui_internal.h:3045
        py::overload_cast<ImGuiTable *>(ImGui::TableSortSpecsBuild), py::arg("table"));

    m.def("table_get_column_next_sort_direction",    // imgui_internal.h:3046
        py::overload_cast<ImGuiTableColumn *>(ImGui::TableGetColumnNextSortDirection), py::arg("column"));

    m.def("table_fix_column_sort_direction",    // imgui_internal.h:3047
        py::overload_cast<ImGuiTable *, ImGuiTableColumn *>(ImGui::TableFixColumnSortDirection), py::arg("table"), py::arg("column"));

    m.def("table_get_column_width_auto",    // imgui_internal.h:3048
        py::overload_cast<ImGuiTable *, ImGuiTableColumn *>(ImGui::TableGetColumnWidthAuto), py::arg("table"), py::arg("column"));

    m.def("table_begin_row",    // imgui_internal.h:3049
        py::overload_cast<ImGuiTable *>(ImGui::TableBeginRow), py::arg("table"));

    m.def("table_end_row",    // imgui_internal.h:3050
        py::overload_cast<ImGuiTable *>(ImGui::TableEndRow), py::arg("table"));

    m.def("table_begin_cell",    // imgui_internal.h:3051
        py::overload_cast<ImGuiTable *, int>(ImGui::TableBeginCell), py::arg("table"), py::arg("column_n"));

    m.def("table_end_cell",    // imgui_internal.h:3052
        py::overload_cast<ImGuiTable *>(ImGui::TableEndCell), py::arg("table"));

    m.def("table_get_cell_bg_rect",    // imgui_internal.h:3053
        py::overload_cast<const ImGuiTable *, int>(ImGui::TableGetCellBgRect), py::arg("table"), py::arg("column_n"));

    m.def("table_get_column_name",    // imgui_internal.h:3054
        py::overload_cast<const ImGuiTable *, int>(ImGui::TableGetColumnName),
        py::arg("table"), py::arg("column_n"),
        pybind11::return_value_policy::reference);

    m.def("table_get_column_resize_id",    // imgui_internal.h:3055
        py::overload_cast<const ImGuiTable *, int, int>(ImGui::TableGetColumnResizeID), py::arg("table"), py::arg("column_n"), py::arg("instance_no") = 0);

    m.def("table_get_max_column_width",    // imgui_internal.h:3056
        py::overload_cast<const ImGuiTable *, int>(ImGui::TableGetMaxColumnWidth), py::arg("table"), py::arg("column_n"));

    m.def("table_set_column_width_auto_single",    // imgui_internal.h:3057
        py::overload_cast<ImGuiTable *, int>(ImGui::TableSetColumnWidthAutoSingle), py::arg("table"), py::arg("column_n"));

    m.def("table_set_column_width_auto_all",    // imgui_internal.h:3058
        py::overload_cast<ImGuiTable *>(ImGui::TableSetColumnWidthAutoAll), py::arg("table"));

    m.def("table_remove",    // imgui_internal.h:3059
        py::overload_cast<ImGuiTable *>(ImGui::TableRemove), py::arg("table"));

    m.def("table_gc_compact_transient_buffers",    // imgui_internal.h:3060
        py::overload_cast<ImGuiTable *>(ImGui::TableGcCompactTransientBuffers), py::arg("table"));

    m.def("table_gc_compact_transient_buffers",    // imgui_internal.h:3061
        py::overload_cast<ImGuiTableTempData *>(ImGui::TableGcCompactTransientBuffers), py::arg("table"));

    m.def("table_gc_compact_settings",    // imgui_internal.h:3062
        py::overload_cast<>(ImGui::TableGcCompactSettings));

    m.def("table_load_settings",    // imgui_internal.h:3065
        py::overload_cast<ImGuiTable *>(ImGui::TableLoadSettings), py::arg("table"));

    m.def("table_save_settings",    // imgui_internal.h:3066
        py::overload_cast<ImGuiTable *>(ImGui::TableSaveSettings), py::arg("table"));

    m.def("table_reset_settings",    // imgui_internal.h:3067
        py::overload_cast<ImGuiTable *>(ImGui::TableResetSettings), py::arg("table"));

    m.def("table_get_bound_settings",    // imgui_internal.h:3068
        py::overload_cast<ImGuiTable *>(ImGui::TableGetBoundSettings),
        py::arg("table"),
        pybind11::return_value_policy::reference);

    m.def("table_settings_add_settings_handler",    // imgui_internal.h:3069
        py::overload_cast<>(ImGui::TableSettingsAddSettingsHandler));

    m.def("table_settings_create",    // imgui_internal.h:3070
        py::overload_cast<ImGuiID, int>(ImGui::TableSettingsCreate),
        py::arg("id"), py::arg("columns_count"),
        pybind11::return_value_policy::reference);

    m.def("table_settings_find_by_id",    // imgui_internal.h:3071
        py::overload_cast<ImGuiID>(ImGui::TableSettingsFindByID),
        py::arg("id"),
        pybind11::return_value_policy::reference);

    m.def("begin_tab_bar_ex",    // imgui_internal.h:3074
        ImGui::BeginTabBarEx, py::arg("tab_bar"), py::arg("bb"), py::arg("flags"), py::arg("dock_node"));

    m.def("tab_bar_find_tab_by_id",    // imgui_internal.h:3075
        ImGui::TabBarFindTabByID,
        py::arg("tab_bar"), py::arg("tab_id"),
        pybind11::return_value_policy::reference);

    m.def("tab_bar_find_most_recently_selected_tab_for_active_window",    // imgui_internal.h:3076
        ImGui::TabBarFindMostRecentlySelectedTabForActiveWindow,
        py::arg("tab_bar"),
        pybind11::return_value_policy::reference);

    m.def("tab_bar_add_tab",    // imgui_internal.h:3077
        ImGui::TabBarAddTab, py::arg("tab_bar"), py::arg("tab_flags"), py::arg("window"));

    m.def("tab_bar_remove_tab",    // imgui_internal.h:3078
        ImGui::TabBarRemoveTab, py::arg("tab_bar"), py::arg("tab_id"));

    m.def("tab_bar_close_tab",    // imgui_internal.h:3079
        ImGui::TabBarCloseTab, py::arg("tab_bar"), py::arg("tab"));

    m.def("tab_bar_queue_reorder",    // imgui_internal.h:3080
        ImGui::TabBarQueueReorder, py::arg("tab_bar"), py::arg("tab"), py::arg("offset"));

    m.def("tab_bar_queue_reorder_from_mouse_pos",    // imgui_internal.h:3081
        ImGui::TabBarQueueReorderFromMousePos, py::arg("tab_bar"), py::arg("tab"), py::arg("mouse_pos"));

    m.def("tab_bar_process_reorder",    // imgui_internal.h:3082
        ImGui::TabBarProcessReorder, py::arg("tab_bar"));

    m.def("tab_item_ex",    // imgui_internal.h:3083
        [](ImGuiTabBar * tab_bar, const char * label, bool p_open, ImGuiTabItemFlags flags, ImGuiWindow * docked_window) -> std::tuple<bool, bool>
        {
            auto TabItemEx_adapt_modifiable_immutable_to_return = [](ImGuiTabBar * tab_bar, const char * label, bool p_open, ImGuiTabItemFlags flags, ImGuiWindow * docked_window) -> std::tuple<bool, bool>
            {
                bool * p_open_adapt_modifiable = & p_open;

                bool r = ImGui::TabItemEx(tab_bar, label, p_open_adapt_modifiable, flags, docked_window);
                return std::make_tuple(r, p_open);
            };

            return TabItemEx_adapt_modifiable_immutable_to_return(tab_bar, label, p_open, flags, docked_window);
        },     py::arg("tab_bar"), py::arg("label"), py::arg("p_open"), py::arg("flags"), py::arg("docked_window"));

    m.def("tab_item_calc_size",    // imgui_internal.h:3084
        ImGui::TabItemCalcSize, py::arg("label"), py::arg("has_close_button"));

    m.def("tab_item_background",    // imgui_internal.h:3085
        ImGui::TabItemBackground, py::arg("draw_list"), py::arg("bb"), py::arg("flags"), py::arg("col"));

    m.def("tab_item_label_and_close_button",    // imgui_internal.h:3086
        [](ImDrawList * draw_list, const ImRect & bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char * label, ImGuiID tab_id, ImGuiID close_button_id, bool is_contents_visible, bool out_just_closed, bool out_text_clipped) -> std::tuple<bool, bool>
        {
            auto TabItemLabelAndCloseButton_adapt_modifiable_immutable_to_return = [](ImDrawList * draw_list, const ImRect & bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char * label, ImGuiID tab_id, ImGuiID close_button_id, bool is_contents_visible, bool out_just_closed, bool out_text_clipped) -> std::tuple<bool, bool>
            {
                bool * out_just_closed_adapt_modifiable = & out_just_closed;
                bool * out_text_clipped_adapt_modifiable = & out_text_clipped;

                ImGui::TabItemLabelAndCloseButton(draw_list, bb, flags, frame_padding, label, tab_id, close_button_id, is_contents_visible, out_just_closed_adapt_modifiable, out_text_clipped_adapt_modifiable);
                return std::make_tuple(out_just_closed, out_text_clipped);
            };

            return TabItemLabelAndCloseButton_adapt_modifiable_immutable_to_return(draw_list, bb, flags, frame_padding, label, tab_id, close_button_id, is_contents_visible, out_just_closed, out_text_clipped);
        },     py::arg("draw_list"), py::arg("bb"), py::arg("flags"), py::arg("frame_padding"), py::arg("label"), py::arg("tab_id"), py::arg("close_button_id"), py::arg("is_contents_visible"), py::arg("out_just_closed"), py::arg("out_text_clipped"));

    m.def("render_text",    // imgui_internal.h:3091
        ImGui::RenderText, py::arg("pos"), py::arg("text"), py::arg("text_end") = py::none(), py::arg("hide_text_after_hash") = true);

    m.def("render_text_wrapped",    // imgui_internal.h:3092
        ImGui::RenderTextWrapped, py::arg("pos"), py::arg("text"), py::arg("text_end"), py::arg("wrap_width"));

    m.def("render_text_clipped",    // imgui_internal.h:3093
        ImGui::RenderTextClipped, py::arg("pos_min"), py::arg("pos_max"), py::arg("text"), py::arg("text_end"), py::arg("text_size_if_known"), py::arg("align") = ImVec2(0, 0), py::arg("clip_rect") = py::none());

    m.def("render_text_clipped_ex",    // imgui_internal.h:3094
        ImGui::RenderTextClippedEx, py::arg("draw_list"), py::arg("pos_min"), py::arg("pos_max"), py::arg("text"), py::arg("text_end"), py::arg("text_size_if_known"), py::arg("align") = ImVec2(0, 0), py::arg("clip_rect") = py::none());

    m.def("render_text_ellipsis",    // imgui_internal.h:3095
        ImGui::RenderTextEllipsis, py::arg("draw_list"), py::arg("pos_min"), py::arg("pos_max"), py::arg("clip_max_x"), py::arg("ellipsis_max_x"), py::arg("text"), py::arg("text_end"), py::arg("text_size_if_known"));

    m.def("render_frame",    // imgui_internal.h:3096
        ImGui::RenderFrame, py::arg("p_min"), py::arg("p_max"), py::arg("fill_col"), py::arg("border") = true, py::arg("rounding") = 0.0f);

    m.def("render_frame_border",    // imgui_internal.h:3097
        ImGui::RenderFrameBorder, py::arg("p_min"), py::arg("p_max"), py::arg("rounding") = 0.0f);

    m.def("render_color_rect_with_alpha_checkerboard",    // imgui_internal.h:3098
        ImGui::RenderColorRectWithAlphaCheckerboard, py::arg("draw_list"), py::arg("p_min"), py::arg("p_max"), py::arg("fill_col"), py::arg("grid_step"), py::arg("grid_off"), py::arg("rounding") = 0.0f, py::arg("flags") = 0);

    m.def("render_nav_highlight",    // imgui_internal.h:3099
        ImGui::RenderNavHighlight,
        py::arg("bb"), py::arg("id"), py::arg("flags") = ImGuiNavHighlightFlags_TypeDefault,
        "Navigation highlight");

    m.def("find_rendered_text_end",    // imgui_internal.h:3100
        ImGui::FindRenderedTextEnd,
        py::arg("text"), py::arg("text_end") = py::none(),
        "Find the optional ## from which we stop displaying text.",
        pybind11::return_value_policy::reference);

    m.def("render_mouse_cursor",    // imgui_internal.h:3101
        ImGui::RenderMouseCursor, py::arg("pos"), py::arg("scale"), py::arg("mouse_cursor"), py::arg("col_fill"), py::arg("col_border"), py::arg("col_shadow"));

    m.def("render_arrow",    // imgui_internal.h:3104
        ImGui::RenderArrow, py::arg("draw_list"), py::arg("pos"), py::arg("col"), py::arg("dir"), py::arg("scale") = 1.0f);

    m.def("render_bullet",    // imgui_internal.h:3105
        ImGui::RenderBullet, py::arg("draw_list"), py::arg("pos"), py::arg("col"));

    m.def("render_check_mark",    // imgui_internal.h:3106
        ImGui::RenderCheckMark, py::arg("draw_list"), py::arg("pos"), py::arg("col"), py::arg("sz"));

    m.def("render_arrow_pointing_at",    // imgui_internal.h:3107
        ImGui::RenderArrowPointingAt, py::arg("draw_list"), py::arg("pos"), py::arg("half_sz"), py::arg("direction"), py::arg("col"));

    m.def("render_arrow_dock_menu",    // imgui_internal.h:3108
        ImGui::RenderArrowDockMenu, py::arg("draw_list"), py::arg("p_min"), py::arg("sz"), py::arg("col"));

    m.def("render_rect_filled_range_h",    // imgui_internal.h:3109
        ImGui::RenderRectFilledRangeH, py::arg("draw_list"), py::arg("rect"), py::arg("col"), py::arg("x_start_norm"), py::arg("x_end_norm"), py::arg("rounding"));

    m.def("render_rect_filled_with_hole",    // imgui_internal.h:3110
        ImGui::RenderRectFilledWithHole, py::arg("draw_list"), py::arg("outer"), py::arg("inner"), py::arg("col"), py::arg("rounding"));

    m.def("calc_rounding_flags_for_rect_in_rect",    // imgui_internal.h:3111
        ImGui::CalcRoundingFlagsForRectInRect, py::arg("r_in"), py::arg("r_outer"), py::arg("threshold"));

    m.def("text_ex",    // imgui_internal.h:3114
        ImGui::TextEx, py::arg("text"), py::arg("text_end") = py::none(), py::arg("flags") = 0);

    m.def("button_ex",    // imgui_internal.h:3115
        ImGui::ButtonEx, py::arg("label"), py::arg("size_arg") = ImVec2(0, 0), py::arg("flags") = 0);

    m.def("close_button",    // imgui_internal.h:3116
        ImGui::CloseButton, py::arg("id"), py::arg("pos"));

    m.def("collapse_button",    // imgui_internal.h:3117
        ImGui::CollapseButton, py::arg("id"), py::arg("pos"), py::arg("dock_node"));

    m.def("arrow_button_ex",    // imgui_internal.h:3118
        ImGui::ArrowButtonEx, py::arg("str_id"), py::arg("dir"), py::arg("size_arg"), py::arg("flags") = 0);

    m.def("scrollbar",    // imgui_internal.h:3119
        ImGui::Scrollbar, py::arg("axis"));

    m.def("scrollbar_ex",    // imgui_internal.h:3120
        ImGui::ScrollbarEx, py::arg("bb"), py::arg("id"), py::arg("axis"), py::arg("p_scroll_v"), py::arg("avail_v"), py::arg("contents_v"), py::arg("flags"));

    m.def("image_button_ex",    // imgui_internal.h:3121
        ImGui::ImageButtonEx, py::arg("id"), py::arg("texture_id"), py::arg("size"), py::arg("uv0"), py::arg("uv1"), py::arg("padding"), py::arg("bg_col"), py::arg("tint_col"));

    m.def("get_window_scrollbar_rect",    // imgui_internal.h:3122
        ImGui::GetWindowScrollbarRect, py::arg("window"), py::arg("axis"));

    m.def("get_window_scrollbar_id",    // imgui_internal.h:3123
        ImGui::GetWindowScrollbarID, py::arg("window"), py::arg("axis"));

    m.def("get_window_resize_corner_id",    // imgui_internal.h:3124
        ImGui::GetWindowResizeCornerID,
        py::arg("window"), py::arg("n"),
        "0..3: corners");

    m.def("get_window_resize_border_id",    // imgui_internal.h:3125
        ImGui::GetWindowResizeBorderID, py::arg("window"), py::arg("dir"));

    m.def("separator_ex",    // imgui_internal.h:3126
        ImGui::SeparatorEx, py::arg("flags"));

    m.def("checkbox_flags",    // imgui_internal.h:3127
        py::overload_cast<const char *, ImS64 *, ImS64>(ImGui::CheckboxFlags), py::arg("label"), py::arg("flags"), py::arg("flags_value"));

    m.def("checkbox_flags",    // imgui_internal.h:3128
        py::overload_cast<const char *, ImU64 *, ImU64>(ImGui::CheckboxFlags), py::arg("label"), py::arg("flags"), py::arg("flags_value"));

    m.def("button_behavior",    // imgui_internal.h:3131
        [](const ImRect & bb, ImGuiID id, bool out_hovered, bool out_held, ImGuiButtonFlags flags = 0) -> std::tuple<bool, bool, bool>
        {
            auto ButtonBehavior_adapt_modifiable_immutable_to_return = [](const ImRect & bb, ImGuiID id, bool out_hovered, bool out_held, ImGuiButtonFlags flags = 0) -> std::tuple<bool, bool, bool>
            {
                bool * out_hovered_adapt_modifiable = & out_hovered;
                bool * out_held_adapt_modifiable = & out_held;

                bool r = ImGui::ButtonBehavior(bb, id, out_hovered_adapt_modifiable, out_held_adapt_modifiable, flags);
                return std::make_tuple(r, out_hovered, out_held);
            };

            return ButtonBehavior_adapt_modifiable_immutable_to_return(bb, id, out_hovered, out_held, flags);
        },     py::arg("bb"), py::arg("id"), py::arg("out_hovered"), py::arg("out_held"), py::arg("flags") = 0);

    m.def("drag_behavior",    // imgui_internal.h:3132
        py::overload_cast<ImGuiID, ImGuiDataType, void *, float, const void *, const void *, const char *, ImGuiSliderFlags>(ImGui::DragBehavior), py::arg("id"), py::arg("data_type"), py::arg("p_v"), py::arg("v_speed"), py::arg("p_min"), py::arg("p_max"), py::arg("format"), py::arg("flags"));

    m.def("slider_behavior",    // imgui_internal.h:3133
        py::overload_cast<const ImRect &, ImGuiID, ImGuiDataType, void *, const void *, const void *, const char *, ImGuiSliderFlags, ImRect *>(ImGui::SliderBehavior), py::arg("bb"), py::arg("id"), py::arg("data_type"), py::arg("p_v"), py::arg("p_min"), py::arg("p_max"), py::arg("format"), py::arg("flags"), py::arg("out_grab_bb"));

    m.def("splitter_behavior",    // imgui_internal.h:3134
        [](const ImRect & bb, ImGuiID id, ImGuiAxis axis, py::array & size1, py::array & size2, float min_size2, float hover_extend = 0.0f, float hover_visibility_delay = 0.0f, ImU32 bg_col = 0) -> bool
        {
            auto SplitterBehavior_adapt_c_buffers = [](const ImRect & bb, ImGuiID id, ImGuiAxis axis, py::array & size1, py::array & size2, float min_size2, float hover_extend = 0.0f, float hover_visibility_delay = 0.0f, ImU32 bg_col = 0) -> bool
            {
                // convert py::array to C standard buffer (mutable)
                void * size1_from_pyarray = size1.mutable_data();
                py::ssize_t size1_count = size1.shape()[0];
                char size1_type = size1.dtype().char_();
                if (size1_type != 'f')
                    throw std::runtime_error(std::string(R"msg(
                            Bad type!  Expected a numpy array of native type:
                                        float *
                                    Which is equivalent to
                                        f
                                    (using py::array::dtype().char_() as an id)
                        )msg"));

                // convert py::array to C standard buffer (mutable)
                void * size2_from_pyarray = size2.mutable_data();
                py::ssize_t size2_count = size2.shape()[0];
                char size2_type = size2.dtype().char_();
                if (size2_type != 'f')
                    throw std::runtime_error(std::string(R"msg(
                            Bad type!  Expected a numpy array of native type:
                                        float *
                                    Which is equivalent to
                                        f
                                    (using py::array::dtype().char_() as an id)
                        )msg"));

                auto r = ImGui::SplitterBehavior(bb, id, axis, static_cast<float *>(size1_from_pyarray), static_cast<float *>(size2_from_pyarray), static_cast<float>(size2_count), min_size2, hover_extend, hover_visibility_delay, bg_col);
                return r;
            };

            return SplitterBehavior_adapt_c_buffers(bb, id, axis, size1, size2, min_size2, hover_extend, hover_visibility_delay, bg_col);
        },     py::arg("bb"), py::arg("id"), py::arg("axis"), py::arg("size1"), py::arg("size2"), py::arg("min_size2"), py::arg("hover_extend") = 0.0f, py::arg("hover_visibility_delay") = 0.0f, py::arg("bg_col") = 0);

    m.def("tree_node_behavior",    // imgui_internal.h:3135
        ImGui::TreeNodeBehavior, py::arg("id"), py::arg("flags"), py::arg("label"), py::arg("label_end") = py::none());

    m.def("tree_node_behavior_is_open",    // imgui_internal.h:3136
        ImGui::TreeNodeBehaviorIsOpen,
        py::arg("id"), py::arg("flags") = 0,
        "Consume previous SetNextItemOpen() data, if any. May return True when logging");

    m.def("tree_push_override_id",    // imgui_internal.h:3137
        ImGui::TreePushOverrideID, py::arg("id"));

    m.def("color_tooltip",    // imgui_internal.h:3165
        ImGui::ColorTooltip, py::arg("text"), py::arg("col"), py::arg("flags"));

    m.def("color_edit_options_popup",    // imgui_internal.h:3166
        py::overload_cast<const float *, ImGuiColorEditFlags>(ImGui::ColorEditOptionsPopup), py::arg("col"), py::arg("flags"));

    m.def("color_picker_options_popup",    // imgui_internal.h:3167
        py::overload_cast<const float *, ImGuiColorEditFlags>(ImGui::ColorPickerOptionsPopup), py::arg("ref_col"), py::arg("flags"));

    m.def("shade_verts_linear_color_gradient_keep_alpha",    // imgui_internal.h:3173
        ImGui::ShadeVertsLinearColorGradientKeepAlpha, py::arg("draw_list"), py::arg("vert_start_idx"), py::arg("vert_end_idx"), py::arg("gradient_p0"), py::arg("gradient_p1"), py::arg("col0"), py::arg("col1"));

    m.def("shade_verts_linear_uv",    // imgui_internal.h:3174
        ImGui::ShadeVertsLinearUV, py::arg("draw_list"), py::arg("vert_start_idx"), py::arg("vert_end_idx"), py::arg("a"), py::arg("b"), py::arg("uv_a"), py::arg("uv_b"), py::arg("clamp"));

    m.def("gc_compact_transient_misc_buffers",    // imgui_internal.h:3177
        ImGui::GcCompactTransientMiscBuffers);

    m.def("gc_compact_transient_window_buffers",    // imgui_internal.h:3178
        ImGui::GcCompactTransientWindowBuffers, py::arg("window"));

    m.def("gc_awake_transient_window_buffers",    // imgui_internal.h:3179
        ImGui::GcAwakeTransientWindowBuffers, py::arg("window"));

    m.def("debug_log",    // imgui_internal.h:3182
        [](const char * fmt)
        {
            auto DebugLog_adapt_variadic_format = [](const char * fmt)
            {
                ImGui::DebugLog("%s", fmt);
            };

            DebugLog_adapt_variadic_format(fmt);
        },     py::arg("fmt"));

    m.def("show_font_atlas",    // imgui_internal.h:3190
        ImGui::ShowFontAtlas, py::arg("atlas"));

    m.def("debug_hook_id_info",    // imgui_internal.h:3191
        ImGui::DebugHookIdInfo, py::arg("id"), py::arg("data_type"), py::arg("data_id"), py::arg("data_id_end"));

    m.def("debug_node_columns",    // imgui_internal.h:3192
        ImGui::DebugNodeColumns, py::arg("columns"));

    m.def("debug_node_dock_node",    // imgui_internal.h:3193
        ImGui::DebugNodeDockNode, py::arg("node"), py::arg("label"));

    m.def("debug_node_draw_list",    // imgui_internal.h:3194
        py::overload_cast<ImGuiWindow *, ImGuiViewportP *, const ImDrawList *, const char *>(ImGui::DebugNodeDrawList), py::arg("window"), py::arg("viewport"), py::arg("draw_list"), py::arg("label"));

    m.def("debug_node_draw_cmd_show_mesh_and_bounding_box",    // imgui_internal.h:3195
        ImGui::DebugNodeDrawCmdShowMeshAndBoundingBox, py::arg("out_draw_list"), py::arg("draw_list"), py::arg("draw_cmd"), py::arg("show_mesh"), py::arg("show_aabb"));

    m.def("debug_node_font",    // imgui_internal.h:3196
        ImGui::DebugNodeFont, py::arg("font"));

    m.def("debug_node_font_glyph",    // imgui_internal.h:3197
        ImGui::DebugNodeFontGlyph, py::arg("font"), py::arg("glyph"));

    m.def("debug_node_storage",    // imgui_internal.h:3198
        ImGui::DebugNodeStorage, py::arg("storage"), py::arg("label"));

    m.def("debug_node_tab_bar",    // imgui_internal.h:3199
        ImGui::DebugNodeTabBar, py::arg("tab_bar"), py::arg("label"));

    m.def("debug_node_table",    // imgui_internal.h:3200
        ImGui::DebugNodeTable, py::arg("table"));

    m.def("debug_node_table_settings",    // imgui_internal.h:3201
        ImGui::DebugNodeTableSettings, py::arg("settings"));

    m.def("debug_node_input_text_state",    // imgui_internal.h:3202
        ImGui::DebugNodeInputTextState, py::arg("state"));

    m.def("debug_node_window",    // imgui_internal.h:3203
        ImGui::DebugNodeWindow, py::arg("window"), py::arg("label"));

    m.def("debug_node_window_settings",    // imgui_internal.h:3204
        ImGui::DebugNodeWindowSettings, py::arg("settings"));

    m.def("debug_node_windows_list",    // imgui_internal.h:3205
        ImGui::DebugNodeWindowsList, py::arg("windows"), py::arg("label"));

    m.def("debug_node_viewport",    // imgui_internal.h:3207
        ImGui::DebugNodeViewport, py::arg("viewport"));

    m.def("debug_render_viewport_thumbnail",    // imgui_internal.h:3208
        ImGui::DebugRenderViewportThumbnail, py::arg("draw_list"), py::arg("viewport"), py::arg("bb"));


    auto pyClassImFontBuilderIO =
        py::class_<ImFontBuilderIO>    // imgui_internal.h:3218
            (m, "ImFontBuilderIO", "This structure is likely to evolve as we add support for incremental atlas updates")
        .def(py::init<>()) // implicit default constructor
        ;

    { // <namespace ImStb>
        py::module_ pyNsImStb = m.def_submodule("ImStb", "");
    } // </namespace ImStb>
    ////////////////////    </generated_from:imgui_internal.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
